Global Const $bs_groupbox = 0x7
Global Const $bs_bottom = 0x800
Global Const $bs_center = 0x300
Global Const $bs_defpushbutton = 0x1
Global Const $bs_left = 0x100
Global Const $bs_multiline = 0x2000
Global Const $bs_pushbox = 0xa
Global Const $bs_pushlike = 0x1000
Global Const $bs_right = 0x200
Global Const $bs_rightbutton = 0x20
Global Const $bs_top = 0x400
Global Const $bs_vcenter = 0xc00
Global Const $bs_flat = 0x8000
Global Const $bs_icon = 0x40
Global Const $bs_bitmap = 0x80
Global Const $bs_notify = 0x4000
Global Const $bs_splitbutton = 0xc
Global Const $bs_defsplitbutton = 0xd
Global Const $bs_commandlink = 0xe
Global Const $bs_defcommandlink = 0xf
Global Const $bcsif_glyph = 0x1
Global Const $bcsif_image = 0x2
Global Const $bcsif_style = 0x4
Global Const $bcsif_size = 0x8
Global Const $bcss_nosplit = 0x1
Global Const $bcss_stretch = 0x2
Global Const $bcss_alignleft = 0x4
Global Const $bcss_image = 0x8
Global Const $button_imagelist_align_left = 0x0
Global Const $button_imagelist_align_right = 0x1
Global Const $button_imagelist_align_top = 0x2
Global Const $button_imagelist_align_bottom = 0x3
Global Const $button_imagelist_align_center = 0x4
Global Const $bs_3state = 0x5
Global Const $bs_auto3state = 0x6
Global Const $bs_autocheckbox = 0x3
Global Const $bs_checkbox = 0x2
Global Const $bs_radiobutton = 0x4
Global Const $bs_autoradiobutton = 0x9
Global Const $bs_ownerdraw = 0xb
Global Const $gui_ss_default_button = 0x0
Global Const $gui_ss_default_checkbox = 0x0
Global Const $gui_ss_default_group = 0x0
Global Const $gui_ss_default_radio = 0x0
Global Const $bcm_first = 0x1600
Global Const $bcm_getidealsize = ($bcm_first + 0x1)
Global Const $bcm_getimagelist = ($bcm_first + 0x3)
Global Const $bcm_getnote = ($bcm_first + 0xa)
Global Const $bcm_getnotelength = ($bcm_first + 0xb)
Global Const $bcm_getsplitinfo = ($bcm_first + 0x8)
Global Const $bcm_gettextmargin = ($bcm_first + 0x5)
Global Const $bcm_setdropdownstate = ($bcm_first + 0x6)
Global Const $bcm_setimagelist = ($bcm_first + 0x2)
Global Const $bcm_setnote = ($bcm_first + 0x9)
Global Const $bcm_setshield = ($bcm_first + 0xc)
Global Const $bcm_setsplitinfo = ($bcm_first + 0x7)
Global Const $bcm_settextmargin = ($bcm_first + 0x4)
Global Const $bm_click = 0xf5
Global Const $bm_getcheck = 0xf0
Global Const $bm_getimage = 0xf6
Global Const $bm_getstate = 0xf2
Global Const $bm_setcheck = 0xf1
Global Const $bm_setdontclick = 0xf8
Global Const $bm_setimage = 0xf7
Global Const $bm_setstate = 0xf3
Global Const $bm_setstyle = 0xf4
Global Const $bcn_first = +0xfffffb1e
Global Const $bcn_dropdown = ($bcn_first + 0x2)
Global Const $bcn_hotitemchange = ($bcn_first + 0x1)
Global Const $bn_clicked = 0x0
Global Const $bn_paint = 0x1
Global Const $bn_hilite = 0x2
Global Const $bn_unhilite = 0x3
Global Const $bn_disable = 0x4
Global Const $bn_doubleclicked = 0x5
Global Const $bn_setfocus = 0x6
Global Const $bn_killfocus = 0x7
Global Const $bn_pushed = $bn_hilite
Global Const $bn_unpushed = $bn_unhilite
Global Const $bn_dblclk = $bn_doubleclicked
Global Const $bst_checked = 0x1
Global Const $bst_indeterminate = 0x2
Global Const $bst_unchecked = 0x0
Global Const $bst_focus = 0x8
Global Const $bst_pushed = 0x4
Global Const $bst_dontclick = 0x80
Global Const $es_left = 0x0
Global Const $es_center = 0x1
Global Const $es_right = 0x2
Global Const $es_multiline = 0x4
Global Const $es_uppercase = 0x8
Global Const $es_lowercase = 0x10
Global Const $es_password = 0x20
Global Const $es_autovscroll = 0x40
Global Const $es_autohscroll = 0x80
Global Const $es_nohidesel = 0x100
Global Const $es_oemconvert = 0x400
Global Const $es_readonly = 0x800
Global Const $es_wantreturn = 0x1000
Global Const $es_number = 0x2000
Global Const $ec_err = +0xffffffff
Global Const $ecm_first = 0x1500
Global Const $em_canundo = 0xc6
Global Const $em_charfrompos = 0xd7
Global Const $em_emptyundobuffer = 0xcd
Global Const $em_fmtlines = 0xc8
Global Const $em_getcuebanner = ($ecm_first + 0x2)
Global Const $em_getfirstvisibleline = 0xce
Global Const $em_gethandle = 0xbd
Global Const $em_getimestatus = 0xd9
Global Const $em_getlimittext = 0xd5
Global Const $em_getline = 0xc4
Global Const $em_getlinecount = 0xba
Global Const $em_getmargins = 0xd4
Global Const $em_getmodify = 0xb8
Global Const $em_getpasswordchar = 0xd2
Global Const $em_getrect = 0xb2
Global Const $em_getsel = 0xb0
Global Const $em_getthumb = 0xbe
Global Const $em_getwordbreakproc = 0xd1
Global Const $em_hideballoontip = ($ecm_first + 0x4)
Global Const $em_limittext = 0xc5
Global Const $em_linefromchar = 0xc9
Global Const $em_lineindex = 0xbb
Global Const $em_linelength = 0xc1
Global Const $em_linescroll = 0xb6
Global Const $em_posfromchar = 0xd6
Global Const $em_replacesel = 0xc2
Global Const $em_scroll = 0xb5
Global Const $em_scrollcaret = 0xb7
Global Const $em_setcuebanner = ($ecm_first + 0x1)
Global Const $em_sethandle = 0xbc
Global Const $em_setimestatus = 0xd8
Global Const $em_setlimittext = $em_limittext
Global Const $em_setmargins = 0xd3
Global Const $em_setmodify = 0xb9
Global Const $em_setpasswordchar = 0xcc
Global Const $em_setreadonly = 0xcf
Global Const $em_setrect = 0xb3
Global Const $em_setrectnp = 0xb4
Global Const $em_setsel = 0xb1
Global Const $em_settabstops = 0xcb
Global Const $em_setwordbreakproc = 0xd0
Global Const $em_showballoontip = ($ecm_first + 0x3)
Global Const $em_undo = 0xc7
Global Const $ec_leftmargin = 0x1
Global Const $ec_rightmargin = 0x2
Global Const $ec_usefontinfo = 0xffff
Global Const $emsis_compositionstring = 0x1
Global Const $eimes_getcompstratonce = 0x1
Global Const $eimes_cancelcompstrinfocus = 0x2
Global Const $eimes_completecompstrkillfocus = 0x4
Global Const $en_align_ltr_ec = 0x700
Global Const $en_align_rtl_ec = 0x701
Global Const $en_change = 0x300
Global Const $en_errspace = 0x500
Global Const $en_hscroll = 0x601
Global Const $en_killfocus = 0x200
Global Const $en_maxtext = 0x501
Global Const $en_setfocus = 0x100
Global Const $en_update = 0x400
Global Const $en_vscroll = 0x602
Global Const $gui_ss_default_edit = 0x3010c0
Global Const $gui_ss_default_input = 0x80
Global Const $gui_event_single = 0x0
Global Const $gui_event_array = 0x1
Global Const $gui_event_none = 0x0
Global Const $gui_event_close = +0xfffffffd
Global Const $gui_event_minimize = +0xfffffffc
Global Const $gui_event_restore = +0xfffffffb
Global Const $gui_event_maximize = +0xfffffffa
Global Const $gui_event_primarydown = +0xfffffff9
Global Const $gui_event_primaryup = +0xfffffff8
Global Const $gui_event_secondarydown = +0xfffffff7
Global Const $gui_event_secondaryup = +0xfffffff6
Global Const $gui_event_mousemove = +0xfffffff5
Global Const $gui_event_resized = +0xfffffff4
Global Const $gui_event_dropped = +0xfffffff3
Global Const $gui_rundefmsg = "GUI_RUNDEFMSG"
Global Const $gui_avistop = 0x0
Global Const $gui_avistart = 0x1
Global Const $gui_aviclose = 0x2
Global Const $gui_checked = 0x1
Global Const $gui_indeterminate = 0x2
Global Const $gui_unchecked = 0x4
Global Const $gui_dropaccepted = 0x8
Global Const $gui_nodropaccepted = 0x1000
Global Const $gui_acceptfiles = $gui_dropaccepted
Global Const $gui_show = 0x10
Global Const $gui_hide = 0x20
Global Const $gui_enable = 0x40
Global Const $gui_disable = 0x80
Global Const $gui_focus = 0x100
Global Const $gui_nofocus = 0x2000
Global Const $gui_defbutton = 0x200
Global Const $gui_expand = 0x400
Global Const $gui_ontop = 0x800
Global Const $gui_fontnormal = 0x0
Global Const $gui_fontitalic = 0x2
Global Const $gui_fontunder = 0x4
Global Const $gui_fontstrike = 0x8
Global Const $gui_dockauto = 0x1
Global Const $gui_dockleft = 0x2
Global Const $gui_dockright = 0x4
Global Const $gui_dockhcenter = 0x8
Global Const $gui_docktop = 0x20
Global Const $gui_dockbottom = 0x40
Global Const $gui_dockvcenter = 0x80
Global Const $gui_dockwidth = 0x100
Global Const $gui_dockheight = 0x200
Global Const $gui_docksize = 0x300
Global Const $gui_dockmenubar = 0x220
Global Const $gui_dockstatebar = 0x240
Global Const $gui_dockall = 0x322
Global Const $gui_dockborders = 0x66
Global Const $gui_gr_close = 0x1
Global Const $gui_gr_line = 0x2
Global Const $gui_gr_bezier = 0x4
Global Const $gui_gr_move = 0x6
Global Const $gui_gr_color = 0x8
Global Const $gui_gr_rect = 0xa
Global Const $gui_gr_ellipse = 0xc
Global Const $gui_gr_pie = 0xe
Global Const $gui_gr_dot = 0x10
Global Const $gui_gr_pixel = 0x12
Global Const $gui_gr_hint = 0x14
Global Const $gui_gr_refresh = 0x16
Global Const $gui_gr_pensize = 0x18
Global Const $gui_gr_nobkcolor = +0xfffffffe
Global Const $gui_bkcolor_default = +0xffffffff
Global Const $gui_bkcolor_transparent = +0xfffffffe
Global Const $gui_bkcolor_lv_alternate = 0xfe000000
Global Const $gui_read_default = 0x0
Global Const $gui_read_extended = 0x1
Global Const $gui_cursor_nooverride = 0x0
Global Const $gui_cursor_override = 0x1
Global Const $gui_ws_ex_parentdrag = 0x100000
Global Const $ss_left = 0x0
Global Const $ss_center = 0x1
Global Const $ss_right = 0x2
Global Const $ss_icon = 0x3
Global Const $ss_blackrect = 0x4
Global Const $ss_grayrect = 0x5
Global Const $ss_whiterect = 0x6
Global Const $ss_blackframe = 0x7
Global Const $ss_grayframe = 0x8
Global Const $ss_whiteframe = 0x9
Global Const $ss_simple = 0xb
Global Const $ss_leftnowordwrap = 0xc
Global Const $ss_bitmap = 0xe
Global Const $ss_enhmetafile = 0xf
Global Const $ss_etchedhorz = 0x10
Global Const $ss_etchedvert = 0x11
Global Const $ss_etchedframe = 0x12
Global Const $ss_realsizecontrol = 0x40
Global Const $ss_noprefix = 0x80
Global Const $ss_notify = 0x100
Global Const $ss_centerimage = 0x200
Global Const $ss_rightjust = 0x400
Global Const $ss_sunken = 0x1000
Global Const $gui_ss_default_label = 0x0
Global Const $gui_ss_default_graphic = 0x0
Global Const $gui_ss_default_icon = $ss_notify
Global Const $gui_ss_default_pic = $ss_notify
Global Const $stm_seticon = 0x170
Global Const $stm_geticon = 0x171
Global Const $stm_setimage = 0x172
Global Const $stm_getimage = 0x173
Global Const $wc_animate = "SysAnimate32"
Global Const $wc_button = "Button"
Global Const $wc_combobox = "ComboBox"
Global Const $wc_comboboxex = "ComboBoxEx32"
Global Const $wc_datetimepick = "SysDateTimePick32"
Global Const $wc_edit = "Edit"
Global Const $wc_header = "SysHeader32"
Global Const $wc_hotkey = "msctls_hotkey32"
Global Const $wc_ipaddress = "SysIPAddress32"
Global Const $wc_link = "SysLink"
Global Const $wc_listbox = "ListBox"
Global Const $wc_listview = "SysListView32"
Global Const $wc_monthcal = "SysMonthCal32"
Global Const $wc_nativefontctl = "NativeFontCtl"
Global Const $wc_pagescroller = "SysPager"
Global Const $wc_progress = "msctls_progress32"
Global Const $wc_rebar = "ReBarWindow32"
Global Const $wc_scrollbar = "ScrollBar"
Global Const $wc_static = "Static"
Global Const $wc_statusbar = "msctls_statusbar32"
Global Const $wc_tabcontrol = "SysTabControl32"
Global Const $wc_toolbar = "ToolbarWindow32"
Global Const $wc_tooltips = "tooltips_class32"
Global Const $wc_trackbar = "msctls_trackbar32"
Global Const $wc_treeview = "SysTreeView32"
Global Const $wc_updown = "msctls_updown32"
Global Const $ws_overlapped = 0x0
Global Const $ws_tiled = $ws_overlapped
Global Const $ws_maximizebox = 0x10000
Global Const $ws_minimizebox = 0x20000
Global Const $ws_tabstop = 0x10000
Global Const $ws_group = 0x20000
Global Const $ws_sizebox = 0x40000
Global Const $ws_thickframe = $ws_sizebox
Global Const $ws_sysmenu = 0x80000
Global Const $ws_hscroll = 0x100000
Global Const $ws_vscroll = 0x200000
Global Const $ws_dlgframe = 0x400000
Global Const $ws_border = 0x800000
Global Const $ws_caption = 0xc00000
Global Const $ws_overlappedwindow = BitOR($ws_caption, $ws_maximizebox, $ws_minimizebox, $ws_overlapped, $ws_sysmenu, $ws_thickframe)
Global Const $ws_tiledwindow = $ws_overlappedwindow
Global Const $ws_maximize = 0x1000000
Global Const $ws_clipchildren = 0x2000000
Global Const $ws_clipsiblings = 0x4000000
Global Const $ws_disabled = 0x8000000
Global Const $ws_visible = 0x10000000
Global Const $ws_minimize = 0x20000000
Global Const $ws_iconic = $ws_minimize
Global Const $ws_child = 0x40000000
Global Const $ws_childwindow = $ws_child
Global Const $ws_popup = 0x80000000
Global Const $ws_popupwindow = 0x80880000
Global Const $ds_3dlook = 0x4
Global Const $ds_absalign = 0x1
Global Const $ds_center = 0x800
Global Const $ds_centermouse = 0x1000
Global Const $ds_contexthelp = 0x2000
Global Const $ds_control = 0x400
Global Const $ds_fixedsys = 0x8
Global Const $ds_localedit = 0x20
Global Const $ds_modalframe = 0x80
Global Const $ds_nofailcreate = 0x10
Global Const $ds_noidlemsg = 0x100
Global Const $ds_setfont = 0x40
Global Const $ds_setforeground = 0x200
Global Const $ds_shellfont = BitOR($ds_fixedsys, $ds_setfont)
Global Const $ds_sysmodal = 0x2
Global Const $ws_ex_acceptfiles = 0x10
Global Const $ws_ex_appwindow = 0x40000
Global Const $ws_ex_composited = 0x2000000
Global Const $ws_ex_controlparent = 0x10000
Global Const $ws_ex_clientedge = 0x200
Global Const $ws_ex_contexthelp = 0x400
Global Const $ws_ex_dlgmodalframe = 0x1
Global Const $ws_ex_layered = 0x80000
Global Const $ws_ex_layoutrtl = 0x400000
Global Const $ws_ex_left = 0x0
Global Const $ws_ex_leftscrollbar = 0x4000
Global Const $ws_ex_ltrreading = 0x0
Global Const $ws_ex_mdichild = 0x40
Global Const $ws_ex_noactivate = 0x8000000
Global Const $ws_ex_noinheritlayout = 0x100000
Global Const $ws_ex_noparentnotify = 0x4
Global Const $ws_ex_noredirectionbitmap = 0x200000
Global Const $ws_ex_right = 0x1000
Global Const $ws_ex_rightscrollbar = 0x0
Global Const $ws_ex_rtlreading = 0x2000
Global Const $ws_ex_staticedge = 0x20000
Global Const $ws_ex_toolwindow = 0x80
Global Const $ws_ex_topmost = 0x8
Global Const $ws_ex_transparent = 0x20
Global Const $ws_ex_windowedge = 0x100
Global Const $ws_ex_overlappedwindow = BitOR($ws_ex_clientedge, $ws_ex_windowedge)
Global Const $ws_ex_palettewindow = BitOR($ws_ex_toolwindow, $ws_ex_topmost, $ws_ex_windowedge)
Global Const $wm_null = 0x0
Global Const $wm_create = 0x1
Global Const $wm_destroy = 0x2
Global Const $wm_move = 0x3
Global Const $wm_sizewait = 0x4
Global Const $wm_size = 0x5
Global Const $wm_activate = 0x6
Global Const $wm_setfocus = 0x7
Global Const $wm_killfocus = 0x8
Global Const $wm_setvisible = 0x9
Global Const $wm_enable = 0xa
Global Const $wm_setredraw = 0xb
Global Const $wm_settext = 0xc
Global Const $wm_gettext = 0xd
Global Const $wm_gettextlength = 0xe
Global Const $wm_paint = 0xf
Global Const $wm_close = 0x10
Global Const $wm_queryendsession = 0x11
Global Const $wm_quit = 0x12
Global Const $wm_erasebkgnd = 0x14
Global Const $wm_queryopen = 0x13
Global Const $wm_syscolorchange = 0x15
Global Const $wm_endsession = 0x16
Global Const $wm_systemerror = 0x17
Global Const $wm_showwindow = 0x18
Global Const $wm_ctlcolor = 0x19
Global Const $wm_settingchange = 0x1a
Global Const $wm_wininichange = 0x1a
Global Const $wm_devmodechange = 0x1b
Global Const $wm_activateapp = 0x1c
Global Const $wm_fontchange = 0x1d
Global Const $wm_timechange = 0x1e
Global Const $wm_cancelmode = 0x1f
Global Const $wm_setcursor = 0x20
Global Const $wm_mouseactivate = 0x21
Global Const $wm_childactivate = 0x22
Global Const $wm_queuesync = 0x23
Global Const $wm_getminmaxinfo = 0x24
Global Const $wm_logoff = 0x25
Global Const $wm_painticon = 0x26
Global Const $wm_iconerasebkgnd = 0x27
Global Const $wm_nextdlgctl = 0x28
Global Const $wm_alttabactive = 0x29
Global Const $wm_spoolerstatus = 0x2a
Global Const $wm_drawitem = 0x2b
Global Const $wm_measureitem = 0x2c
Global Const $wm_deleteitem = 0x2d
Global Const $wm_vkeytoitem = 0x2e
Global Const $wm_chartoitem = 0x2f
Global Const $wm_setfont = 0x30
Global Const $wm_getfont = 0x31
Global Const $wm_sethotkey = 0x32
Global Const $wm_gethotkey = 0x33
Global Const $wm_filesyschange = 0x34
Global Const $wm_isactiveicon = 0x35
Global Const $wm_queryparkicon = 0x36
Global Const $wm_querydragicon = 0x37
Global Const $wm_winhelp = 0x38
Global Const $wm_compareitem = 0x39
Global Const $wm_fullscreen = 0x3a
Global Const $wm_clientshutdown = 0x3b
Global Const $wm_ddemlevent = 0x3c
Global Const $wm_getobject = 0x3d
Global Const $wm_calcscroll = 0x3f
Global Const $wm_testing = 0x40
Global Const $wm_compacting = 0x41
Global Const $wm_otherwindowcreated = 0x42
Global Const $wm_otherwindowdestroyed = 0x43
Global Const $wm_commnotify = 0x44
Global Const $wm_mediastatuschange = 0x45
Global Const $wm_windowposchanging = 0x46
Global Const $wm_windowposchanged = 0x47
Global Const $wm_power = 0x48
Global Const $wm_copyglobaldata = 0x49
Global Const $wm_copydata = 0x4a
Global Const $wm_canceljournal = 0x4b
Global Const $wm_logonnotify = 0x4c
Global Const $wm_keyf1 = 0x4d
Global Const $wm_notify = 0x4e
Global Const $wm_access_window = 0x4f
Global Const $wm_inputlangchangerequest = 0x50
Global Const $wm_inputlangchange = 0x51
Global Const $wm_tcard = 0x52
Global Const $wm_help = 0x53
Global Const $wm_userchanged = 0x54
Global Const $wm_notifyformat = 0x55
Global Const $wm_qm_activate = 0x60
Global Const $wm_hook_do_callback = 0x61
Global Const $wm_syscopydata = 0x62
Global Const $wm_finaldestroy = 0x70
Global Const $wm_measureitem_clientdata = 0x71
Global Const $wm_contextmenu = 0x7b
Global Const $wm_stylechanging = 0x7c
Global Const $wm_stylechanged = 0x7d
Global Const $wm_displaychange = 0x7e
Global Const $wm_geticon = 0x7f
Global Const $wm_seticon = 0x80
Global Const $wm_nccreate = 0x81
Global Const $wm_ncdestroy = 0x82
Global Const $wm_nccalcsize = 0x83
Global Const $wm_nchittest = 0x84
Global Const $wm_ncpaint = 0x85
Global Const $wm_ncactivate = 0x86
Global Const $wm_getdlgcode = 0x87
Global Const $wm_syncpaint = 0x88
Global Const $wm_synctask = 0x89
Global Const $wm_kludgeminrect = 0x8b
Global Const $wm_lpkdrawswitchwnd = 0x8c
Global Const $wm_uahdestroywindow = 0x90
Global Const $wm_uahdrawmenu = 0x91
Global Const $wm_uahdrawmenuitem = 0x92
Global Const $wm_uahinitmenu = 0x93
Global Const $wm_uahmeasuremenuitem = 0x94
Global Const $wm_uahncpaintmenupopup = 0x95
Global Const $wm_ncmousemove = 0xa0
Global Const $wm_nclbuttondown = 0xa1
Global Const $wm_nclbuttonup = 0xa2
Global Const $wm_nclbuttondblclk = 0xa3
Global Const $wm_ncrbuttondown = 0xa4
Global Const $wm_ncrbuttonup = 0xa5
Global Const $wm_ncrbuttondblclk = 0xa6
Global Const $wm_ncmbuttondown = 0xa7
Global Const $wm_ncmbuttonup = 0xa8
Global Const $wm_ncmbuttondblclk = 0xa9
Global Const $wm_ncxbuttondown = 0xab
Global Const $wm_ncxbuttonup = 0xac
Global Const $wm_ncxbuttondblclk = 0xad
Global Const $wm_ncuahdrawcaption = 0xae
Global Const $wm_ncuahdrawframe = 0xaf
Global Const $wm_input_device_change = 0xfe
Global Const $wm_input = 0xff
Global Const $wm_keydown = 0x100
Global Const $wm_keyfirst = 0x100
Global Const $wm_keyup = 0x101
Global Const $wm_char = 0x102
Global Const $wm_deadchar = 0x103
Global Const $wm_syskeydown = 0x104
Global Const $wm_syskeyup = 0x105
Global Const $wm_syschar = 0x106
Global Const $wm_sysdeadchar = 0x107
Global Const $wm_yomichar = 0x108
Global Const $wm_keylast = 0x109
Global Const $wm_unichar = 0x109
Global Const $wm_convertrequest = 0x10a
Global Const $wm_convertresult = 0x10b
Global Const $wm_im_info = 0x10c
Global Const $wm_ime_startcomposition = 0x10d
Global Const $wm_ime_endcomposition = 0x10e
Global Const $wm_ime_composition = 0x10f
Global Const $wm_ime_keylast = 0x10f
Global Const $wm_initdialog = 0x110
Global Const $wm_command = 0x111
Global Const $wm_syscommand = 0x112
Global Const $wm_timer = 0x113
Global Const $wm_hscroll = 0x114
Global Const $wm_vscroll = 0x115
Global Const $wm_initmenu = 0x116
Global Const $wm_initmenupopup = 0x117
Global Const $wm_systimer = 0x118
Global Const $wm_gesture = 0x119
Global Const $wm_gesturenotify = 0x11a
Global Const $wm_gestureinput = 0x11b
Global Const $wm_gesturenotified = 0x11c
Global Const $wm_menuselect = 0x11f
Global Const $wm_menuchar = 0x120
Global Const $wm_enteridle = 0x121
Global Const $wm_menurbuttonup = 0x122
Global Const $wm_menudrag = 0x123
Global Const $wm_menugetobject = 0x124
Global Const $wm_uninitmenupopup = 0x125
Global Const $wm_menucommand = 0x126
Global Const $wm_changeuistate = 0x127
Global Const $wm_updateuistate = 0x128
Global Const $wm_queryuistate = 0x129
Global Const $wm_lbtrackpoint = 0x131
Global Const $wm_ctlcolormsgbox = 0x132
Global Const $wm_ctlcoloredit = 0x133
Global Const $wm_ctlcolorlistbox = 0x134
Global Const $wm_ctlcolorbtn = 0x135
Global Const $wm_ctlcolordlg = 0x136
Global Const $wm_ctlcolorscrollbar = 0x137
Global Const $wm_ctlcolorstatic = 0x138
Global Const $mn_gethmenu = 0x1e1
Global Const $wm_parentnotify = 0x210
Global Const $wm_entermenuloop = 0x211
Global Const $wm_exitmenuloop = 0x212
Global Const $wm_nextmenu = 0x213
Global Const $wm_sizing = 0x214
Global Const $wm_capturechanged = 0x215
Global Const $wm_moving = 0x216
Global Const $wm_powerbroadcast = 0x218
Global Const $wm_devicechange = 0x219
Global Const $wm_mdicreate = 0x220
Global Const $wm_mdidestroy = 0x221
Global Const $wm_mdiactivate = 0x222
Global Const $wm_mdirestore = 0x223
Global Const $wm_mdinext = 0x224
Global Const $wm_mdimaximize = 0x225
Global Const $wm_mditile = 0x226
Global Const $wm_mdicascade = 0x227
Global Const $wm_mdiiconarrange = 0x228
Global Const $wm_mdigetactive = 0x229
Global Const $wm_dropobject = 0x22a
Global Const $wm_querydropobject = 0x22b
Global Const $wm_begindrag = 0x22c
Global Const $wm_dragloop = 0x22d
Global Const $wm_dragselect = 0x22e
Global Const $wm_dragmove = 0x22f
Global Const $wm_mdisetmenu = 0x230
Global Const $wm_entersizemove = 0x231
Global Const $wm_exitsizemove = 0x232
Global Const $wm_dropfiles = 0x233
Global Const $wm_mdirefreshmenu = 0x234
Global Const $wm_touch = 0x240
Global Const $wm_ime_setcontext = 0x281
Global Const $wm_ime_notify = 0x282
Global Const $wm_ime_control = 0x283
Global Const $wm_ime_compositionfull = 0x284
Global Const $wm_ime_select = 0x285
Global Const $wm_ime_char = 0x286
Global Const $wm_ime_system = 0x287
Global Const $wm_ime_request = 0x288
Global Const $wm_ime_keydown = 0x290
Global Const $wm_ime_keyup = 0x291
Global Const $wm_ncmousehover = 0x2a0
Global Const $wm_mousehover = 0x2a1
Global Const $wm_ncmouseleave = 0x2a2
Global Const $wm_mouseleave = 0x2a3
Global Const $wm_wtssession_change = 0x2b1
Global Const $wm_tablet_first = 0x2c0
Global Const $wm_tablet_last = 0x2df
Global Const $wm_cut = 0x300
Global Const $wm_copy = 0x301
Global Const $wm_paste = 0x302
Global Const $wm_clear = 0x303
Global Const $wm_undo = 0x304
Global Const $wm_paletteischanging = 0x310
Global Const $wm_hotkey = 0x312
Global Const $wm_palettechanged = 0x311
Global Const $wm_sysmenu = 0x313
Global Const $wm_hookmsg = 0x314
Global Const $wm_exitprocess = 0x315
Global Const $wm_wakethread = 0x316
Global Const $wm_print = 0x317
Global Const $wm_printclient = 0x318
Global Const $wm_appcommand = 0x319
Global Const $wm_querynewpalette = 0x30f
Global Const $wm_themechanged = 0x31a
Global Const $wm_uahinit = 0x31b
Global Const $wm_desktopnotify = 0x31c
Global Const $wm_clipboardupdate = 0x31d
Global Const $wm_dwmcompositionchanged = 0x31e
Global Const $wm_dwmncrenderingchanged = 0x31f
Global Const $wm_dwmcolorizationcolorchanged = 0x320
Global Const $wm_dwmwindowmaximizedchange = 0x321
Global Const $wm_dwmexileframe = 0x322
Global Const $wm_dwmsendiconicthumbnail = 0x323
Global Const $wm_magnification_started = 0x324
Global Const $wm_magnification_ended = 0x325
Global Const $wm_dwmsendiconiclivepreviewbitmap = 0x326
Global Const $wm_dwmthumbnailsizechanged = 0x327
Global Const $wm_magnification_output = 0x328
Global Const $wm_measurecontrol = 0x330
Global Const $wm_getactiontext = 0x331
Global Const $wm_forwardkeydown = 0x333
Global Const $wm_forwardkeyup = 0x334
Global Const $wm_gettitlebarinfoex = 0x33f
Global Const $wm_notifywow = 0x340
Global Const $wm_handheldfirst = 0x358
Global Const $wm_handheldlast = 0x35f
Global Const $wm_afxfirst = 0x360
Global Const $wm_afxlast = 0x37f
Global Const $wm_penwinfirst = 0x380
Global Const $wm_penwinlast = 0x38f
Global Const $wm_dde_initiate = 0x3e0
Global Const $wm_dde_terminate = 0x3e1
Global Const $wm_dde_advise = 0x3e2
Global Const $wm_dde_unadvise = 0x3e3
Global Const $wm_dde_ack = 0x3e4
Global Const $wm_dde_data = 0x3e5
Global Const $wm_dde_request = 0x3e6
Global Const $wm_dde_poke = 0x3e7
Global Const $wm_dde_execute = 0x3e8
Global Const $wm_dbnotification = 0x3fd
Global Const $wm_netconnect = 0x3fe
Global Const $wm_hibernate = 0x3ff
Global Const $wm_user = 0x400
Global Const $wm_app = 0x8000
Global Const $nm_first = 0x0
Global Const $nm_outofmemory = $nm_first + 0xffffffff
Global Const $nm_click = $nm_first + 0xfffffffe
Global Const $nm_dblclk = $nm_first + 0xfffffffd
Global Const $nm_return = $nm_first + 0xfffffffc
Global Const $nm_rclick = $nm_first + 0xfffffffb
Global Const $nm_rdblclk = $nm_first + 0xfffffffa
Global Const $nm_setfocus = $nm_first + 0xfffffff9
Global Const $nm_killfocus = $nm_first + 0xfffffff8
Global Const $nm_customdraw = $nm_first + 0xfffffff4
Global Const $nm_hover = $nm_first + 0xfffffff3
Global Const $nm_nchittest = $nm_first + 0xfffffff2
Global Const $nm_keydown = $nm_first + 0xfffffff1
Global Const $nm_releasedcapture = $nm_first + 0xfffffff0
Global Const $nm_setcursor = $nm_first + 0xffffffef
Global Const $nm_char = $nm_first + 0xffffffee
Global Const $nm_tooltipscreated = $nm_first + 0xffffffed
Global Const $nm_ldown = $nm_first + 0xffffffec
Global Const $nm_rdown = $nm_first + 0xffffffeb
Global Const $nm_themechanged = $nm_first + 0xffffffea
Global Const $wm_mousefirst = 0x200
Global Const $wm_mousemove = 0x200
Global Const $wm_lbuttondown = 0x201
Global Const $wm_lbuttonup = 0x202
Global Const $wm_lbuttondblclk = 0x203
Global Const $wm_rbuttondown = 0x204
Global Const $wm_rbuttonup = 0x205
Global Const $wm_rbuttondblclk = 0x206
Global Const $wm_mbuttondown = 0x207
Global Const $wm_mbuttonup = 0x208
Global Const $wm_mbuttondblclk = 0x209
Global Const $wm_mousewheel = 0x20a
Global Const $wm_xbuttondown = 0x20b
Global Const $wm_xbuttonup = 0x20c
Global Const $wm_xbuttondblclk = 0x20d
Global Const $wm_mousehwheel = 0x20e
Global Const $ps_solid = 0x0
Global Const $ps_dash = 0x1
Global Const $ps_dot = 0x2
Global Const $ps_dashdot = 0x3
Global Const $ps_dashdotdot = 0x4
Global Const $ps_null = 0x5
Global Const $ps_insideframe = 0x6
Global Const $ps_userstyle = 0x7
Global Const $ps_alternate = 0x8
Global Const $ps_endcap_round = 0x0
Global Const $ps_endcap_square = 0x100
Global Const $ps_endcap_flat = 0x200
Global Const $ps_join_bevel = 0x1000
Global Const $ps_join_miter = 0x2000
Global Const $ps_join_round = 0x0
Global Const $ps_geometric = 0x10000
Global Const $ps_cosmetic = 0x0
Global Const $lwa_alpha = 0x2
Global Const $lwa_colorkey = 0x1
Global Const $rgn_and = 0x1
Global Const $rgn_or = 0x2
Global Const $rgn_xor = 0x3
Global Const $rgn_diff = 0x4
Global Const $rgn_copy = 0x5
Global Const $errorregion = 0x0
Global Const $nullregion = 0x1
Global Const $simpleregion = 0x2
Global Const $complexregion = 0x3
Global Const $transparent = 0x1
Global Const $opaque = 0x2
Global Const $ccm_first = 0x2000
Global Const $ccm_getunicodeformat = ($ccm_first + 0x6)
Global Const $ccm_setunicodeformat = ($ccm_first + 0x5)
Global Const $ccm_setbkcolor = $ccm_first + 0x1
Global Const $ccm_setcolorscheme = $ccm_first + 0x2
Global Const $ccm_getcolorscheme = $ccm_first + 0x3
Global Const $ccm_getdroptarget = $ccm_first + 0x4
Global Const $ccm_setwindowtheme = $ccm_first + 0xb
Global Const $ga_parent = 0x1
Global Const $ga_root = 0x2
Global Const $ga_rootowner = 0x3
Global Const $sm_cxscreen = 0x0
Global Const $sm_cyscreen = 0x1
Global Const $sm_cxvscroll = 0x2
Global Const $sm_cyhscroll = 0x3
Global Const $sm_cycaption = 0x4
Global Const $sm_cxborder = 0x5
Global Const $sm_cyborder = 0x6
Global Const $sm_cxfixedframe = 0x7
Global Const $sm_cxdlgframe = $sm_cxfixedframe
Global Const $sm_cyfixedframe = 0x8
Global Const $sm_cydlgframe = $sm_cyfixedframe
Global Const $sm_cyvthumb = 0x9
Global Const $sm_cxhthumb = 0xa
Global Const $sm_cxicon = 0xb
Global Const $sm_cyicon = 0xc
Global Const $sm_cxcursor = 0xd
Global Const $sm_cycursor = 0xe
Global Const $sm_cymenu = 0xf
Global Const $sm_cxfullscreen = 0x10
Global Const $sm_cyfullscreen = 0x11
Global Const $sm_cykanjiwindow = 0x12
Global Const $sm_mousepresent = 0x13
Global Const $sm_cyvscroll = 0x14
Global Const $sm_cxhscroll = 0x15
Global Const $sm_debug = 0x16
Global Const $sm_swapbutton = 0x17
Global Const $sm_reserved1 = 0x18
Global Const $sm_reserved2 = 0x19
Global Const $sm_reserved3 = 0x1a
Global Const $sm_reserved4 = 0x1b
Global Const $sm_cxmin = 0x1c
Global Const $sm_cymin = 0x1d
Global Const $sm_cxsize = 0x1e
Global Const $sm_cysize = 0x1f
Global Const $sm_cxsizeframe = 0x20
Global Const $sm_cxframe = $sm_cxsizeframe
Global Const $sm_cysizeframe = 0x21
Global Const $sm_cyframe = $sm_cysizeframe
Global Const $sm_cxmintrack = 0x22
Global Const $sm_cymintrack = 0x23
Global Const $sm_cxdoubleclk = 0x24
Global Const $sm_cydoubleclk = 0x25
Global Const $sm_cxiconspacing = 0x26
Global Const $sm_cyiconspacing = 0x27
Global Const $sm_menudropalignment = 0x28
Global Const $sm_penwindows = 0x29
Global Const $sm_dbcsenabled = 0x2a
Global Const $sm_cmousebuttons = 0x2b
Global Const $sm_secure = 0x2c
Global Const $sm_cxedge = 0x2d
Global Const $sm_cyedge = 0x2e
Global Const $sm_cxminspacing = 0x2f
Global Const $sm_cyminspacing = 0x30
Global Const $sm_cxsmicon = 0x31
Global Const $sm_cysmicon = 0x32
Global Const $sm_cysmcaption = 0x33
Global Const $sm_cxsmsize = 0x34
Global Const $sm_cysmsize = 0x35
Global Const $sm_cxmenusize = 0x36
Global Const $sm_cymenusize = 0x37
Global Const $sm_arrange = 0x38
Global Const $sm_cxminimized = 0x39
Global Const $sm_cyminimized = 0x3a
Global Const $sm_cxmaxtrack = 0x3b
Global Const $sm_cymaxtrack = 0x3c
Global Const $sm_cxmaximized = 0x3d
Global Const $sm_cymaximized = 0x3e
Global Const $sm_network = 0x3f
Global Const $sm_cleanboot = 0x43
Global Const $sm_cxdrag = 0x44
Global Const $sm_cydrag = 0x45
Global Const $sm_showsounds = 0x46
Global Const $sm_cxmenucheck = 0x47
Global Const $sm_cymenucheck = 0x48
Global Const $sm_slowmachine = 0x49
Global Const $sm_mideastenabled = 0x4a
Global Const $sm_mousewheelpresent = 0x4b
Global Const $sm_xvirtualscreen = 0x4c
Global Const $sm_yvirtualscreen = 0x4d
Global Const $sm_cxvirtualscreen = 0x4e
Global Const $sm_cyvirtualscreen = 0x4f
Global Const $sm_cmonitors = 0x50
Global Const $sm_samedisplayformat = 0x51
Global Const $sm_immenabled = 0x52
Global Const $sm_cxfocusborder = 0x53
Global Const $sm_cyfocusborder = 0x54
Global Const $sm_tabletpc = 0x56
Global Const $sm_mediacenter = 0x57
Global Const $sm_starter = 0x58
Global Const $sm_serverr2 = 0x59
Global Const $sm_cmetrics = 0x5a
Global Const $sm_remotesession = 0x1000
Global Const $sm_shuttingdown = 0x2000
Global Const $sm_remotecontrol = 0x2001
Global Const $sm_caretblinkingenabled = 0x2002
Global Const $blackness = 0x42
Global Const $captureblt = 0x40000000
Global Const $dstinvert = 0x550009
Global Const $mergecopy = 0xc000ca
Global Const $mergepaint = 0xbb0226
Global Const $nomirrorbitmap = 0x80000000
Global Const $notsrccopy = 0x330008
Global Const $notsrcerase = 0x1100a6
Global Const $patcopy = 0xf00021
Global Const $patinvert = 0x5a0049
Global Const $patpaint = 0xfb0a09
Global Const $srcand = 0x8800c6
Global Const $srccopy = 0xcc0020
Global Const $srcerase = 0x440328
Global Const $srcinvert = 0x660046
Global Const $srcpaint = 0xee0086
Global Const $whiteness = 0xff0062
Global Const $dt_bottom = 0x8
Global Const $dt_calcrect = 0x400
Global Const $dt_center = 0x1
Global Const $dt_editcontrol = 0x2000
Global Const $dt_end_ellipsis = 0x8000
Global Const $dt_expandtabs = 0x40
Global Const $dt_externalleading = 0x200
Global Const $dt_hideprefix = 0x100000
Global Const $dt_internal = 0x1000
Global Const $dt_left = 0x0
Global Const $dt_modifystring = 0x10000
Global Const $dt_noclip = 0x100
Global Const $dt_nofullwidthcharbreak = 0x80000
Global Const $dt_noprefix = 0x800
Global Const $dt_path_ellipsis = 0x4000
Global Const $dt_prefixonly = 0x200000
Global Const $dt_right = 0x2
Global Const $dt_rtlreading = 0x20000
Global Const $dt_singleline = 0x20
Global Const $dt_tabstop = 0x80
Global Const $dt_top = 0x0
Global Const $dt_vcenter = 0x4
Global Const $dt_wordbreak = 0x10
Global Const $dt_word_ellipsis = 0x40000
Global Const $rdw_erase = 0x4
Global Const $rdw_frame = 0x400
Global Const $rdw_internalpaint = 0x2
Global Const $rdw_invalidate = 0x1
Global Const $rdw_noerase = 0x20
Global Const $rdw_noframe = 0x800
Global Const $rdw_nointernalpaint = 0x10
Global Const $rdw_validate = 0x8
Global Const $rdw_erasenow = 0x200
Global Const $rdw_updatenow = 0x100
Global Const $rdw_allchildren = 0x80
Global Const $rdw_nochildren = 0x40
Global Const $wm_renderformat = 0x305
Global Const $wm_renderallformats = 0x306
Global Const $wm_destroyclipboard = 0x307
Global Const $wm_drawclipboard = 0x308
Global Const $wm_paintclipboard = 0x309
Global Const $wm_vscrollclipboard = 0x30a
Global Const $wm_sizeclipboard = 0x30b
Global Const $wm_askcbformatname = 0x30c
Global Const $wm_changecbchain = 0x30d
Global Const $wm_hscrollclipboard = 0x30e
Global Const $hterror = +0xfffffffe
Global Const $httransparent = +0xffffffff
Global Const $htnowhere = 0x0
Global Const $htclient = 0x1
Global Const $htcaption = 0x2
Global Const $htsysmenu = 0x3
Global Const $htgrowbox = 0x4
Global Const $htsize = $htgrowbox
Global Const $htmenu = 0x5
Global Const $hthscroll = 0x6
Global Const $htvscroll = 0x7
Global Const $htminbutton = 0x8
Global Const $htmaxbutton = 0x9
Global Const $htleft = 0xa
Global Const $htright = 0xb
Global Const $httop = 0xc
Global Const $httopleft = 0xd
Global Const $httopright = 0xe
Global Const $htbottom = 0xf
Global Const $htbottomleft = 0x10
Global Const $htbottomright = 0x11
Global Const $htborder = 0x12
Global Const $htreduce = $htminbutton
Global Const $htzoom = $htmaxbutton
Global Const $htsizefirst = $htleft
Global Const $htsizelast = $htbottomright
Global Const $htobject = 0x13
Global Const $htclose = 0x14
Global Const $hthelp = 0x15
Global Const $color_scrollbar = 0x0
Global Const $color_background = 0x1
Global Const $color_activecaption = 0x2
Global Const $color_inactivecaption = 0x3
Global Const $color_menu = 0x4
Global Const $color_window = 0x5
Global Const $color_windowframe = 0x6
Global Const $color_menutext = 0x7
Global Const $color_windowtext = 0x8
Global Const $color_captiontext = 0x9
Global Const $color_activeborder = 0xa
Global Const $color_inactiveborder = 0xb
Global Const $color_appworkspace = 0xc
Global Const $color_highlight = 0xd
Global Const $color_highlighttext = 0xe
Global Const $color_btnface = 0xf
Global Const $color_btnshadow = 0x10
Global Const $color_graytext = 0x11
Global Const $color_btntext = 0x12
Global Const $color_inactivecaptiontext = 0x13
Global Const $color_btnhighlight = 0x14
Global Const $color_3ddkshadow = 0x15
Global Const $color_3dlight = 0x16
Global Const $color_infotext = 0x17
Global Const $color_infobk = 0x18
Global Const $color_hotlight = 0x1a
Global Const $color_gradientactivecaption = 0x1b
Global Const $color_gradientinactivecaption = 0x1c
Global Const $color_menuhilight = 0x1d
Global Const $color_menubar = 0x1e
Global Const $color_desktop = 0x1
Global Const $color_3dface = 0xf
Global Const $color_3dshadow = 0x10
Global Const $color_3dhighlight = 0x14
Global Const $color_3dhilight = 0x14
Global Const $color_btnhilight = 0x14
Global Const $hinst_commctrl = +0xffffffff
Global Const $idb_std_small_color = 0x0
Global Const $idb_std_large_color = 0x1
Global Const $idb_view_small_color = 0x4
Global Const $idb_view_large_color = 0x5
Global Const $idb_hist_small_color = 0x8
Global Const $idb_hist_large_color = 0x9
Global Const $startf_forceofffeedback = 0x80
Global Const $startf_forceonfeedback = 0x40
Global Const $startf_preventpinning = 0x2000
Global Const $startf_runfullscreen = 0x20
Global Const $startf_titleisappid = 0x1000
Global Const $startf_titleislinkname = 0x800
Global Const $startf_usecountchars = 0x8
Global Const $startf_usefillattribute = 0x10
Global Const $startf_usehotkey = 0x200
Global Const $startf_useposition = 0x4
Global Const $startf_useshowwindow = 0x1
Global Const $startf_usesize = 0x2
Global Const $startf_usestdhandles = 0x100
Global Const $cdds_prepaint = 0x1
Global Const $cdds_postpaint = 0x2
Global Const $cdds_preerase = 0x3
Global Const $cdds_posterase = 0x4
Global Const $cdds_item = 0x10000
Global Const $cdds_itemprepaint = 0x10001
Global Const $cdds_itempostpaint = 0x10002
Global Const $cdds_itempreerase = 0x10003
Global Const $cdds_itemposterase = 0x10004
Global Const $cdds_subitem = 0x20000
Global Const $cdis_selected = 0x1
Global Const $cdis_grayed = 0x2
Global Const $cdis_disabled = 0x4
Global Const $cdis_checked = 0x8
Global Const $cdis_focus = 0x10
Global Const $cdis_default = 0x20
Global Const $cdis_hot = 0x40
Global Const $cdis_marked = 0x80
Global Const $cdis_indeterminate = 0x100
Global Const $cdis_showkeyboardcues = 0x200
Global Const $cdis_nearhot = 0x400
Global Const $cdis_othersidehot = 0x800
Global Const $cdis_drophilited = 0x1000
Global Const $cdrf_dodefault = 0x0
Global Const $cdrf_newfont = 0x2
Global Const $cdrf_skipdefault = 0x4
Global Const $cdrf_notifypostpaint = 0x10
Global Const $cdrf_notifyitemdraw = 0x20
Global Const $cdrf_notifysubitemdraw = 0x20
Global Const $cdrf_notifyposterase = 0x40
Global Const $cdrf_doerase = 0x8
Global Const $cdrf_skippostpaint = 0x100
Global Const $gui_ss_default_gui = BitOR($ws_minimizebox, $ws_caption, $ws_popup, $ws_sysmenu)
Global Const $opt_coordsrelative = 0x0
Global Const $opt_coordsabsolute = 0x1
Global Const $opt_coordsclient = 0x2
Global Const $opt_errorsilent = 0x0
Global Const $opt_errorfatal = 0x1
Global Const $opt_capsnostore = 0x0
Global Const $opt_capsstore = 0x1
Global Const $opt_matchstart = 0x1
Global Const $opt_matchany = 0x2
Global Const $opt_matchexact = 0x3
Global Const $opt_matchadvanced = 0x4
Global Const $ccs_top = 0x1
Global Const $ccs_nomovey = 0x2
Global Const $ccs_bottom = 0x3
Global Const $ccs_noresize = 0x4
Global Const $ccs_noparentalign = 0x8
Global Const $ccs_nohilite = 0x10
Global Const $ccs_adjustable = 0x20
Global Const $ccs_nodivider = 0x40
Global Const $ccs_vert = 0x80
Global Const $ccs_left = 0x81
Global Const $ccs_nomovex = 0x82
Global Const $ccs_right = 0x83
Global Const $dt_drivetype = 0x1
Global Const $dt_ssdstatus = 0x2
Global Const $dt_bustype = 0x3
Global Const $proxy_ie = 0x0
Global Const $proxy_none = 0x1
Global Const $proxy_specified = 0x2
Global Const $objid_window = 0x0
Global Const $objid_titlebar = 0xfffffffe
Global Const $objid_sizegrip = 0xfffffff9
Global Const $objid_caret = 0xfffffff8
Global Const $objid_cursor = 0xfffffff7
Global Const $objid_alert = 0xfffffff6
Global Const $objid_sound = 0xfffffff5
Global Const $dlg_centerontop = 0x0
Global Const $dlg_notitle = 0x1
Global Const $dlg_notontop = 0x2
Global Const $dlg_textleft = 0x4
Global Const $dlg_textright = 0x8
Global Const $dlg_moveable = 0x10
Global Const $dlg_textvcenter = 0x20
Global Const $mcid_unknown = +0xffffffff
Global Const $mcid_hand = 0x0
Global Const $mcid_appstarting = 0x1
Global Const $mcid_arrow = 0x2
Global Const $mcid_cross = 0x3
Global Const $mcid_help = 0x4
Global Const $mcid_ibeam = 0x5
Global Const $mcid_icon = 0x6
Global Const $mcid_no = 0x7
Global Const $mcid_size = 0x8
Global Const $mcid_sizeall = 0x9
Global Const $mcid_sizenesw = 0xa
Global Const $mcid_sizens = 0xb
Global Const $mcid_sizenwse = 0xc
Global Const $mcid_sizewe = 0xd
Global Const $mcid_uparrow = 0xe
Global Const $mcid_wait = 0xf
Global Const $mcid_none = 0x10
Global Const $sd_logoff = 0x0
Global Const $sd_shutdown = 0x1
Global Const $sd_reboot = 0x2
Global Const $sd_force = 0x4
Global Const $sd_powerdown = 0x8
Global Const $sd_forcehung = 0x10
Global Const $sd_standby = 0x20
Global Const $sd_hibernate = 0x40
Global Const $stdin_child = 0x1
Global Const $stdout_child = 0x2
Global Const $stderr_child = 0x4
Global Const $stderr_merged = 0x8
Global Const $stdio_inherit_parent = 0x10
Global Const $run_create_new_console = 0x10000
Global Const $ubound_dimensions = 0x0
Global Const $ubound_rows = 0x1
Global Const $ubound_columns = 0x2
Global Const $mouseeventf_absolute = 0x8000
Global Const $mouseeventf_move = 0x1
Global Const $mouseeventf_leftdown = 0x2
Global Const $mouseeventf_leftup = 0x4
Global Const $mouseeventf_rightdown = 0x8
Global Const $mouseeventf_rightup = 0x10
Global Const $mouseeventf_middledown = 0x20
Global Const $mouseeventf_middleup = 0x40
Global Const $mouseeventf_wheel = 0x800
Global Const $mouseeventf_xdown = 0x80
Global Const $mouseeventf_xup = 0x100
Global Const $reg_none = 0x0
Global Const $reg_sz = 0x1
Global Const $reg_expand_sz = 0x2
Global Const $reg_binary = 0x3
Global Const $reg_dword = 0x4
Global Const $reg_dword_little_endian = 0x4
Global Const $reg_dword_big_endian = 0x5
Global Const $reg_link = 0x6
Global Const $reg_multi_sz = 0x7
Global Const $reg_resource_list = 0x8
Global Const $reg_full_resource_descriptor = 0x9
Global Const $reg_resource_requirements_list = 0xa
Global Const $reg_qword = 0xb
Global Const $reg_qword_little_endian = 0xb
Global Const $hwnd_bottom = 0x1
Global Const $hwnd_notopmost = +0xfffffffe
Global Const $hwnd_top = 0x0
Global Const $hwnd_topmost = +0xffffffff
Global Const $swp_nosize = 0x1
Global Const $swp_nomove = 0x2
Global Const $swp_nozorder = 0x4
Global Const $swp_noredraw = 0x8
Global Const $swp_noactivate = 0x10
Global Const $swp_framechanged = 0x20
Global Const $swp_drawframe = 0x20
Global Const $swp_showwindow = 0x40
Global Const $swp_hidewindow = 0x80
Global Const $swp_nocopybits = 0x100
Global Const $swp_noownerzorder = 0x200
Global Const $swp_noreposition = 0x200
Global Const $swp_nosendchanging = 0x400
Global Const $swp_defererase = 0x2000
Global Const $swp_asyncwindowpos = 0x4000
Global Const $keyword_default = 0x1
Global Const $keyword_null = 0x2
Global Const $declared_local = +0xffffffff
Global Const $declared_unknown = 0x0
Global Const $declared_global = 0x1
Global Const $assign_create = 0x0
Global Const $assign_forcelocal = 0x1
Global Const $assign_forceglobal = 0x2
Global Const $assign_existfail = 0x4
Global Const $bi_enable = 0x0
Global Const $bi_disable = 0x1
Global Const $break_enable = 0x1
Global Const $break_disable = 0x0
Global Const $cdtray_open = "open"
Global Const $cdtray_closed = "closed"
Global Const $send_default = 0x0
Global Const $send_raw = 0x1
Global Const $dir_default = 0x0
Global Const $dir_extended = 0x1
Global Const $dir_norecurse = 0x2
Global Const $dir_remove = 0x1
Global Const $dt_all = "ALL"
Global Const $dt_cdrom = "CDROM"
Global Const $dt_removable = "REMOVABLE"
Global Const $dt_fixed = "FIXED"
Global Const $dt_network = "NETWORK"
Global Const $dt_ramdisk = "RAMDISK"
Global Const $dt_unknown = "UNKNOWN"
Global Const $dt_undefined = 0x1
Global Const $dt_fat = "FAT"
Global Const $dt_fat32 = "FAT32"
Global Const $dt_exfat = "exFAT"
Global Const $dt_ntfs = "NTFS"
Global Const $dt_nwfs = "NWFS"
Global Const $dt_cdfs = "CDFS"
Global Const $dt_udf = "UDF"
Global Const $dma_default = 0x0
Global Const $dma_persistent = 0x1
Global Const $dma_authentication = 0x8
Global Const $ds_unknown = "UNKNOWN"
Global Const $ds_ready = "READY"
Global Const $ds_notready = "NOTREADY"
Global Const $ds_invalid = "INVALID"
Global Const $mouse_click_left = "left"
Global Const $mouse_click_right = "right"
Global Const $mouse_click_middle = "middle"
Global Const $mouse_click_main = "main"
Global Const $mouse_click_menu = "menu"
Global Const $mouse_click_primary = "primary"
Global Const $mouse_click_secondary = "secondary"
Global Const $mouse_wheel_up = "up"
Global Const $mouse_wheel_down = "down"
Global Const $number_auto = 0x0
Global Const $number_32bit = 0x1
Global Const $number_64bit = 0x2
Global Const $number_double = 0x3
Global Const $obj_name = 0x1
Global Const $obj_string = 0x2
Global Const $obj_progid = 0x3
Global Const $obj_file = 0x4
Global Const $obj_module = 0x5
Global Const $obj_clsid = 0x6
Global Const $obj_iid = 0x7
Global Const $exitclose_normal = 0x0
Global Const $exitclose_byexit = 0x1
Global Const $exitclose_byclick = 0x2
Global Const $exitclose_bylogoff = 0x3
Global Const $exitclose_byshutdown = 0x4
Global Const $process_stats_memory = 0x0
Global Const $process_stats_io = 0x1
Global Const $process_low = 0x0
Global Const $process_belownormal = 0x1
Global Const $process_normal = 0x2
Global Const $process_abovenormal = 0x3
Global Const $process_high = 0x4
Global Const $process_realtime = 0x5
Global Const $run_logon_noprofile = 0x0
Global Const $run_logon_profile = 0x1
Global Const $run_logon_network = 0x2
Global Const $run_logon_inherit = 0x4
Global Const $sound_nowait = 0x0
Global Const $sound_wait = 0x1
Global Const $shex_open = "open"
Global Const $shex_edit = "edit"
Global Const $shex_print = "print"
Global Const $shex_properties = "properties"
Global Const $tcp_data_default = 0x0
Global Const $tcp_data_binary = 0x1
Global Const $udp_open_default = 0x0
Global Const $udp_open_broadcast = 0x1
Global Const $udp_data_default = 0x0
Global Const $udp_data_binary = 0x1
Global Const $udp_data_array = 0x2
Global Const $tip_noicon = 0x0
Global Const $tip_infoicon = 0x1
Global Const $tip_warningicon = 0x2
Global Const $tip_erroricon = 0x3
Global Const $tip_balloon = 0x1
Global Const $tip_center = 0x2
Global Const $tip_forcevisible = 0x4
Global Const $windows_noontop = 0x0
Global Const $windows_ontop = 0x1
Global Const $win_state_exists = 0x1
Global Const $win_state_visible = 0x2
Global Const $win_state_enabled = 0x4
Global Const $win_state_active = 0x8
Global Const $win_state_minimized = 0x10
Global Const $win_state_maximized = 0x20
Global Const $fc_nooverwrite = 0x0
Global Const $fc_overwrite = 0x1
Global Const $fc_createpath = 0x8
Global Const $ft_modified = 0x0
Global Const $ft_created = 0x1
Global Const $ft_accessed = 0x2
Global Const $ft_array = 0x0
Global Const $ft_string = 0x1
Global Const $ft_msec = 0x2
Global Const $ft_utc = 0x4
Global Const $fsf_createbutton = 0x1
Global Const $fsf_newdialog = 0x2
Global Const $fsf_editcontrol = 0x4
Global Const $ft_nonrecursive = 0x0
Global Const $ft_recursive = 0x1
Global Const $fo_read = 0x0
Global Const $fo_append = 0x1
Global Const $fo_overwrite = 0x2
Global Const $fo_createpath = 0x8
Global Const $fo_binary = 0x10
Global Const $fo_unicode = 0x20
Global Const $fo_utf16_le = 0x20
Global Const $fo_utf16_be = 0x40
Global Const $fo_utf8 = 0x80
Global Const $fo_utf8_nobom = 0x100
Global Const $fo_ansi = 0x200
Global Const $fo_utf16_le_nobom = 0x400
Global Const $fo_utf16_be_nobom = 0x800
Global Const $fo_utf8_full = 0x4000
Global Const $fo_fullfile_detect = 0x4000
Global Const $eof = +0xffffffff
Global Const $fd_filemustexist = 0x1
Global Const $fd_pathmustexist = 0x2
Global Const $fd_multiselect = 0x4
Global Const $fd_promptcreatenew = 0x8
Global Const $fd_promptoverwrite = 0x10
Global Const $create_new = 0x1
Global Const $create_always = 0x2
Global Const $open_existing = 0x3
Global Const $open_always = 0x4
Global Const $truncate_existing = 0x5
Global Const $invalid_set_file_pointer = +0xffffffff
Global Const $file_begin = 0x0
Global Const $file_current = 0x1
Global Const $file_end = 0x2
Global Const $file_attribute_readonly = 0x1
Global Const $file_attribute_hidden = 0x2
Global Const $file_attribute_system = 0x4
Global Const $file_attribute_directory = 0x10
Global Const $file_attribute_archive = 0x20
Global Const $file_attribute_device = 0x40
Global Const $file_attribute_normal = 0x80
Global Const $file_attribute_temporary = 0x100
Global Const $file_attribute_sparse_file = 0x200
Global Const $file_attribute_reparse_point = 0x400
Global Const $file_attribute_compressed = 0x800
Global Const $file_attribute_offline = 0x1000
Global Const $file_attribute_not_content_indexed = 0x2000
Global Const $file_attribute_encrypted = 0x4000
Global Const $file_share_read = 0x1
Global Const $file_share_write = 0x2
Global Const $file_share_delete = 0x4
Global Const $file_share_readwrite = BitOR($file_share_read, $file_share_write)
Global Const $file_share_any = BitOR($file_share_read, $file_share_write, $file_share_delete)
Global Const $generic_all = 0x10000000
Global Const $generic_execute = 0x20000000
Global Const $generic_write = 0x40000000
Global Const $generic_read = 0x80000000
Global Const $generic_readwrite = BitOR($generic_read, $generic_write)
Global Const $file_encoding_utf16le = 0x20
Global Const $fe_entire_utf8 = 0x1
Global Const $fe_partialfirst_utf8 = 0x2
Global Const $fn_fullpath = 0x0
Global Const $fn_relativepath = 0x1
Global Const $fv_comments = "Comments"
Global Const $fv_companyname = "CompanyName"
Global Const $fv_filedescription = "FileDescription"
Global Const $fv_fileversion = "FileVersion"
Global Const $fv_internalname = "InternalName"
Global Const $fv_legalcopyright = "LegalCopyright"
Global Const $fv_legaltrademarks = "LegalTrademarks"
Global Const $fv_originalfilename = "OriginalFilename"
Global Const $fv_productname = "ProductName"
Global Const $fv_productversion = "ProductVersion"
Global Const $fv_privatebuild = "PrivateBuild"
Global Const $fv_specialbuild = "SpecialBuild"
Global Const $frta_nocount = 0x0
Global Const $frta_count = 0x1
Global Const $frta_intarrays = 0x2
Global Const $frta_entiresplit = 0x4
Global Const $flta_filesfolders = 0x0
Global Const $flta_files = 0x1
Global Const $flta_folders = 0x2
Global Const $fltar_filesfolders = 0x0
Global Const $fltar_files = 0x1
Global Const $fltar_folders = 0x2
Global Const $fltar_nohidden = 0x4
Global Const $fltar_nosystem = 0x8
Global Const $fltar_nolink = 0x10
Global Const $fltar_norecur = 0x0
Global Const $fltar_recur = 0x1
Global Const $fltar_nosort = 0x0
Global Const $fltar_sort = 0x1
Global Const $fltar_fastsort = 0x2
Global Const $fltar_nopath = 0x0
Global Const $fltar_relpath = 0x1
Global Const $fltar_fullpath = 0x2
Global Const $path_original = 0x0
Global Const $path_drive = 0x1
Global Const $path_directory = 0x2
Global Const $path_filename = 0x3
Global Const $path_extension = 0x4
Global Const $mb_ok = 0x0
Global Const $mb_okcancel = 0x1
Global Const $mb_abortretryignore = 0x2
Global Const $mb_yesnocancel = 0x3
Global Const $mb_yesno = 0x4
Global Const $mb_retrycancel = 0x5
Global Const $mb_canceltrycontinue = 0x6
Global Const $mb_help = 0x4000
Global Const $mb_iconnone = 0x0
Global Const $mb_iconstop = 0x10
Global Const $mb_iconerror = 0x10
Global Const $mb_iconhand = 0x10
Global Const $mb_iconquestion = 0x20
Global Const $mb_iconexclamation = 0x30
Global Const $mb_iconwarning = 0x30
Global Const $mb_iconinformation = 0x40
Global Const $mb_iconasterisk = 0x40
Global Const $mb_usericon = 0x80
Global Const $mb_defbutton1 = 0x0
Global Const $mb_defbutton2 = 0x100
Global Const $mb_defbutton3 = 0x200
Global Const $mb_defbutton4 = 0x300
Global Const $mb_applmodal = 0x0
Global Const $mb_systemmodal = 0x1000
Global Const $mb_taskmodal = 0x2000
Global Const $mb_default_desktop_only = 0x20000
Global Const $mb_right = 0x80000
Global Const $mb_rtlreading = 0x100000
Global Const $mb_setforeground = 0x10000
Global Const $mb_topmost = 0x40000
Global Const $mb_service_notification = 0x200000
Global Const $mb_rightjustified = $mb_right
Global Const $idtimeout = +0xffffffff
Global Const $idok = 0x1
Global Const $idcancel = 0x2
Global Const $idabort = 0x3
Global Const $idretry = 0x4
Global Const $idignore = 0x5
Global Const $idyes = 0x6
Global Const $idno = 0x7
Global Const $idclose = 0x8
Global Const $idhelp = 0x9
Global Const $idtryagain = 0xa
Global Const $idcontinue = 0xb
Global Const $se_assignprimarytoken_name = "SeAssignPrimaryTokenPrivilege"
Global Const $se_audit_name = "SeAuditPrivilege"
Global Const $se_backup_name = "SeBackupPrivilege"
Global Const $se_change_notify_name = "SeChangeNotifyPrivilege"
Global Const $se_create_global_name = "SeCreateGlobalPrivilege"
Global Const $se_create_pagefile_name = "SeCreatePagefilePrivilege"
Global Const $se_create_permanent_name = "SeCreatePermanentPrivilege"
Global Const $se_create_symbolic_link_name = "SeCreateSymbolicLinkPrivilege"
Global Const $se_create_token_name = "SeCreateTokenPrivilege"
Global Const $se_debug_name = "SeDebugPrivilege"
Global Const $se_enable_delegation_name = "SeEnableDelegationPrivilege"
Global Const $se_impersonate_name = "SeImpersonatePrivilege"
Global Const $se_inc_base_priority_name = "SeIncreaseBasePriorityPrivilege"
Global Const $se_inc_working_set_name = "SeIncreaseWorkingSetPrivilege"
Global Const $se_increase_quota_name = "SeIncreaseQuotaPrivilege"
Global Const $se_load_driver_name = "SeLoadDriverPrivilege"
Global Const $se_lock_memory_name = "SeLockMemoryPrivilege"
Global Const $se_machine_account_name = "SeMachineAccountPrivilege"
Global Const $se_manage_volume_name = "SeManageVolumePrivilege"
Global Const $se_prof_single_process_name = "SeProfileSingleProcessPrivilege"
Global Const $se_relabel_name = "SeRelabelPrivilege"
Global Const $se_remote_shutdown_name = "SeRemoteShutdownPrivilege"
Global Const $se_restore_name = "SeRestorePrivilege"
Global Const $se_security_name = "SeSecurityPrivilege"
Global Const $se_shutdown_name = "SeShutdownPrivilege"
Global Const $se_sync_agent_name = "SeSyncAgentPrivilege"
Global Const $se_system_environment_name = "SeSystemEnvironmentPrivilege"
Global Const $se_system_profile_name = "SeSystemProfilePrivilege"
Global Const $se_systemtime_name = "SeSystemtimePrivilege"
Global Const $se_take_ownership_name = "SeTakeOwnershipPrivilege"
Global Const $se_tcb_name = "SeTcbPrivilege"
Global Const $se_time_zone_name = "SeTimeZonePrivilege"
Global Const $se_trusted_credman_access_name = "SeTrustedCredManAccessPrivilege"
Global Const $se_unsolicited_input_name = "SeUnsolicitedInputPrivilege"
Global Const $se_undock_name = "SeUndockPrivilege"
Global Const $se_privilege_enabled_by_default = 0x1
Global Const $se_privilege_enabled = 0x2
Global Const $se_privilege_removed = 0x4
Global Const $se_privilege_used_for_access = 0x80000000
Global Const $se_group_mandatory = 0x1
Global Const $se_group_enabled_by_default = 0x2
Global Const $se_group_enabled = 0x4
Global Const $se_group_owner = 0x8
Global Const $se_group_use_for_deny_only = 0x10
Global Const $se_group_integrity = 0x20
Global Const $se_group_integrity_enabled = 0x40
Global Const $se_group_resource = 0x20000000
Global Const $se_group_logon_id = 0xc0000000
Global Enum $tokenprimary = 0x1, $tokenimpersonation
Global Enum $securityanonymous = 0x0, $securityidentification, $securityimpersonation, $securitydelegation
Global Enum $tokenuser = 0x1, $tokengroups, $tokenprivileges, $tokenowner, $tokenprimarygroup, $tokendefaultdacl, $tokensource, $tokentype, $tokenimpersonationlevel, $tokenstatistics, $tokenrestrictedsids, $tokensessionid, $tokengroupsandprivileges, $tokensessionreference, $tokensandboxinert, $tokenauditpolicy, $tokenorigin, $tokenelevationtype, $tokenlinkedtoken, $tokenelevation, $tokenhasrestrictions, $tokenaccessinformation, $tokenvirtualizationallowed, $tokenvirtualizationenabled, $tokenintegritylevel, $tokenuiaccess, $tokenmandatorypolicy, $tokenlogonsid
Global Const $token_assign_primary = 0x1
Global Const $token_duplicate = 0x2
Global Const $token_impersonate = 0x4
Global Const $token_query = 0x8
Global Const $token_query_source = 0x10
Global Const $token_adjust_privileges = 0x20
Global Const $token_adjust_groups = 0x40
Global Const $token_adjust_default = 0x80
Global Const $token_adjust_sessionid = 0x100
Global Const $token_all_access = 0xf01ff
Global Const $token_read = 0x20008
Global Const $token_write = 0x200e0
Global Const $token_execute = 0x20000
Global Const $token_has_traverse_privilege = 0x1
Global Const $token_has_backup_privilege = 0x2
Global Const $token_has_restore_privilege = 0x4
Global Const $token_has_admin_group = 0x8
Global Const $token_is_restricted = 0x10
Global Const $token_session_not_referenced = 0x20
Global Const $token_sandbox_inert = 0x40
Global Const $token_has_impersonate_privilege = 0x80
Global Const $standard_rights_delete = 0x10000
Global Const $read_control = 0x20000
Global Const $write_dac = 0x40000
Global Const $write_owner = 0x80000
Global Const $standard_rights_synchronize = 0x100000
Global Const $access_system_security = 0x1000000
Global Const $standard_rights_required = 0xf0000
Global Const $standard_rights_read = $read_control
Global Const $standard_rights_write = $read_control
Global Const $standard_rights_execute = $read_control
Global Const $standard_rights_all = 0x1f0000
Global Const $specific_rights_all = 0xffff
Global Enum $not_used_access = 0x0, $grant_access, $set_access, $deny_access, $revoke_access, $set_audit_success, $set_audit_failure
Global Enum $trustee_is_unknown = 0x0, $trustee_is_user, $trustee_is_group, $trustee_is_domain, $trustee_is_alias, $trustee_is_well_known_group, $trustee_is_deleted, $trustee_is_invalid, $trustee_is_computer
Global Const $logon_with_profile = 0x1
Global Const $logon_netcredentials_only = 0x2
Global Enum $sidtypeuser = 0x1, $sidtypegroup, $sidtypedomain, $sidtypealias, $sidtypewellknowngroup, $sidtypedeletedaccount, $sidtypeinvalid, $sidtypeunknown, $sidtypecomputer, $sidtypelabel
Global Const $sid_administrators = "S-1-5-32-544"
Global Const $sid_users = "S-1-5-32-545"
Global Const $sid_guests = "S-1-5-32-546"
Global Const $sid_account_operators = "S-1-5-32-548"
Global Const $sid_server_operators = "S-1-5-32-549"
Global Const $sid_print_operators = "S-1-5-32-550"
Global Const $sid_backup_operators = "S-1-5-32-551"
Global Const $sid_replicator = "S-1-5-32-552"
Global Const $sid_owner = "S-1-3-0"
Global Const $sid_everyone = "S-1-1-0"
Global Const $sid_network = "S-1-5-2"
Global Const $sid_interactive = "S-1-5-4"
Global Const $sid_system = "S-1-5-18"
Global Const $sid_authenticated_users = "S-1-5-11"
Global Const $sid_schannel_authentication = "S-1-5-64-14"
Global Const $sid_digest_authentication = "S-1-5-64-21"
Global Const $sid_nt_service = "S-1-5-80"
Global Const $sid_untrusted_mandatory_level = "S-1-16-0"
Global Const $sid_low_mandatory_level = "S-1-16-4096"
Global Const $sid_medium_mandatory_level = "S-1-16-8192"
Global Const $sid_medium_plus_mandatory_level = "S-1-16-8448"
Global Const $sid_high_mandatory_level = "S-1-16-12288"
Global Const $sid_system_mandatory_level = "S-1-16-16384"
Global Const $sid_protected_process_mandatory_level = "S-1-16-20480"
Global Const $sid_secure_process_mandatory_level = "S-1-16-28672"
Global Const $sid_all_services = "S-1-5-80-0"
Global Const $str_nocasesense = 0x0
Global Const $str_casesense = 0x1
Global Const $str_nocasesensebasic = 0x2
Global Const $str_stripleading = 0x1
Global Const $str_striptrailing = 0x2
Global Const $str_stripspaces = 0x4
Global Const $str_stripall = 0x8
Global Const $str_chrsplit = 0x0
Global Const $str_entiresplit = 0x1
Global Const $str_nocount = 0x2
Global Const $str_regexpmatch = 0x0
Global Const $str_regexparraymatch = 0x1
Global Const $str_regexparrayfullmatch = 0x2
Global Const $str_regexparrayglobalmatch = 0x3
Global Const $str_regexparrayglobalfullmatch = 0x4
Global Const $str_endisstart = 0x0
Global Const $str_endnotstart = 0x1
Global Const $sb_ansi = 0x1
Global Const $sb_utf16le = 0x2
Global Const $sb_utf16be = 0x3
Global Const $sb_utf8 = 0x4
Global Const $se_utf16 = 0x0
Global Const $se_ansi = 0x1
Global Const $se_utf8 = 0x2
Global Const $str_utf16 = 0x0
Global Const $str_ucs2 = 0x1
#region Global Variables and Constants
Global Const $format_message_allocate_buffer = 0x100
Global Const $format_message_ignore_inserts = 0x200
Global Const $format_message_from_string = 0x400
Global Const $format_message_from_hmodule = 0x800
Global Const $format_message_from_system = 0x1000
Global Const $format_message_argument_array = 0x2000
#endregion Global Variables and Constants
Func _WinAPI_Beep($ifreq = 0x1f4, $iduration = 0x3e8)
    Local $acall = DllCall("kernel32.dll", "bool", "Beep", "dword", $ifreq, "dword", $iduration)
    If @error Then Return SetError(@error, @extended, False)
    Return $acall[0x0]
EndFunc   ;==>_WINAPI_BEEP
Func _WinAPI_FormatMessage($iflags, $psource, $imessageid, $ilanguageid, ByRef $pbuffer, $isize, $varguments)
    Local $sbuffertype = "struct*"
    If IsString($pbuffer) Then $sbuffertype = "wstr"
    Local $acall = DllCall("kernel32.dll", "dword", "FormatMessageW", "dword", $iflags, "struct*", $psource, "dword", $imessageid, "dword", $ilanguageid, $sbuffertype, $pbuffer, "dword", $isize, "ptr", $varguments)
    If @error Then Return SetError(@error, @extended, 0x0)
    If Not $acall[0x0] Then Return SetError(0xa, _WinAPI_GetLastError(), 0x0)
    If $sbuffertype = "wstr" Then $pbuffer = $acall[0x5]
    Return $acall[0x0]
EndFunc   ;==>_WINAPI_FORMATMESSAGE
Func _WINAPI_GETERRORMESSAGE($icode, $ilanguage = 0x0, Const $_icallererror = @error, Const $_icallerextended = @extended)
    Local $acall = DllCall("kernel32.dll", "dword", "FormatMessageW", "dword", BitOR($format_message_from_system, $format_message_ignore_inserts), "ptr", 0x0, "dword", $icode, "dword", $ilanguage, "wstr", "", "dword", 0x1000, "ptr", 0x0)
    If @error Or Not $acall[0x0] Then Return SetError(@error, @extended, "")
    Return SetError($_icallererror, $_icallerextended, StringRegExpReplace($acall[0x5], "[" & @LF & "," & @CR & "]*\Z", ""))
EndFunc   ;==>_WINAPI_GETERRORMESSAGE
Func _WinAPI_GetLastError(Const $_icallererror = @error, Const $_icallerextended = @extended)
    Local $acall = DllCall("kernel32.dll", "dword", "GetLastError")
    Return SetError($_icallererror, $_icallerextended, $acall[0x0])
EndFunc   ;==>_WINAPI_GETLASTERROR
Func _WinAPI_GetLastErrorMessage(Const $_icallererror = @error, Const $_icallerextended = @extended)
    Local $ilasterror = _WinAPI_GetLastError()
    Local $tbufferptr = DllStructCreate("ptr")
    Local $ncount = _WinAPI_FormatMessage(BitOR($format_message_allocate_buffer, $format_message_from_system, $format_message_ignore_inserts), 0x0, $ilasterror, 0x0, $tbufferptr, 0x0, 0x0)
    If @error Then Return SetError(-@error, @extended, "")
    Local $stext = ""
    Local $pbuffer = DllStructGetData($tbufferptr, 0x1)
    If $pbuffer Then
        If $ncount > 0x0 Then
            Local $tbuffer = DllStructCreate("wchar[" & ($ncount + 0x1) & "]", $pbuffer)
            $stext = DllStructGetData($tbuffer, 0x1)
            If StringRight($stext, 0x2) = @CRLF Then $stext = StringTrimRight($stext, 0x2)
        EndIf
        DllCall("kernel32.dll", "handle", "LocalFree", "handle", $pbuffer)
    EndIf
    Return SetError($_icallererror, $_icallerextended, $stext)
EndFunc   ;==>_WINAPI_GETLASTERRORMESSAGE
Func _WinAPI_MessageBeep($itype = 0x1)
    Local $isound
    Switch $itype
        Case 0x1
            $isound = 0x0
        Case 0x2
            $isound = 0x10
        Case 0x3
            $isound = 0x20
        Case 0x4
            $isound = 0x30
        Case 0x5
            $isound = 0x40
        Case Else
            $isound = +0xffffffff
    EndSwitch
    Local $acall = DllCall("user32.dll", "bool", "MessageBeep", "uint", $isound)
    If @error Then Return SetError(@error, @extended, False)
    Return $acall[0x0]
EndFunc   ;==>_WINAPI_MESSAGEBEEP
Func _WinAPI_MsgBox($iflags, $stitle, $stext)
    BlockInput(0x0)
    MsgBox($iflags, $stitle, $stext & "      ")
EndFunc   ;==>_WINAPI_MSGBOX
Func _WinAPI_SetLastError($ierrorcode, Const $_icallererror = @error, Const $_icallerextended = @extended)
    DllCall("kernel32.dll", "none", "SetLastError", "dword", $ierrorcode)
    Return SetError($_icallererror, $_icallerextended, NULL)
EndFunc   ;==>_WINAPI_SETLASTERROR
Func _WinAPI_ShowError($stext, $bexit = True)
    BlockInput(0x0)
    MsgBox($mb_systemmodal, "Error", $stext & "      ")
    If $bexit Then Exit
EndFunc   ;==>_WINAPI_SHOWERROR
Func _WINAPI_SHOWLASTERROR($stext = "", $babort = False, $ilanguage = 0x0, Const $_icallererror = @error, Const $_icallerextended = @extended)
    Local $serror
    Local $ilasterror = _WinAPI_GetLastError()
    While 0x1
        $serror = _WINAPI_GETERRORMESSAGE($ilasterror, $ilanguage)
        If @error And $ilanguage Then
            $ilanguage = 0x0
        Else
            ExitLoop
        EndIf
    WEnd
    If StringStripWS($stext, $str_stripleading + $str_striptrailing) Then
        $stext &= @CRLF & @CRLF
    Else
        $stext = ""
    EndIf
    _WinAPI_MsgBox(BitOR(0x40000, BitShift(0x10, +0xfffffffe * (Not $ilasterror))), $ilasterror, $stext & $serror)
    If $ilasterror Then
        _WinAPI_SetLastError($ilasterror)
        If $babort Then
            Exit $ilasterror
        EndIf
    EndIf
    Return SetError($_icallererror, $_icallerextended, 0x1)
EndFunc   ;==>_WINAPI_SHOWLASTERROR
Func _WinAPI_ShowMsg($stext)
    _WinAPI_MsgBox($mb_systemmodal, "Information", $stext)
EndFunc   ;==>_WINAPI_SHOWMSG
Func __COMERRORFORMATING(ByRef $ocomerror, $sprefix = @TAB)
    Local Const $str_striptrailing = 0x2
    Local $serror = "COM Error encountered in " & @ScriptName & " (" & $ocomerror .Scriptline & ") :" & @CRLF & $sprefix & "Number        " & @TAB & "= 0x" & Hex($ocomerror .Number, 0x8) & " (" & $ocomerror .Number & ")" & @CRLF & $sprefix & "WinDescription" & @TAB & "= " & StringStripWS($ocomerror .WinDescription, $str_striptrailing) & @CRLF & $sprefix & "Description   " & @TAB & "= " & StringStripWS($ocomerror .Description, $str_striptrailing) & @CRLF & $sprefix & "Source        " & @TAB & "= " & $ocomerror .Source & @CRLF & $sprefix & "HelpFile      " & @TAB & "= " & $ocomerror .HelpFile & @CRLF & $sprefix & "HelpContext   " & @TAB & "= " & $ocomerror .HelpContext & @CRLF & $sprefix & "LastDllError  " & @TAB & "= " & $ocomerror .LastDllError & @CRLF & $sprefix & "Retcode       " & @TAB & "= 0x" & Hex($ocomerror .retcode)
    Return $serror
EndFunc   ;==>__COMERRORFORMATING
#region Functions list
#endregion Functions list
#region Public Functions
Func _Security__AdjustTokenPrivileges($htoken, $bdisableall, $tnewstate, $ibufferlen, $tprevstate = 0x0, $prequired = 0x0)
    Local $acall = DllCall("advapi32.dll", "bool", "AdjustTokenPrivileges", "handle", $htoken, "bool", $bdisableall, "struct*", $tnewstate, "dword", $ibufferlen, "struct*", $tprevstate, "struct*", $prequired)
    If @error Then Return SetError(@error, @extended, False)
    Return Not ($acall[0x0] = 0x0)
EndFunc   ;==>_SECURITY__ADJUSTTOKENPRIVILEGES
Func _Security__CreateProcessWithToken($htoken, $ilogonflags, $scommandline, $icreationflags, $scurdir, $tstartupinfo, $tprocess_information)
    Local $acall = DllCall("advapi32.dll", "bool", "CreateProcessWithTokenW", "handle", $htoken, "dword", $ilogonflags, "ptr", 0x0, "wstr", $scommandline, "dword", $icreationflags, "struct*", 0x0, "wstr", $scurdir, "struct*", $tstartupinfo, "struct*", $tprocess_information)
    If @error Or Not $acall[0x0] Then Return SetError(@error + 0xa, @extended, False)
    Return True
EndFunc   ;==>_SECURITY__CREATEPROCESSWITHTOKEN
Func _Security__DuplicateTokenEx($hexistingtoken, $idesiredaccess, $iimpersonationlevel, $itokentype)
    Local $acall = DllCall("advapi32.dll", "bool", "DuplicateTokenEx", "handle", $hexistingtoken, "dword", $idesiredaccess, "struct*", 0x0, "int", $iimpersonationlevel, "int", $itokentype, "handle*", 0x0)
    If @error Or Not $acall[0x0] Then Return SetError(@error + 0xa, @extended, 0x0)
    Return $acall[0x6]
EndFunc   ;==>_SECURITY__DUPLICATETOKENEX
Func _Security__GetAccountSid($saccount, $ssystem = "")
    Local $aacct = _Security__LookupAccountName($saccount, $ssystem)
    If @error Then Return SetError(@error, @extended, 0x0)
    If IsArray($aacct) Then Return _Security__StringSidToSid($aacct[0x0])
    Return ""
EndFunc   ;==>_SECURITY__GETACCOUNTSID
Func _Security__GetLengthSid($psid)
    If Not _Security__IsValidSid($psid) Then Return SetError(@error + 0xa, @extended, 0x0)
    Local $acall = DllCall("advapi32.dll", "dword", "GetLengthSid", "struct*", $psid)
    If @error Then Return SetError(@error, @extended, 0x0)
    Return $acall[0x0]
EndFunc   ;==>_SECURITY__GETLENGTHSID
Func _Security__GetTokenInformation($htoken, $iclass)
    Local $acall = DllCall("advapi32.dll", "bool", "GetTokenInformation", "handle", $htoken, "int", $iclass, "struct*", 0x0, "dword", 0x0, "dword*", 0x0)
    If @error Or Not $acall[0x5] Then Return SetError(@error + 0x14, @extended, 0x0)
    Local $ilen = $acall[0x5]
    Local $tbuffer = DllStructCreate("byte[" & $ilen & "]")
    $acall = DllCall("advapi32.dll", "bool", "GetTokenInformation", "handle", $htoken, "int", $iclass, "struct*", $tbuffer, "dword", DllStructGetSize($tbuffer), "dword*", 0x0)
    If @error Or Not $acall[0x0] Then Return SetError(@error + 0xa, @extended, 0x0)
    Return $tbuffer
EndFunc   ;==>_SECURITY__GETTOKENINFORMATION
Func _Security__ImpersonateSelf($ilevel = $securityimpersonation)
    Local $acall = DllCall("advapi32.dll", "bool", "ImpersonateSelf", "int", $ilevel)
    If @error Then Return SetError(@error, @extended, False)
    Return Not ($acall[0x0] = 0x0)
EndFunc   ;==>_SECURITY__IMPERSONATESELF
Func _Security__IsValidSid($psid)
    Local $acall = DllCall("advapi32.dll", "bool", "IsValidSid", "struct*", $psid)
    If @error Then Return SetError(@error, @extended, False)
    Return Not ($acall[0x0] = 0x0)
EndFunc   ;==>_SECURITY__ISVALIDSID
Func _Security__LookupAccountName($saccount, $ssystem = "")
    Local $tdata = DllStructCreate("byte SID[256]")
    Local $acall = DllCall("advapi32.dll", "bool", "LookupAccountNameW", "wstr", $ssystem, "wstr", $saccount, "struct*", $tdata, "dword*", DllStructGetSize($tdata), "wstr", "", "dword*", DllStructGetSize($tdata), "int*", 0x0)
    If @error Or Not $acall[0x0] Then Return SetError(@error + 0xa, @extended, 0x0)
    Local $aacct[0x3]
    $aacct[0x0] = _Security__SidToStringSid(DllStructGetPtr($tdata, "SID"))
    $aacct[0x1] = $acall[0x5]
    $aacct[0x2] = $acall[0x7]
    Return $aacct
EndFunc   ;==>_SECURITY__LOOKUPACCOUNTNAME
Func _Security__LookupAccountSid($vsid, $ssystem = "")
    Local $psid, $aacct[0x3]
    If IsString($vsid) Then
        $psid = _Security__StringSidToSid($vsid)
    Else
        $psid = $vsid
    EndIf
    If Not _Security__IsValidSid($psid) Then Return SetError(@error + 0x14, @extended, 0x0)
    If $ssystem = "" Then $ssystem = NULL
    Local $acall = DllCall("advapi32.dll", "bool", "LookupAccountSidW", "wstr", $ssystem, "struct*", $psid, "wstr", "", "dword*", 0x10000, "wstr", "", "dword*", 0x10000, "int*", 0x0)
    If @error Or Not $acall[0x0] Then Return SetError(@error + 0xa, @extended, 0x0)
    Local $aacct[0x3]
    $aacct[0x0] = $acall[0x3]
    $aacct[0x1] = $acall[0x5]
    $aacct[0x2] = $acall[0x7]
    Return $aacct
EndFunc   ;==>_SECURITY__LOOKUPACCOUNTSID
Func _Security__LookupPrivilegeValue($ssystem, $sname)
    Local $acall = DllCall("advapi32.dll", "bool", "LookupPrivilegeValueW", "wstr", $ssystem, "wstr", $sname, "int64*", 0x0)
    If @error Or Not $acall[0x0] Then Return SetError(@error + 0xa, @extended, 0x0)
    Return $acall[0x3]
EndFunc   ;==>_SECURITY__LOOKUPPRIVILEGEVALUE
Func _Security__OpenProcessToken($hprocess, $iaccess)
    Local $acall = DllCall("advapi32.dll", "bool", "OpenProcessToken", "handle", $hprocess, "dword", $iaccess, "handle*", 0x0)
    If @error Or Not $acall[0x0] Then Return SetError(@error + 0xa, @extended, 0x0)
    Return $acall[0x3]
EndFunc   ;==>_SECURITY__OPENPROCESSTOKEN
Func _Security__OpenThreadToken($iaccess, $hthread = 0x0, $bopenasself = False)
    Local $acall
    If $hthread = 0x0 Then
        $acall = DllCall("kernel32.dll", "handle", "GetCurrentThread")
        If @error Then Return SetError(@error + 0x14, @extended, 0x0)
        $hthread = $acall[0x0]
    EndIf
    $acall = DllCall("advapi32.dll", "bool", "OpenThreadToken", "handle", $hthread, "dword", $iaccess, "bool", $bopenasself, "handle*", 0x0)
    If @error Or Not $acall[0x0] Then Return SetError(@error + 0xa, @extended, 0x0)
    Return $acall[0x4]
EndFunc   ;==>_SECURITY__OPENTHREADTOKEN
Func _Security__OpenThreadTokenEx($iaccess, $hthread = 0x0, $bopenasself = False)
    Local $htoken = _Security__OpenThreadToken($iaccess, $hthread, $bopenasself)
    If $htoken = 0x0 Then
        Local Const $error_no_token = 0x3f0
        If _WinAPI_GetLastError() <> $error_no_token Then Return SetError(0x14, _WinAPI_GetLastError(), 0x0)
        If Not _Security__ImpersonateSelf() Then Return SetError(@error + 0xa, _WinAPI_GetLastError(), 0x0)
        $htoken = _Security__OpenThreadToken($iaccess, $hthread, $bopenasself)
        If $htoken = 0x0 Then Return SetError(@error, _WinAPI_GetLastError(), 0x0)
    EndIf
    Return $htoken
EndFunc   ;==>_SECURITY__OPENTHREADTOKENEX
Func _Security__SetPrivilege($htoken, $sprivilege, $benable)
    Local $iluid = _Security__LookupPrivilegeValue("", $sprivilege)
    If $iluid = 0x0 Then Return SetError(@error + 0xa, @extended, False)
    Local Const $tagtoken_privileges = "dword Count;align 4;int64 LUID;dword Attributes"
    Local $tcurrstate = DllStructCreate($tagtoken_privileges)
    Local $icurrstate = DllStructGetSize($tcurrstate)
    Local $tprevstate = DllStructCreate($tagtoken_privileges)
    Local $iprevstate = DllStructGetSize($tprevstate)
    Local $trequired = DllStructCreate("int Data")
    DllStructSetData($tcurrstate, "Count", 0x1)
    DllStructSetData($tcurrstate, "LUID", $iluid)
    If Not _Security__AdjustTokenPrivileges($htoken, False, $tcurrstate, $icurrstate, $tprevstate, $trequired) Then Return SetError(0x2, @error, False)
    DllStructSetData($tprevstate, "Count", 0x1)
    DllStructSetData($tprevstate, "LUID", $iluid)
    Local $iattributes = DllStructGetData($tprevstate, "Attributes")
    If $benable Then
        $iattributes = BitOR($iattributes, $se_privilege_enabled)
    Else
        $iattributes = BitAND($iattributes, BitNOT($se_privilege_enabled))
    EndIf
    DllStructSetData($tprevstate, "Attributes", $iattributes)
    If Not _Security__AdjustTokenPrivileges($htoken, False, $tprevstate, $iprevstate, $tcurrstate, $trequired) Then Return SetError(0x3, @error, False)
    Return True
EndFunc   ;==>_SECURITY__SETPRIVILEGE
Func _Security__SetTokenInformation($htoken, $itokeninformation, $vtokeninformation, $itokeninformationlength)
    Local $acall = DllCall("advapi32.dll", "bool", "SetTokenInformation", "handle", $htoken, "int", $itokeninformation, "struct*", $vtokeninformation, "dword", $itokeninformationlength)
    If @error Or Not $acall[0x0] Then Return SetError(@error + 0xa, @extended, False)
    Return True
EndFunc   ;==>_SECURITY__SETTOKENINFORMATION
Func _Security__SidToStringSid($psid)
    If Not _Security__IsValidSid($psid) Then Return SetError(@error + 0xa, 0x0, "")
    Local $acall = DllCall("advapi32.dll", "bool", "ConvertSidToStringSidW", "struct*", $psid, "ptr*", 0x0)
    If @error Or Not $acall[0x0] Then Return SetError(@error + 0xa, @extended, "")
    Local $pstringsid = $acall[0x2]
    Local $alen = DllCall("kernel32.dll", "int", "lstrlenW", "struct*", $pstringsid)
    Local $ssid = DllStructGetData(DllStructCreate("wchar Text[" & $alen[0x0] + 0x1 & "]", $pstringsid), "Text")
    DllCall("kernel32.dll", "handle", "LocalFree", "handle", $pstringsid)
    Return $ssid
EndFunc   ;==>_SECURITY__SIDTOSTRINGSID
Func _Security__SidTypeStr($itype)
    Switch $itype
        Case $sidtypeuser
            Return "User"
        Case $sidtypegroup
            Return "Group"
        Case $sidtypedomain
            Return "Domain"
        Case $sidtypealias
            Return "Alias"
        Case $sidtypewellknowngroup
            Return "Well Known Group"
        Case $sidtypedeletedaccount
            Return "Deleted Account"
        Case $sidtypeinvalid
            Return "Invalid"
        Case $sidtypeunknown
            Return "Unknown Type"
        Case $sidtypecomputer
            Return "Computer"
        Case $sidtypelabel
            Return "A mandatory integrity label SID"
        Case Else
            Return "Unknown SID Type"
    EndSwitch
EndFunc   ;==>_SECURITY__SIDTYPESTR
Func _Security__StringSidToSid($ssid)
    Local $acall = DllCall("advapi32.dll", "bool", "ConvertStringSidToSidW", "wstr", $ssid, "ptr*", 0x0)
    If @error Or Not $acall[0x0] Then Return SetError(@error + 0xa, @extended, 0x0)
    Local $psid = $acall[0x2]
    Local $tbuffer = DllStructCreate("byte Data[" & _Security__GetLengthSid($psid) & "]", $psid)
    Local $tsid = DllStructCreate("byte Data[" & DllStructGetSize($tbuffer) & "]")
    DllStructSetData($tsid, "Data", DllStructGetData($tbuffer, "Data"))
    DllCall("kernel32.dll", "handle", "LocalFree", "handle", $psid)
    Return $tsid
EndFunc   ;==>_SECURITY__STRINGSIDTOSID
#endregion Public Functions
Func _SendMessage($hwnd, $imsg, $wparam = 0x0, $lparam = 0x0, $ireturn = 0x0, $wparamtype = "wparam", $lparamtype = "lparam", $sreturntype = "lresult")
    Local $acall = DllCall("user32.dll", $sreturntype, "SendMessageW", "hwnd", $hwnd, "uint", $imsg, $wparamtype, $wparam, $lparamtype, $lparam)
    If @error Then Return SetError(@error, @extended, "")
    If $ireturn >= 0x0 And $ireturn <= 0x4 Then Return $acall[$ireturn]
    Return $acall
EndFunc   ;==>_SENDMESSAGE
Func _SendMessageA($hwnd, $imsg, $wparam = 0x0, $lparam = 0x0, $ireturn = 0x0, $wparamtype = "wparam", $lparamtype = "lparam", $sreturntype = "lresult")
    Local $acall = DllCall("user32.dll", $sreturntype, "SendMessageA", "hwnd", $hwnd, "uint", $imsg, $wparamtype, $wparam, $lparamtype, $lparam)
    If @error Then Return SetError(@error, @extended, "")
    If $ireturn >= 0x0 And $ireturn <= 0x4 Then Return $acall[$ireturn]
    Return $acall
EndFunc   ;==>_SENDMESSAGEA
Global Const $tagpoint = "struct;long X;long Y;endstruct"
Global Const $tagrect = "struct;long Left;long Top;long Right;long Bottom;endstruct"
Global Const $tagsize = "struct;long X;long Y;endstruct"
Global Const $tagmargins = "int cxLeftWidth;int cxRightWidth;int cyTopHeight;int cyBottomHeight"
Global Const $tagfiletime = "struct;dword Lo;dword Hi;endstruct"
Global Const $tagsystemtime = "struct;word Year;word Month;word Dow;word Day;word Hour;word Minute;word Second;word MSeconds;endstruct"
Global Const $tagtime_zone_information = "struct;long Bias;wchar StdName[32];word StdDate[8];long StdBias;wchar DayName[32];word DayDate[8];long DayBias;endstruct"
Global Const $tagnmhdr = "struct;hwnd hWndFrom;uint_ptr IDFrom;INT Code;endstruct"
Global Const $tagcomboboxexitem = "uint Mask;int_ptr Item;ptr Text;int TextMax;int Image;int SelectedImage;int OverlayImage;" & "int Indent;lparam Param"
Global Const $tagnmcbedragbegin = $tagnmhdr & ";int ItemID;wchar szText[260]"
Global Const $tagnmcbeendedit = $tagnmhdr & ";bool fChanged;int NewSelection;wchar szText[260];int Why"
Global Const $tagnmcomboboxex = $tagnmhdr & ";uint Mask;int_ptr Item;ptr Text;int TextMax;int Image;" & "int SelectedImage;int OverlayImage;int Indent;lparam Param"
Global Const $tagdtprange = "word MinYear;word MinMonth;word MinDOW;word MinDay;word MinHour;word MinMinute;" & "word MinSecond;word MinMSecond;word MaxYear;word MaxMonth;word MaxDOW;word MaxDay;word MaxHour;" & "word MaxMinute;word MaxSecond;word MaxMSecond;bool MinValid;bool MaxValid"
Global Const $tagnmdatetimechange = $tagnmhdr & ";dword Flag;" & $tagsystemtime
Global Const $tagnmdatetimeformat = $tagnmhdr & ";ptr Format;" & $tagsystemtime & ";ptr pDisplay;wchar Display[64]"
Global Const $tagnmdatetimeformatquery = $tagnmhdr & ";ptr Format;struct;long SizeX;long SizeY;endstruct"
Global Const $tagnmdatetimekeydown = $tagnmhdr & ";int VirtKey;ptr Format;" & $tagsystemtime
Global Const $tagnmdatetimestring = $tagnmhdr & ";ptr UserString;" & $tagsystemtime & ";dword Flags"
Global Const $tageventlogrecord = "dword Length;dword Reserved;dword RecordNumber;dword TimeGenerated;dword TimeWritten;dword EventID;" & "word EventType;word NumStrings;word EventCategory;word ReservedFlags;dword ClosingRecordNumber;dword StringOffset;" & "dword UserSidLength;dword UserSidOffset;dword DataLength;dword DataOffset"
Global Const $taggdip_effectparams_blur = "float Radius; bool ExpandEdge"
Global Const $taggdip_effectparams_brightnesscontrast = "int BrightnessLevel; int ContrastLevel"
Global Const $taggdip_effectparams_colorbalance = "int CyanRed; int MagentaGreen; int YellowBlue"
Global Const $taggdip_effectparams_colorcurve = "int Adjustment; int Channel; int AdjustValue"
Global Const $taggdip_effectparams_colorlut = "byte LutB[256]; byte LutG[256]; byte LutR[256]; byte LutA[256]"
Global Const $taggdip_effectparams_huesaturationlightness = "int HueLevel; int SaturationLevel; int LightnessLevel"
Global Const $taggdip_effectparams_levels = "int Highlight; int Midtone; int Shadow"
Global Const $taggdip_effectparams_redeyecorrection = "uint NumberOfAreas; ptr Areas"
Global Const $taggdip_effectparams_sharpen = "float Radius; float Amount"
Global Const $taggdip_effectparams_tint = "int Hue; int Amount"
Global Const $taggdipbitmapdata = "uint Width;uint Height;int Stride;int Format;ptr Scan0;uint_ptr Reserved"
Global Const $taggdipcolormatrix = "float m[25]"
Global Const $taggdipencoderparam = "struct;byte GUID[16];ulong NumberOfValues;ulong Type;ptr Values;endstruct"
Global Const $taggdipencoderparams = "uint Count;" & $taggdipencoderparam
Global Const $taggdiprectf = "struct;float X;float Y;float Width;float Height;endstruct"
Global Const $taggdipstartupinput = "uint Version;ptr Callback;bool NoThread;bool NoCodecs"
Global Const $taggdipstartupoutput = "ptr HookProc;ptr UnhookProc"
Global Const $taggdipimagecodecinfo = "byte CLSID[16];byte FormatID[16];ptr CodecName;ptr DllName;ptr FormatDesc;ptr FileExt;" & "ptr MimeType;dword Flags;dword Version;dword SigCount;dword SigSize;ptr SigPattern;ptr SigMask"
Global Const $taggdippencoderparams = "uint Count;byte Params[1]"
Global Const $taghditem = "uint Mask;int XY;ptr Text;handle hBMP;int TextMax;int Fmt;lparam Param;int Image;int Order;uint Type;ptr pFilter;uint State"
Global Const $tagnmhddispinfo = $tagnmhdr & ";int Item;uint Mask;ptr Text;int TextMax;int Image;lparam lParam"
Global Const $tagnmhdfilterbtnclick = $tagnmhdr & ";int Item;" & $tagrect
Global Const $tagnmheader = $tagnmhdr & ";int Item;int Button;ptr pItem"
Global Const $taggetipaddress = "byte Field4;byte Field3;byte Field2;byte Field1"
Global Const $tagnmipaddress = $tagnmhdr & ";int Field;int Value"
Global Const $taglvfindinfo = "struct;uint Flags;ptr Text;lparam Param;" & $tagpoint & ";uint Direction;endstruct"
Global Const $taglvhittestinfo = $tagpoint & ";uint Flags;int Item;int SubItem;int iGroup"
Global Const $taglvitem = "struct;uint Mask;int Item;int SubItem;uint State;uint StateMask;ptr Text;int TextMax;int Image;lparam Param;" & "int Indent;int GroupID;uint Columns;ptr pColumns;ptr piColFmt;int iGroup;endstruct"
Global Const $tagnmlistview = $tagnmhdr & ";int Item;int SubItem;uint NewState;uint OldState;uint Changed;" & "struct;long ActionX;long ActionY;endstruct;lparam Param"
Global Const $tagnmlvcustomdraw = "struct;" & $tagnmhdr & ";dword dwDrawStage;handle hdc;" & $tagrect & ";dword_ptr dwItemSpec;uint uItemState;lparam lItemlParam;endstruct" & ";dword clrText;dword clrTextBk;int iSubItem;dword dwItemType;dword clrFace;int iIconEffect;" & "int iIconPhase;int iPartID;int iStateID;struct;long TextLeft;long TextTop;long TextRight;long TextBottom;endstruct;uint uAlign"
Global Const $tagnmlvdispinfo = $tagnmhdr & ";" & $taglvitem
Global Const $tagnmlvfinditem = $tagnmhdr & ";int Start;" & $taglvfindinfo
Global Const $tagnmlvgetinfotip = $tagnmhdr & ";dword Flags;ptr Text;int TextMax;int Item;int SubItem;lparam lParam"
Global Const $tagnmitemactivate = $tagnmhdr & ";int Index;int SubItem;uint NewState;uint OldState;uint Changed;" & $tagpoint & ";lparam lParam;uint KeyFlags"
Global Const $tagnmlvkeydown = $tagnmhdr & ";align 2;word VKey;uint Flags"
Global Const $tagnmlvscroll = $tagnmhdr & ";int DX;int DY"
Global Const $tagmchittestinfo = "uint Size;" & $tagpoint & ";uint Hit;" & $tagsystemtime & ";" & $tagrect & ";int iOffset;int iRow;int iCol"
Global Const $tagmcmonthrange = "word MinYear;word MinMonth;word MinDOW;word MinDay;word MinHour;word MinMinute;word MinSecond;" & "word MinMSeconds;word MaxYear;word MaxMonth;word MaxDOW;word MaxDay;word MaxHour;word MaxMinute;word MaxSecond;" & "word MaxMSeconds;short Span"
Global Const $tagmcrange = "word MinYear;word MinMonth;word MinDOW;word MinDay;word MinHour;word MinMinute;word MinSecond;" & "word MinMSeconds;word MaxYear;word MaxMonth;word MaxDOW;word MaxDay;word MaxHour;word MaxMinute;word MaxSecond;" & "word MaxMSeconds;short MinSet;short MaxSet"
Global Const $tagmcselrange = "word MinYear;word MinMonth;word MinDOW;word MinDay;word MinHour;word MinMinute;word MinSecond;" & "word MinMSeconds;word MaxYear;word MaxMonth;word MaxDOW;word MaxDay;word MaxHour;word MaxMinute;word MaxSecond;" & "word MaxMSeconds"
Global Const $tagnmdaystate = $tagnmhdr & ";" & $tagsystemtime & ";int DayState;ptr pDayState"
Global Const $tagnmselchange = $tagnmhdr & ";struct;word BegYear;word BegMonth;word BegDOW;word BegDay;word BegHour;word BegMinute;word BegSecond;word BegMSeconds;endstruct;" & "struct;word EndYear;word EndMonth;word EndDOW;word EndDay;word EndHour;word EndMinute;word EndSecond;word EndMSeconds;endstruct"
Global Const $tagnmobjectnotify = $tagnmhdr & ";int Item;ptr piid;ptr pObject;long Result;dword dwFlags"
Global Const $tagnmtckeydown = $tagnmhdr & ";align 2;word VKey;uint Flags"
Global Const $tagtvitem = "struct;uint Mask;handle hItem;uint State;uint StateMask;ptr Text;int TextMax;int Image;int SelectedImage;" & "int Children;lparam Param;endstruct"
Global Const $tagtvitemex = "struct;" & $tagtvitem & ";int Integral;uint uStateEx;hwnd hwnd;int iExpandedImage;int iReserved;endstruct"
Global Const $tagnmtreeview = $tagnmhdr & ";uint Action;" & "struct;uint OldMask;handle OldhItem;uint OldState;uint OldStateMask;" & "ptr OldText;int OldTextMax;int OldImage;int OldSelectedImage;int OldChildren;lparam OldParam;endstruct;" & "struct;uint NewMask;handle NewhItem;uint NewState;uint NewStateMask;" & "ptr NewText;int NewTextMax;int NewImage;int NewSelectedImage;int NewChildren;lparam NewParam;endstruct;" & "struct;long PointX;long PointY;endstruct"
Global Const $tagnmtvcustomdraw = "struct;" & $tagnmhdr & ";dword DrawStage;handle HDC;" & $tagrect & ";dword_ptr ItemSpec;uint ItemState;lparam ItemParam;endstruct" & ";dword ClrText;dword ClrTextBk;int Level"
Global Const $tagnmtvdispinfo = $tagnmhdr & ";" & $tagtvitem
Global Const $tagnmtvgetinfotip = $tagnmhdr & ";ptr Text;int TextMax;handle hItem;lparam lParam"
Global Const $tagnmtvitemchange = $tagnmhdr & ";uint Changed;handle hItem;uint StateNew;uint StateOld;lparam lParam;"
Global Const $tagtvhittestinfo = $tagpoint & ";uint Flags;handle Item"
Global Const $tagnmtvkeydown = $tagnmhdr & ";align 2;word VKey;uint Flags"
Global Const $tagnmmouse = $tagnmhdr & ";dword_ptr ItemSpec;dword_ptr ItemData;" & $tagpoint & ";lparam HitInfo"
Global Const $tagtoken_privileges = "dword Count;align 4;int64 LUID;dword Attributes"
Global Const $tagimageinfo = "handle hBitmap;handle hMask;int Unused1;int Unused2;" & $tagrect
Global Const $tagmenuinfo = "dword Size;INT Mask;dword Style;uint YMax;handle hBack;dword ContextHelpID;ulong_ptr MenuData"
Global Const $tagmenuiteminfo = "uint Size;uint Mask;uint Type;uint State;uint ID;handle SubMenu;handle BmpChecked;handle BmpUnchecked;" & "ulong_ptr ItemData;ptr TypeData;uint CCH;handle BmpItem"
Global Const $tagrebarbandinfo = "uint cbSize;uint fMask;uint fStyle;dword clrFore;dword clrBack;ptr lpText;uint cch;" & "int iImage;hwnd hwndChild;uint cxMinChild;uint cyMinChild;uint cx;handle hbmBack;uint wID;uint cyChild;uint cyMaxChild;" & "uint cyIntegral;uint cxIdeal;lparam lParam;uint cxHeader" & ((@OSVersion = "WIN_XP") ? "" : ";" & $tagrect & ";uint uChevronState")
Global Const $tagnmrebarautobreak = $tagnmhdr & ";uint uBand;uint wID;lparam lParam;uint uMsg;uint fStyleCurrent;bool fAutoBreak"
Global Const $tagnmrbautosize = $tagnmhdr & ";bool fChanged;" & "struct;long TargetLeft;long TargetTop;long TargetRight;long TargetBottom;endstruct;" & "struct;long ActualLeft;long ActualTop;long ActualRight;long ActualBottom;endstruct"
Global Const $tagnmrebar = $tagnmhdr & ";dword dwMask;uint uBand;uint fStyle;uint wID;lparam lParam"
Global Const $tagnmrebarchevron = $tagnmhdr & ";uint uBand;uint wID;lparam lParam;" & $tagrect & ";lparam lParamNM"
Global Const $tagnmrebarchildsize = $tagnmhdr & ";uint uBand;uint wID;" & "struct;long CLeft;long CTop;long CRight;long CBottom;endstruct;" & "struct;long BLeft;long BTop;long BRight;long BBottom;endstruct"
Global Const $tagcolorscheme = "dword Size;dword BtnHighlight;dword BtnShadow"
Global Const $tagnmtoolbar = $tagnmhdr & ";int iItem;" & "struct;int iBitmap;int idCommand;byte fsState;byte fsStyle;dword_ptr dwData;int_ptr iString;endstruct" & ";int cchText;ptr pszText;" & $tagrect
Global Const $tagnmtbhotitem = $tagnmhdr & ";int idOld;int idNew;dword dwFlags"
Global Const $tagtbbutton = "int Bitmap;int Command;byte State;byte Style;dword_ptr Param;int_ptr String"
Global Const $tagtbbuttoninfo = "uint Size;dword Mask;int Command;int Image;byte State;byte Style;word CX;dword_ptr Param;ptr Text;int TextMax"
Global Const $tagnetresource = "dword Scope;dword Type;dword DisplayType;dword Usage;ptr LocalName;ptr RemoteName;ptr Comment;ptr Provider"
Global Const $tagoverlapped = "ulong_ptr Internal;ulong_ptr InternalHigh;struct;dword Offset;dword OffsetHigh;endstruct;handle hEvent"
Global Const $tagopenfilename = "dword StructSize;hwnd hwndOwner;handle hInstance;ptr lpstrFilter;ptr lpstrCustomFilter;" & "dword nMaxCustFilter;dword nFilterIndex;ptr lpstrFile;dword nMaxFile;ptr lpstrFileTitle;dword nMaxFileTitle;" & "ptr lpstrInitialDir;ptr lpstrTitle;dword Flags;word nFileOffset;word nFileExtension;ptr lpstrDefExt;lparam lCustData;" & "ptr lpfnHook;ptr lpTemplateName;ptr pvReserved;dword dwReserved;dword FlagsEx"
Global Const $tagbitmapinfoheader = "struct;dword biSize;long biWidth;long biHeight;word biPlanes;word biBitCount;" & "dword biCompression;dword biSizeImage;long biXPelsPerMeter;long biYPelsPerMeter;dword biClrUsed;dword biClrImportant;endstruct"
Global Const $tagbitmapinfo = $tagbitmapinfoheader & ";dword biRGBQuad[1]"
Global Const $tagblendfunction = "byte Op;byte Flags;byte Alpha;byte Format"
Global Const $tagguid = "struct;ulong Data1;ushort Data2;ushort Data3;byte Data4[8];endstruct"
Global Const $tagwindowplacement = "uint length;uint flags;uint showCmd;long ptMinPosition[2];long ptMaxPosition[2];long rcNormalPosition[4]"
Global Const $tagwindowpos = "hwnd hWnd;hwnd InsertAfter;int X;int Y;int CX;int CY;uint Flags"
Global Const $tagscrollinfo = "uint cbSize;uint fMask;int nMin;int nMax;uint nPage;int nPos;int nTrackPos"
Global Const $tagscrollbarinfo = "dword cbSize;" & $tagrect & ";int dxyLineButton;int xyThumbTop;" & "int xyThumbBottom;int reserved;dword rgstate[6]"
Global Const $taglogfont = "struct;long Height;long Width;long Escapement;long Orientation;long Weight;byte Italic;byte Underline;" & "byte Strikeout;byte CharSet;byte OutPrecision;byte ClipPrecision;byte Quality;byte PitchAndFamily;wchar FaceName[32];endstruct"
Global Const $tagkbdllhookstruct = "dword vkCode;dword scanCode;dword flags;dword time;ulong_ptr dwExtraInfo"
Global Const $tagprocess_information = "handle hProcess;handle hThread;dword ProcessID;dword ThreadID"
Global Const $tagstartupinfo = "dword Size;ptr Reserved1;ptr Desktop;ptr Title;dword X;dword Y;dword XSize;dword YSize;dword XCountChars;" & "dword YCountChars;dword FillAttribute;dword Flags;word ShowWindow;word Reserved2;ptr Reserved3;handle StdInput;" & "handle StdOutput;handle StdError"
Global Const $tagsecurity_attributes = "dword Length;ptr Descriptor;bool InheritHandle"
Global Const $tagwin32_find_data = "dword dwFileAttributes;dword ftCreationTime[2];dword ftLastAccessTime[2];dword ftLastWriteTime[2];dword nFileSizeHigh;dword nFileSizeLow;dword dwReserved0;dword dwReserved1;wchar cFileName[260];wchar cAlternateFileName[14]"
Global Const $tagtextmetric = "long tmHeight;long tmAscent;long tmDescent;long tmInternalLeading;long tmExternalLeading;" & "long tmAveCharWidth;long tmMaxCharWidth;long tmWeight;long tmOverhang;long tmDigitizedAspectX;long tmDigitizedAspectY;" & "wchar tmFirstChar;wchar tmLastChar;wchar tmDefaultChar;wchar tmBreakChar;byte tmItalic;byte tmUnderlined;byte tmStruckOut;" & "byte tmPitchAndFamily;byte tmCharSet"
Global Const $hgdi_error = Ptr(+0xffffffff)
Global Const $invalid_handle_value = Ptr(+0xffffffff)
Global Const $clr_invalid = +0xffffffff
Global Const $mb_precomposed = 0x1
Global Const $mb_composite = 0x2
Global Const $mb_useglyphchars = 0x4
Global Const $ulw_alpha = 0x2
Global Const $ulw_colorkey = 0x1
Global Const $ulw_opaque = 0x4
Global Const $ulw_ex_noresize = 0x8
Global Const $wh_callwndproc = 0x4
Global Const $wh_callwndprocret = 0xc
Global Const $wh_cbt = 0x5
Global Const $wh_debug = 0x9
Global Const $wh_foregroundidle = 0xb
Global Const $wh_getmessage = 0x3
Global Const $wh_journalplayback = 0x1
Global Const $wh_journalrecord = 0x0
Global Const $wh_keyboard = 0x2
Global Const $wh_keyboard_ll = 0xd
Global Const $wh_mouse = 0x7
Global Const $wh_mouse_ll = 0xe
Global Const $wh_msgfilter = +0xffffffff
Global Const $wh_shell = 0xa
Global Const $wh_sysmsgfilter = 0x6
Global Const $wpf_asyncwindowplacement = 0x4
Global Const $wpf_restoretomaximized = 0x2
Global Const $wpf_setminposition = 0x1
Global Const $kf_extended = 0x100
Global Const $kf_altdown = 0x2000
Global Const $kf_up = 0x8000
Global Const $llkhf_extended = BitShift($kf_extended, 0x8)
Global Const $llkhf_lower_il_injected = 0x2
Global Const $llkhf_injected = 0x10
Global Const $llkhf_altdown = BitShift($kf_altdown, 0x8)
Global Const $llkhf_up = BitShift($kf_up, 0x8)
Global Const $lvkf_alt = 0x1
Global Const $lvkf_control = 0x2
Global Const $lvkf_shift = 0x4
Global Const $ofn_allowmultiselect = 0x200
Global Const $ofn_createprompt = 0x2000
Global Const $ofn_dontaddtorecent = 0x2000000
Global Const $ofn_enablehook = 0x20
Global Const $ofn_enableincludenotify = 0x400000
Global Const $ofn_enablesizing = 0x800000
Global Const $ofn_enabletemplate = 0x40
Global Const $ofn_enabletemplatehandle = 0x80
Global Const $ofn_explorer = 0x80000
Global Const $ofn_extensiondifferent = 0x400
Global Const $ofn_filemustexist = 0x1000
Global Const $ofn_forceshowhidden = 0x10000000
Global Const $ofn_hidereadonly = 0x4
Global Const $ofn_longnames = 0x200000
Global Const $ofn_nochangedir = 0x8
Global Const $ofn_nodereferencelinks = 0x100000
Global Const $ofn_nolongnames = 0x40000
Global Const $ofn_nonetworkbutton = 0x20000
Global Const $ofn_noreadonlyreturn = 0x8000
Global Const $ofn_notestfilecreate = 0x10000
Global Const $ofn_novalidate = 0x100
Global Const $ofn_overwriteprompt = 0x2
Global Const $ofn_pathmustexist = 0x800
Global Const $ofn_readonly = 0x1
Global Const $ofn_shareaware = 0x4000
Global Const $ofn_showhelp = 0x10
Global Const $ofn_ex_noplacesbar = 0x1
Global Const $std_cut = 0x0
Global Const $std_copy = 0x1
Global Const $std_paste = 0x2
Global Const $std_undo = 0x3
Global Const $std_redow = 0x4
Global Const $std_delete = 0x5
Global Const $std_filenew = 0x6
Global Const $std_fileopen = 0x7
Global Const $std_filesave = 0x8
Global Const $std_printpre = 0x9
Global Const $std_properties = 0xa
Global Const $std_help = 0xb
Global Const $std_find = 0xc
Global Const $std_replace = 0xd
Global Const $std_print = 0xe
Global Const $kb_sendspecial = 0x0
Global Const $kb_sendraw = 0x1
Global Const $kb_capsoff = 0x0
Global Const $kb_capson = 0x1
Global Const $s_ok = 0x0
Global Const $e_abort = 0x80004004
Global Const $e_accessdenied = 0x80070005
Global Const $e_fail = 0x80004005
Global Const $e_handle = 0x80070006
Global Const $e_invalidarg = 0x80070057
Global Const $e_nointerface = 0x80004002
Global Const $e_notimpl = 0x80004001
Global Const $e_outofmemory = 0x8007000e
Global Const $e_pointer = 0x80004003
Global Const $e_unexpected = 0x8000ffff
#region Global Variables and Constants
Global $__g_venum, $__g_vext = 0x0
Global $__g_irgbmode = 0x1
Global Const $tagosversioninfo = "struct;dword OSVersionInfoSize;dword MajorVersion;dword MinorVersion;dword BuildNumber;dword PlatformId;wchar CSDVersion[128];endstruct"
Global Const $image_bitmap = 0x0
Global Const $image_icon = 0x1
Global Const $image_cursor = 0x2
Global Const $image_enhmetafile = 0x3
Global Const $lr_defaultcolor = 0x0
Global Const $lr_monochrome = 0x1
Global Const $lr_color = 0x2
Global Const $lr_copyreturnorg = 0x4
Global Const $lr_copydeleteorg = 0x8
Global Const $lr_loadfromfile = 0x10
Global Const $lr_loadtransparent = 0x20
Global Const $lr_defaultsize = 0x40
Global Const $lr_vgacolor = 0x80
Global Const $lr_loadmap3dcolors = 0x1000
Global Const $lr_createdibsection = 0x2000
Global Const $lr_copyfromresource = 0x4000
Global Const $lr_shared = 0x8000
Global Const $__tagcursorinfo = "dword Size;dword Flags;handle hCursor;" & "struct;long X;long Y;endstruct"
#endregion Global Variables and Constants
#region Functions list
#endregion Functions list
#region Public Functions
Func _WinAPI_CreateFile($sfilename, $icreation, $iaccess = 0x4, $ishare = 0x0, $iattributes = 0x0, $tsecurity = 0x0)
    Local $ida = 0x0, $ism = 0x0, $icd = 0x0, $ifa = 0x0
    If BitAND($iaccess, 0x1) <> 0x0 Then $ida = BitOR($ida, $generic_execute)
    If BitAND($iaccess, 0x2) <> 0x0 Then $ida = BitOR($ida, $generic_read)
    If BitAND($iaccess, 0x4) <> 0x0 Then $ida = BitOR($ida, $generic_write)
    If BitAND($ishare, 0x1) <> 0x0 Then $ism = BitOR($ism, $file_share_delete)
    If BitAND($ishare, 0x2) <> 0x0 Then $ism = BitOR($ism, $file_share_read)
    If BitAND($ishare, 0x4) <> 0x0 Then $ism = BitOR($ism, $file_share_write)
    Switch $icreation
        Case 0x0
            $icd = $create_new
        Case 0x1
            $icd = $create_always
        Case 0x2
            $icd = $open_existing
        Case 0x3
            $icd = $open_always
        Case 0x4
            $icd = $truncate_existing
    EndSwitch
    If BitAND($iattributes, 0x1) <> 0x0 Then $ifa = BitOR($ifa, $file_attribute_archive)
    If BitAND($iattributes, 0x2) <> 0x0 Then $ifa = BitOR($ifa, $file_attribute_hidden)
    If BitAND($iattributes, 0x4) <> 0x0 Then $ifa = BitOR($ifa, $file_attribute_readonly)
    If BitAND($iattributes, 0x8) <> 0x0 Then $ifa = BitOR($ifa, $file_attribute_system)
    Local $acall = DllCall("kernel32.dll", "handle", "CreateFileW", "wstr", $sfilename, "dword", $ida, "dword", $ism, "struct*", $tsecurity, "dword", $icd, "dword", $ifa, "ptr", 0x0)
    If @error Or ($acall[0x0] = Ptr(+0xffffffff)) Then Return SetError(@error, @extended, 0x0)
    Return $acall[0x0]
EndFunc   ;==>_WINAPI_CREATEFILE
Func _WinAPI_FreeLibrary($hmodule)
    Local $acall = DllCall("kernel32.dll", "bool", "FreeLibrary", "handle", $hmodule)
    If @error Then Return SetError(@error, @extended, False)
    Return $acall[0x0]
EndFunc   ;==>_WINAPI_FREELIBRARY
Func _WinAPI_GetCursorInfo()
    Local $tcursor = DllStructCreate($__tagcursorinfo)
    Local $icursor = DllStructGetSize($tcursor)
    DllStructSetData($tcursor, "Size", $icursor)
    Local $acall = DllCall("user32.dll", "bool", "GetCursorInfo", "struct*", $tcursor)
    If @error Or Not $acall[0x0] Then Return SetError(@error + 0xa, @extended, 0x0)
    Local $acursor[0x5]
    $acursor[0x0] = True
    $acursor[0x1] = DllStructGetData($tcursor, "Flags") <> 0x0
    $acursor[0x2] = DllStructGetData($tcursor, "hCursor")
    $acursor[0x3] = DllStructGetData($tcursor, "X")
    $acursor[0x4] = DllStructGetData($tcursor, "Y")
    Return $acursor
EndFunc   ;==>_WINAPI_GETCURSORINFO
Func _WinAPI_GetDlgCtrlID($hwnd)
    Local $acall = DllCall("user32.dll", "int", "GetDlgCtrlID", "hwnd", $hwnd)
    If @error Then Return SetError(@error, @extended, 0x0)
    Return $acall[0x0]
EndFunc   ;==>_WINAPI_GETDLGCTRLID
Func _WinAPI_GetModuleHandle($smodulename)
    If $smodulename = "" Then $smodulename = NULL
    Local $acall = DllCall("kernel32.dll", "handle", "GetModuleHandleW", "wstr", $smodulename)
    If @error Then Return SetError(@error, @extended, 0x0)
    Return $acall[0x0]
EndFunc   ;==>_WINAPI_GETMODULEHANDLE
Func _WINAPI_GETSTRING($pstring, $bunicode = True)
    Local $ilength = _WINAPI_STRLEN($pstring, $bunicode)
    If @error Or Not $ilength Then Return SetError(@error + 0xa, @extended, "")
    Local $tstring = DllStructCreate(($bunicode ? "wchar" : "char") & "[" & ($ilength + 0x1) & "]", $pstring)
    If @error Then Return SetError(@error, @extended, "")
    Return SetExtended($ilength, DllStructGetData($tstring, 0x1))
EndFunc   ;==>_WINAPI_GETSTRING
Func _WINAPI_GETVERSION()
    Local $tosvi = DllStructCreate($tagosversioninfo)
    DllStructSetData($tosvi, 0x1, DllStructGetSize($tosvi))
    Local $acall = DllCall("kernel32.dll", "bool", "GetVersionExW", "struct*", $tosvi)
    If @error Or Not $acall[0x0] Then Return SetError(@error, @extended, 0x0)
    Return Number(DllStructGetData($tosvi, 0x2) & "." & DllStructGetData($tosvi, 0x3), $number_double)
EndFunc   ;==>_WINAPI_GETVERSION
Func _WINAPI_ISWOW64PROCESS($ipid = 0x0)
    If Not $ipid Then $ipid = @AutoItPID
    Local $hprocess = DllCall("kernel32.dll", "handle", "OpenProcess", "dword", (_WINAPI_GETVERSION() < 6 ? 0x400 : 0x1000), "bool", 0x0, "dword", $ipid)
    If @error Or Not $hprocess[0x0] Then Return SetError(@error + 0x14, @extended, False)
    Local $acall = DllCall("kernel32.dll", "bool", "IsWow64Process", "handle", $hprocess[0x0], "bool*", 0x0)
    If __CHECKERRORCLOSEHANDLE($acall, $hprocess[0x0]) Then Return SetError(@error, @extended, False)
    Return $acall[0x2]
EndFunc   ;==>_WINAPI_ISWOW64PROCESS
Func _WinAPI_LoadImage($hinstance, $simage, $itype, $ixdesired, $iydesired, $iload)
    Local $acall, $simagetype = "int"
    If IsString($simage) Then $simagetype = "wstr"
    $acall = DllCall("user32.dll", "handle", "LoadImageW", "handle", $hinstance, $simagetype, $simage, "uint", $itype, "int", $ixdesired, "int", $iydesired, "uint", $iload)
    If @error Then Return SetError(@error, @extended, 0x0)
    Return $acall[0x0]
EndFunc   ;==>_WINAPI_LOADIMAGE
Func _WinAPI_LoadLibrary($sfilename)
    Local $acall = DllCall("kernel32.dll", "handle", "LoadLibraryW", "wstr", $sfilename)
    If @error Then Return SetError(@error, @extended, 0x0)
    Return $acall[0x0]
EndFunc   ;==>_WINAPI_LOADLIBRARY
Func _WINAPI_PATHISDIRECTORY($sfilepath)
    Local $acall = DllCall("shlwapi.dll", "bool", "PathIsDirectoryW", "wstr", $sfilepath)
    If @error Then Return SetError(@error, @extended, False)
    Return $acall[0x0]
EndFunc   ;==>_WINAPI_PATHISDIRECTORY
Func _WinAPI_ReadFile($hfile, $pbuffer, $itoread, ByRef $iread, $toverlapped = 0x0)
    Local $acall = DllCall("kernel32.dll", "bool", "ReadFile", "handle", $hfile, "struct*", $pbuffer, "dword", $itoread, "dword*", 0x0, "struct*", $toverlapped)
    If @error Then Return SetError(@error, @extended, False)
    $iread = $acall[0x4]
    Return $acall[0x0]
EndFunc   ;==>_WINAPI_READFILE
Func _WINAPI_STRLEN($pstring, $bunicode = True)
    Local $w = ""
    If $bunicode Then $w = "W"
    Local $acall = DllCall("kernel32.dll", "int", "lstrlen" & $w, "struct*", $pstring)
    If @error Then Return SetError(@error, @extended, 0x0)
    Return $acall[0x0]
EndFunc   ;==>_WINAPI_STRLEN
Func _WINAPI_SWITCHCOLOR($icolor)
    If $icolor = +0xffffffff Then Return $icolor
    Return BitOR(BitAND($icolor, 0xff00), BitShift(BitAND($icolor, 0xff), +0xfffffff0), BitShift(BitAND($icolor, 0xff0000), 0x10))
EndFunc   ;==>_WINAPI_SWITCHCOLOR
Func _WinAPI_WriteFile($hfile, $pbuffer, $itowrite, ByRef $iwritten, $toverlapped = 0x0)
    Local $acall = DllCall("kernel32.dll", "bool", "WriteFile", "handle", $hfile, "struct*", $pbuffer, "dword", $itowrite, "dword*", 0x0, "struct*", $toverlapped)
    If @error Then Return SetError(@error, @extended, False)
    $iwritten = $acall[0x4]
    Return $acall[0x0]
EndFunc   ;==>_WINAPI_WRITEFILE
#endregion Public Functions
#region Internal Functions
Func __CHECKERRORARRAYBOUNDS(Const ByRef $adata, ByRef $istart, ByRef $iend, $ndim = 0x1, $idim = $ubound_dimensions)
    If Not IsArray($adata) Then Return SetError(0x1, 0x0, 0x1)
    If UBound($adata, $idim) <> $ndim Then Return SetError(0x2, 0x0, 0x1)
    If $istart < 0x0 Then $istart = 0x0
    Local $iubound = UBound($adata) + 0xffffffff
    If $iend < 0x1 Or $iend > $iubound Then $iend = $iubound
    If $istart > $iend Then Return SetError(0x4, 0x0, 0x1)
    Return 0x0
EndFunc   ;==>__CHECKERRORARRAYBOUNDS
Func __CHECKERRORCLOSEHANDLE($acall, $hfile, $blasterror = False, $icurerr = @error, $icurext = @extended)
    If Not $icurerr And Not $acall[0x0] Then $icurerr = 0xa
    Local $alasterror = DllCall("kernel32.dll", "dword", "GetLastError")
    DllCall("kernel32.dll", "bool", "CloseHandle", "handle", $hfile)
    If $icurerr Then DllCall("kernel32.dll", "none", "SetLastError", "dword", $alasterror[0x0])
    If $blasterror Then $icurext = $alasterror[0x0]
    Return SetError($icurerr, $icurext, $icurerr)
EndFunc   ;==>__CHECKERRORCLOSEHANDLE
Func __DLL($spath, $bpin = False)
    Local $acall = DllCall("kernel32.dll", "bool", "GetModuleHandleExW", "dword", ($bpin ? 0x1 : 0x2), "wstr", $spath, "ptr*", 0x0)
    If Not $acall[0x3] Then
        $acall = DllCall("kernel32.dll", "handle", "LoadLibraryW", "wstr", $spath)
        If @error Or Not $acall[0x0] Then Return 0x0
    EndIf
    Return 0x1
EndFunc   ;==>__DLL
Func __ENUMWINDOWSPROC($hwnd, $bvisible)
    Local $acall
    If $bvisible Then
        $acall = DllCall("user32.dll", "bool", "IsWindowVisible", "hwnd", $hwnd)
        If Not $acall[0x0] Then
            Return 0x1
        EndIf
    EndIf
    __INC($__g_venum)
    $__g_venum[$__g_venum[0x0][0x0]][0x0] = $hwnd
    $acall = DllCall("user32.dll", "int", "GetClassNameW", "hwnd", $hwnd, "wstr", "", "int", 0x1000)
    $__g_venum[$__g_venum[0x0][0x0]][0x1] = $acall[0x2]
    Return 0x1
EndFunc   ;==>__ENUMWINDOWSPROC
Func __FATALEXIT($icode, $stext = "")
    If $stext Then MsgBox($mb_systemmodal, "AutoIt", $stext)
    DllCall("kernel32.dll", "none", "FatalExit", "int", $icode)
EndFunc   ;==>__FATALEXIT
Func __INC(ByRef $adata, $iincrement = 0x64)
    Select
        Case UBound($adata, $ubound_columns)
            If $iincrement < 0x0 Then
                ReDim $adata[$adata[0x0][0x0] + 0x1][UBound($adata, $ubound_columns)]
            Else
                $adata[0x0][0x0] += 0x1
                If $adata[0x0][0x0] > UBound($adata) + 0xffffffff Then
                    ReDim $adata[$adata[0x0][0x0] + $iincrement][UBound($adata, $ubound_columns)]
                EndIf
            EndIf
        Case UBound($adata, $ubound_rows)
            If $iincrement < 0x0 Then
                ReDim $adata[$adata[0x0] + 0x1]
            Else
                $adata[0x0] += 0x1
                If $adata[0x0] > UBound($adata) + 0xffffffff Then
                    ReDim $adata[$adata[0x0] + $iincrement]
                EndIf
            EndIf
        Case Else
            Return 0x0
    EndSelect
    Return 0x1
EndFunc   ;==>__INC
Func __RGB($icolor)
    If $__g_irgbmode Then
        $icolor = _WINAPI_SWITCHCOLOR($icolor)
    EndIf
    Return $icolor
EndFunc   ;==>__RGB
#endregion Internal Functions
#region Global Variables and Constants
#endregion Global Variables and Constants
#region Functions list
#endregion Functions list
#region Public Functions
Func _WINAPI_CHARTOOEM($sstr)
    Local $acall, $sretstr = "", $nlen = StringLen($sstr) + 0x1, $istart = 0x1
    While $istart < $nlen
        $acall = DllCall("user32.dll", "bool", "CharToOemW", "wstr", StringMid($sstr, $istart, 0x10000), "wstr", "")
        If @error Or Not $acall[0x0] Then Return SetError(@error + 0xa, @extended, "")
        $istart += 0x10000
        $sretstr &= $acall[0x2]
    WEnd
    Return $sretstr
EndFunc   ;==>_WINAPI_CHARTOOEM
Func _WinAPI_ClientToScreen($hwnd, ByRef $tpoint)
    Local $acall = DllCall("user32.dll", "bool", "ClientToScreen", "hwnd", $hwnd, "struct*", $tpoint)
    If @error Or Not $acall[0x0] Then Return SetError(@error + 0xa, @extended, 0x0)
    Return $tpoint
EndFunc   ;==>_WINAPI_CLIENTTOSCREEN
Func _WINAPI_DWORDTOFLOAT($ivalue)
    Local $tdword = DllStructCreate("dword")
    Local $tfloat = DllStructCreate("float", DllStructGetPtr($tdword))
    DllStructSetData($tdword, 0x1, $ivalue)
    Return DllStructGetData($tfloat, 0x1)
EndFunc   ;==>_WINAPI_DWORDTOFLOAT
Func _WINAPI_DWORDTOINT($ivalue)
    Local $tdata = DllStructCreate("int")
    DllStructSetData($tdata, 0x1, $ivalue)
    Return DllStructGetData($tdata, 0x1)
EndFunc   ;==>_WINAPI_DWORDTOINT
Func _WINAPI_FLOATTODWORD($ivalue)
    Local $tfloat = DllStructCreate("float")
    Local $tdword = DllStructCreate("dword", DllStructGetPtr($tfloat))
    DllStructSetData($tfloat, 0x1, $ivalue)
    Return DllStructGetData($tdword, 0x1)
EndFunc   ;==>_WINAPI_FLOATTODWORD
Func _WinAPI_FloatToInt($nfloat)
    Local $tfloat = DllStructCreate("float")
    Local $tint = DllStructCreate("int", DllStructGetPtr($tfloat))
    DllStructSetData($tfloat, 0x1, $nfloat)
    Return DllStructGetData($tint, 0x1)
EndFunc   ;==>_WINAPI_FLOATTOINT
Func _WinAPI_GetXYFromPoint(ByRef $tpoint, ByRef $ix, ByRef $iy)
    $ix = DllStructGetData($tpoint, "X")
    $iy = DllStructGetData($tpoint, "Y")
EndFunc   ;==>_WINAPI_GETXYFROMPOINT
Func _WinAPI_GUIDFromString($sguid)
    Local $tguid = DllStructCreate($tagguid)
    If Not _WinAPI_GUIDFromStringEx($sguid, $tguid) Then Return SetError(@error, @extended, 0x0)
    Return $tguid
EndFunc   ;==>_WINAPI_GUIDFROMSTRING
Func _WinAPI_GUIDFromStringEx($sguid, $tguid)
    Local $acall = DllCall("ole32.dll", "long", "CLSIDFromString", "wstr", $sguid, "struct*", $tguid)
    If @error Then Return SetError(@error, @extended, False)
    If $acall[0x0] Then Return SetError(0xa, $acall[0x0], False)
    Return True
EndFunc   ;==>_WINAPI_GUIDFROMSTRINGEX
Func _WINAPI_HASHDATA($pmemory, $isize, $ilength = 0x20)
    If ($ilength <= 0x0) Or ($ilength > 0x100) Then Return SetError(0xb, 0x0, 0x0)
    Local $tdata = DllStructCreate("byte[" & $ilength & "]")
    Local $acall = DllCall("shlwapi.dll", "uint", "HashData", "struct*", $pmemory, "dword", $isize, "struct*", $tdata, "dword", $ilength)
    If @error Then Return SetError(@error, @extended, 0x0)
    If $acall[0x0] Then Return SetError(0xa, $acall[0x0], 0x0)
    Return DllStructGetData($tdata, 0x1)
EndFunc   ;==>_WINAPI_HASHDATA
Func _WINAPI_HASHSTRING($sstring, $bcasesensitive = True, $ilength = 0x20)
    Local $ilengths = StringLen($sstring)
    If Not $ilengths Or ($ilength > 0x100) Then Return SetError(0xc, 0x0, 0x0)
    Local $tstring = DllStructCreate("wchar[" & ($ilengths + 0x1) & "]")
    If Not $bcasesensitive Then
        $sstring = StringLower($sstring)
    EndIf
    DllStructSetData($tstring, 0x1, $sstring)
    Local $shash = _WINAPI_HASHDATA($tstring, 0x2 * $ilengths, $ilength)
    If @error Then Return SetError(@error, @extended, 0x0)
    Return $shash
EndFunc   ;==>_WINAPI_HASHSTRING
Func _WINAPI_HIBYTE($ivalue)
    Return BitAND(BitShift($ivalue, 0x8), 0xff)
EndFunc   ;==>_WINAPI_HIBYTE
Func _WINAPI_HIDWORD($ivalue)
    Local $tint64 = DllStructCreate("int64")
    Local $tqword = DllStructCreate("dword;dword", DllStructGetPtr($tint64))
    DllStructSetData($tint64, 0x1, $ivalue)
    Return DllStructGetData($tqword, 0x2)
EndFunc   ;==>_WINAPI_HIDWORD
Func _WinAPI_HiWord($ilong)
    Return BitShift($ilong, 0x10)
EndFunc   ;==>_WINAPI_HIWORD
Func _WINAPI_INTTODWORD($ivalue)
    Local $tdata = DllStructCreate("dword")
    DllStructSetData($tdata, 0x1, $ivalue)
    Return DllStructGetData($tdata, 0x1)
EndFunc   ;==>_WINAPI_INTTODWORD
Func _WinAPI_IntToFloat($iint)
    Local $tint = DllStructCreate("int")
    Local $tfloat = DllStructCreate("float", DllStructGetPtr($tint))
    DllStructSetData($tint, 0x1, $iint)
    Return DllStructGetData($tfloat, 0x1)
EndFunc   ;==>_WINAPI_INTTOFLOAT
Func _WINAPI_LOBYTE($ivalue)
    Return BitAND($ivalue, 0xff)
EndFunc   ;==>_WINAPI_LOBYTE
Func _WINAPI_LODWORD($ivalue)
    Local $tint64 = DllStructCreate("int64")
    Local $tqword = DllStructCreate("dword;dword", DllStructGetPtr($tint64))
    DllStructSetData($tint64, 0x1, $ivalue)
    Return DllStructGetData($tqword, 0x1)
EndFunc   ;==>_WINAPI_LODWORD
Func _WinAPI_LoWord($ilong)
    Return BitAND($ilong, 0xffff)
EndFunc   ;==>_WINAPI_LOWORD
Func _WINAPI_LONGMID($ivalue, $istart, $icount)
    Return BitAND(BitShift($ivalue, $istart), BitOR(BitShift(BitShift(0x7fffffff, 0x20 - ($icount + 0x1)), 0x1), BitShift(0x1, -($icount + 0xffffffff))))
EndFunc   ;==>_WINAPI_LONGMID
Func _WinAPI_MAKELANGID($ilngidprimary, $ilngidsub)
    Return BitOR(BitShift($ilngidsub, +0xfffffff6), $ilngidprimary)
EndFunc   ;==>_WINAPI_MAKELANGID
Func _WinAPI_MAKELCID($ilngid, $isortid)
    Return BitOR(BitShift($isortid, +0xfffffff0), $ilngid)
EndFunc   ;==>_WINAPI_MAKELCID
Func _WinAPI_MakeLong($ilo, $ihi)
    Return BitOR(BitShift($ihi, +0xfffffff0), BitAND($ilo, 0xffff))
EndFunc   ;==>_WINAPI_MAKELONG
Func _WinAPI_MakeQWord($ilodword, $ihidword)
    Local $tint64 = DllStructCreate("uint64")
    Local $tdwords = DllStructCreate("dword;dword", DllStructGetPtr($tint64))
    DllStructSetData($tdwords, 0x1, $ilodword)
    DllStructSetData($tdwords, 0x2, $ihidword)
    Return DllStructGetData($tint64, 0x1)
EndFunc   ;==>_WINAPI_MAKEQWORD
Func _WINAPI_MAKEWORD($ilo, $ihi)
    Local $tword = DllStructCreate("ushort")
    Local $tbyte = DllStructCreate("byte;byte", DllStructGetPtr($tword))
    DllStructSetData($tbyte, 0x1, $ihi)
    DllStructSetData($tbyte, 0x2, $ilo)
    Return DllStructGetData($tword, 0x1)
EndFunc   ;==>_WINAPI_MAKEWORD
Func _WinAPI_MultiByteToWideChar($vtext, $icodepage = 0x0, $iflags = 0x0, $bretstring = False)
    Local $stexttype = ""
    If IsString($vtext) Then $stexttype = "str"
    If (IsDllStruct($vtext) Or IsPtr($vtext)) Then $stexttype = "struct*"
    If $stexttype = "" Then Return SetError(0x1, 0x0, 0x0)
    Local $acall = DllCall("kernel32.dll", "int", "MultiByteToWideChar", "uint", $icodepage, "dword", $iflags, $stexttype, $vtext, "int", +0xffffffff, "ptr", 0x0, "int", 0x0)
    If @error Or Not $acall[0x0] Then Return SetError(@error + 0xa, @extended, 0x0)
    Local $iout = $acall[0x0]
    Local $tout = DllStructCreate("wchar[" & $iout & "]")
    $acall = DllCall("kernel32.dll", "int", "MultiByteToWideChar", "uint", $icodepage, "dword", $iflags, $stexttype, $vtext, "int", +0xffffffff, "struct*", $tout, "int", $iout)
    If @error Or Not $acall[0x0] Then Return SetError(@error + 0x14, @extended, 0x0)
    If $bretstring Then Return DllStructGetData($tout, 0x1)
    Return $tout
EndFunc   ;==>_WINAPI_MULTIBYTETOWIDECHAR
Func _WinAPI_MultiByteToWideCharEx($stext, $ptext, $icodepage = 0x0, $iflags = 0x0)
    Local $acall = DllCall("kernel32.dll", "int", "MultiByteToWideChar", "uint", $icodepage, "dword", $iflags, "STR", $stext, "int", +0xffffffff, "struct*", $ptext, "int", (StringLen($stext) + 0x1) * 0x2)
    If @error Then Return SetError(@error, @extended, False)
    Return $acall[0x0]
EndFunc   ;==>_WINAPI_MULTIBYTETOWIDECHAREX
Func _WINAPI_OEMTOCHAR($sstr)
    Local $acall, $sretstr = "", $nlen = StringLen($sstr) + 0x1, $istart = 0x1
    While $istart < $nlen
        $acall = DllCall("user32.dll", "bool", "OemToCharA", "str", StringMid($sstr, $istart, 0x10000), "str", "")
        If @error Or Not $acall[0x0] Then Return SetError(@error + 0xa, @extended, "")
        $sretstr &= $acall[0x2]
        $istart += 0x10000
    WEnd
    Return $sretstr
EndFunc   ;==>_WINAPI_OEMTOCHAR
Func _WinAPI_PointFromRect(ByRef $trect, $bcenter = True)
    Local $ix1 = DllStructGetData($trect, "Left")
    Local $iy1 = DllStructGetData($trect, "Top")
    Local $ix2 = DllStructGetData($trect, "Right")
    Local $iy2 = DllStructGetData($trect, "Bottom")
    If $bcenter Then
        $ix1 = $ix1 + (($ix2 - $ix1) / 0x2)
        $iy1 = $iy1 + (($iy2 - $iy1) / 0x2)
    EndIf
    Local $tpoint = DllStructCreate($tagpoint)
    DllStructSetData($tpoint, "X", $ix1)
    DllStructSetData($tpoint, "Y", $iy1)
    Return $tpoint
EndFunc   ;==>_WINAPI_POINTFROMRECT
Func _WinAPI_PrimaryLangId($ilngid)
    Return BitAND($ilngid, 0x3ff)
EndFunc   ;==>_WINAPI_PRIMARYLANGID
Func _WinAPI_ScreenToClient($hwnd, ByRef $tpoint)
    Local $acall = DllCall("user32.dll", "bool", "ScreenToClient", "hwnd", $hwnd, "struct*", $tpoint)
    If @error Then Return SetError(@error, @extended, False)
    Return $acall[0x0]
EndFunc   ;==>_WINAPI_SCREENTOCLIENT
Func _WINAPI_SHORTTOWORD($ivalue)
    Return BitAND($ivalue, 0xffff)
EndFunc   ;==>_WINAPI_SHORTTOWORD
Func _WINAPI_STRFORMATBYTESIZE($isize)
    Local $acall = DllCall("shlwapi.dll", "ptr", "StrFormatByteSizeW", "int64", $isize, "wstr", "", "uint", 0x400)
    If @error Or Not $acall[0x0] Then Return SetError(@error + 0xa, @extended, "")
    Return $acall[0x2]
EndFunc   ;==>_WINAPI_STRFORMATBYTESIZE
Func _WINAPI_STRFORMATBYTESIZEEX($isize)
    Local $asymbol = DllCall("kernel32.dll", "int", "GetLocaleInfoW", "dword", 0x400, "dword", 0xf, "wstr", "", "int", 0x800)
    If @error Then Return SetError(@error + 0xa, @extended, "")
    Local $ssize = _WINAPI_STRFORMATBYTESIZE(0x0)
    If @error Then Return SetError(@error, @extended, "")
    Return StringReplace($ssize, "0", StringRegExpReplace(Number($isize), "(?<=\d)(?=(\d{3})+\z)", $asymbol[0x3]))
EndFunc   ;==>_WINAPI_STRFORMATBYTESIZEEX
Func _WINAPI_STRFORMATKBSIZE($isize)
    Local $acall = DllCall("shlwapi.dll", "ptr", "StrFormatKBSizeW", "int64", $isize, "wstr", "", "uint", 0x400)
    If @error Or Not $acall[0x0] Then Return SetError(@error + 0xa, @extended, "")
    Return $acall[0x2]
EndFunc   ;==>_WINAPI_STRFORMATKBSIZE
Func _WINAPI_STRFROMTIMEINTERVAL($itime, $idigits = 0x7)
    Local $acall = DllCall("shlwapi.dll", "int", "StrFromTimeIntervalW", "wstr", "", "uint", 0x400, "dword", $itime, "int", $idigits)
    If @error Or Not $acall[0x0] Then Return SetError(@error + 0xa, @extended, "")
    Return StringStripWS($acall[0x1], $str_stripleading + $str_striptrailing)
EndFunc   ;==>_WINAPI_STRFROMTIMEINTERVAL
Func _WinAPI_StringFromGUID($tguid)
    Local $acall = DllCall("ole32.dll", "int", "StringFromGUID2", "struct*", $tguid, "wstr", "", "int", 0x28)
    If @error Or Not $acall[0x0] Then Return SetError(@error, @extended, "")
    Return SetExtended($acall[0x0], $acall[0x2])
EndFunc   ;==>_WINAPI_STRINGFROMGUID
Func _WinAPI_SubLangId($ilngid)
    Return BitShift($ilngid, 0xa)
EndFunc   ;==>_WINAPI_SUBLANGID
Func _WINAPI_SWAPDWORD($ivalue)
    Local $tstruct1 = DllStructCreate("dword;dword")
    Local $tstruct2 = DllStructCreate("byte[4];byte[4]", DllStructGetPtr($tstruct1))
    DllStructSetData($tstruct1, 0x1, $ivalue)
    For $i = 0x1 To 0x4
        DllStructSetData($tstruct2, 0x2, DllStructGetData($tstruct2, 0x1, 0x5 - $i), $i)
    Next
    Return DllStructGetData($tstruct1, 0x2)
EndFunc   ;==>_WINAPI_SWAPDWORD
Func _WINAPI_SWAPQWORD($ivalue)
    Local $tstruct1 = DllStructCreate("int64;int64")
    Local $tstruct2 = DllStructCreate("byte[8];byte[8]", DllStructGetPtr($tstruct1))
    DllStructSetData($tstruct1, 0x1, $ivalue)
    For $i = 0x1 To 0x8
        DllStructSetData($tstruct2, 0x2, DllStructGetData($tstruct2, 0x1, 0x9 - $i), $i)
    Next
    Return DllStructGetData($tstruct1, 0x2)
EndFunc   ;==>_WINAPI_SWAPQWORD
Func _WINAPI_SWAPWORD($ivalue)
    Local $tstruct1 = DllStructCreate("word;word")
    Local $tstruct2 = DllStructCreate("byte[2];byte[2]", DllStructGetPtr($tstruct1))
    DllStructSetData($tstruct1, 0x1, $ivalue)
    For $i = 0x1 To 0x2
        DllStructSetData($tstruct2, 0x2, DllStructGetData($tstruct2, 0x1, 0x3 - $i), $i)
    Next
    Return DllStructGetData($tstruct1, 0x2)
EndFunc   ;==>_WINAPI_SWAPWORD
Func _WinAPI_WideCharToMultiByte($vunicode, $icodepage = 0x0, $bretnostruct = True, $bretbinary = False)
    Local $sunicodetype = "wstr"
    If Not IsString($vunicode) Then $sunicodetype = "struct*"
    Local $acall = DllCall("kernel32.dll", "int", "WideCharToMultiByte", "uint", $icodepage, "dword", 0x0, $sunicodetype, $vunicode, "int", +0xffffffff, "ptr", 0x0, "int", 0x0, "ptr", 0x0, "ptr", 0x0)
    If @error Or Not $acall[0x0] Then Return SetError(@error + 0x14, @extended, "")
    Local $tmultibyte = DllStructCreate((($bretbinary) ? ("byte") : ("char")) & "[" & $acall[0x0] & "]")
    $acall = DllCall("kernel32.dll", "int", "WideCharToMultiByte", "uint", $icodepage, "dword", 0x0, $sunicodetype, $vunicode, "int", +0xffffffff, "struct*", $tmultibyte, "int", $acall[0x0], "ptr", 0x0, "ptr", 0x0)
    If @error Or Not $acall[0x0] Then Return SetError(@error + 0xa, @extended, "")
    If $bretnostruct Then Return DllStructGetData($tmultibyte, 0x1)
    Return $tmultibyte
EndFunc   ;==>_WINAPI_WIDECHARTOMULTIBYTE
Func _WINAPI_WORDTOSHORT($ivalue)
    If BitAND($ivalue, 0x8000) Then
        Return BitOR($ivalue, 0xffff8000)
    EndIf
    Return BitAND($ivalue, 0x7fff)
EndFunc   ;==>_WINAPI_WORDTOSHORT
#endregion Public Functions
Global Const $__dlg_wm_user = 0x400
Global Const $bif_browsefilejunctions = 0x10000
Global Const $bif_browseforcomputer = 0x1000
Global Const $bif_browseforprinter = 0x2000
Global Const $bif_browseincludefiles = 0x4000
Global Const $bif_browseincludeurls = 0x80
Global Const $bif_dontgobelowdomain = 0x2
Global Const $bif_editbox = 0x10
Global Const $bif_newdialogstyle = 0x40
Global Const $bif_nonewfolderbutton = 0x200
Global Const $bif_notranslatetargets = 0x400
Global Const $bif_returnfsancestors = 0x8
Global Const $bif_returnonlyfsdirs = 0x1
Global Const $bif_shareable = 0x8000
Global Const $bif_statustext = 0x4
Global Const $bif_usenewui = BitOR($bif_editbox, $bif_newdialogstyle)
Global Const $bif_uahint = 0x100
Global Const $bif_validate = 0x20
Global Const $bffm_initialized = 0x1
Global Const $bffm_iunknown = 0x5
Global Const $bffm_selchanged = 0x2
Global Const $bffm_validatefailed = 0x4
Global Const $bffm_setstatustexta = $__dlg_wm_user + 0x64
Global Const $bffm_enableok = $__dlg_wm_user + 0x65
Global Const $bffm_setselectiona = $__dlg_wm_user + 0x66
Global Const $bffm_setselectionw = $__dlg_wm_user + 0x67
Global Const $bffm_setstatustextw = $__dlg_wm_user + 0x68
Global Const $bffm_setoktext = $__dlg_wm_user + 0x69
Global Const $bffm_setexpanded = $__dlg_wm_user + 0x6a
Global Const $cderr_dialogfailure = 0xffff
Global Const $cderr_findresfailure = 0x6
Global Const $cderr_initialization = 0x2
Global Const $cderr_loadresfailure = 0x7
Global Const $cderr_loadstrfailure = 0x5
Global Const $cderr_lockresfailure = 0x8
Global Const $cderr_memallocfailure = 0x9
Global Const $cderr_memlockfailure = 0xa
Global Const $cderr_nohinstance = 0x4
Global Const $cderr_nohook = 0xb
Global Const $cderr_notemplate = 0x3
Global Const $cderr_registermsgfail = 0xc
Global Const $cderr_structsize = 0x1
Global Const $pderr_createicfailure = 0x100a
Global Const $pderr_defaultdifferent = 0x100c
Global Const $pderr_dndmmismatch = 0x1009
Global Const $pderr_getdevmodefail = 0x1005
Global Const $pderr_initfailure = 0x1006
Global Const $pderr_loaddrvfailure = 0x1004
Global Const $pderr_nodefaultprn = 0x1008
Global Const $pderr_nodevices = 0x1007
Global Const $pderr_parsefailure = 0x1002
Global Const $pderr_printernotfound = 0x100b
Global Const $pderr_retdeffailure = 0x1003
Global Const $pderr_setupfailure = 0x1001
Global Const $cferr_maxlessthanmin = 0x2002
Global Const $cferr_nofonts = 0x2001
Global Const $fnerr_buffertoosmall = 0x3003
Global Const $fnerr_invalidfilename = 0x3002
Global Const $fnerr_subclassfailure = 0x3001
Global Const $frerr_bufferlengthzero = 0x4001
Global Const $fr_dialogterm = 0x40
Global Const $fr_down = 0x1
Global Const $fr_enablehook = 0x100
Global Const $fr_enabletemplate = 0x200
Global Const $fr_enabletemplatehandle = 0x2000
Global Const $fr_findnext = 0x8
Global Const $fr_hideupdown = 0x4000
Global Const $fr_hidematchcase = 0x8000
Global Const $fr_hidewholeword = 0x10000
Global Const $fr_matchcase = 0x4
Global Const $fr_nomatchcase = 0x800
Global Const $fr_noupdown = 0x400
Global Const $fr_nowholeword = 0x1000
Global Const $fr_replace = 0x10
Global Const $fr_replaceall = 0x20
Global Const $fr_showhelp = 0x80
Global Const $fr_wholeword = 0x2
Global Const $shfmt_id_default = 0xffff
Global Const $shfmt_opt_full = 0x0
Global Const $shfmt_opt_quickformat = 0x1
Global Const $shfmt_opt_sysonly = 0x2
Global Const $shfmt_error = +0xffffffff
Global Const $shfmt_cancel = +0xfffffffe
Global Const $shfmt_noformat = +0xfffffffd
Global Const $cdm_first = $__dlg_wm_user + 0x64
Global Const $cdm_getspec = $cdm_first
Global Const $cdm_getfilepath = $cdm_first + 0x1
Global Const $cdm_getfolderpath = $cdm_first + 0x2
Global Const $cdm_getfolderidlist = $cdm_first + 0x3
Global Const $cdm_setcontroltext = $cdm_first + 0x4
Global Const $cdm_hidecontrol = $cdm_first + 0x5
Global Const $cdm_setdefext = $cdm_first + 0x6
Global Const $cdm_last = $__dlg_wm_user + 0xc8
Global Const $cdn_first = +0xfffffda7
Global Const $cdn_initdone = $cdn_first
Global Const $cdn_selchange = $cdn_first + 0xffffffff
Global Const $cdn_folderchange = $cdn_first + 0xfffffffe
Global Const $cdn_shareviolation = $cdn_first + 0xfffffffd
Global Const $cdn_help = $cdn_first + 0xfffffffc
Global Const $cdn_fileok = $cdn_first + 0xfffffffb
Global Const $cdn_typechange = $cdn_first + 0xfffffffa
Global Const $cdn_includeitem = $cdn_first + 0xfffffff9
Global Const $cdn_last = +0xfffffd45
Global Const $psd_defaultminmargins = 0x0
Global Const $psd_disablemargins = 0x10
Global Const $psd_disableorientation = 0x100
Global Const $psd_disablepagepainting = 0x80000
Global Const $psd_disablepaper = 0x200
Global Const $psd_disableprinter = 0x20
Global Const $psd_enablepagepainthook = 0x40000
Global Const $psd_enablepagesetuphook = 0x2000
Global Const $psd_enablepagesetuptemplate = 0x8000
Global Const $psd_enablepagesetuptemplatehandle = 0x20000
Global Const $psd_inhundredthsofmillimeters = 0x8
Global Const $psd_inthousandthsofinches = 0x4
Global Const $psd_margins = 0x2
Global Const $psd_minmargins = 0x1
Global Const $psd_nonetworkbutton = 0x200000
Global Const $psd_nowarning = 0x80
Global Const $psd_returndefault = 0x400
Global Const $psd_showhelp = 0x800
Global Const $wm_psd_pagesetupdlg = $__dlg_wm_user
Global Const $wm_psd_fullpagerect = $__dlg_wm_user + 0x1
Global Const $wm_psd_minmarginrect = $__dlg_wm_user + 0x2
Global Const $wm_psd_marginrect = $__dlg_wm_user + 0x3
Global Const $wm_psd_greektextrect = $__dlg_wm_user + 0x4
Global Const $wm_psd_envstamprect = $__dlg_wm_user + 0x5
Global Const $wm_psd_yafullpagerect = $__dlg_wm_user + 0x6
Global Const $pd_allpages = 0x0
Global Const $pd_collate = 0x10
Global Const $pd_currentpage = 0x400000
Global Const $pd_disableprinttofile = 0x80000
Global Const $pd_enableprinthook = 0x1000
Global Const $pd_enableprinttemplate = 0x4000
Global Const $pd_enableprinttemplatehandle = 0x10000
Global Const $pd_enablesetuphook = 0x2000
Global Const $pd_enablesetuptemplate = 0x8000
Global Const $pd_enablesetuptemplatehandle = 0x20000
Global Const $pd_exclusionflags = 0x1000000
Global Const $pd_hideprinttofile = 0x100000
Global Const $pd_nocurrentpage = 0x800000
Global Const $pd_nonetworkbutton = 0x200000
Global Const $pd_nopagenums = 0x8
Global Const $pd_noselection = 0x4
Global Const $pd_nowarning = 0x80
Global Const $pd_pagenums = 0x2
Global Const $pd_printsetup = 0x40
Global Const $pd_printtofile = 0x20
Global Const $pd_returndc = 0x100
Global Const $pd_returndefault = 0x400
Global Const $pd_returnic = 0x200
Global Const $pd_selection = 0x1
Global Const $pd_showhelp = 0x800
Global Const $pd_usedevmodecopies = 0x40000
Global Const $pd_usedevmodecopiesandcollate = $pd_usedevmodecopies
Global Const $pd_uselargetemplate = 0x10000000
Global Const $pd_result_apply = 0x2
Global Const $pd_result_cancel = 0x0
Global Const $pd_result_print = 0x1
Global Const $ewx_logoff = 0x0
Global Const $ewx_poweroff = 0x8
Global Const $ewx_reboot = 0x2
Global Const $ewx_shutdown = 0x1
Global Const $ewx_force = 0x4
Global Const $ewx_forceifhung = 0x10
Global Const $oaif_allow_registration = 0x1
Global Const $oaif_register_ext = 0x2
Global Const $oaif_exec = 0x4
Global Const $oaif_force_registration = 0x8
Global Const $oaif_hide_registration = 0x20
Global Const $oaif_url_protocol = 0x40
Global Const $credui_flags_always_show_ui = 0x80
Global Const $credui_flags_complete_username = 0x800
Global Const $credui_flags_do_not_persist = 0x2
Global Const $credui_flags_exclude_certificates = 0x8
Global Const $credui_flags_expect_confirmation = 0x20000
Global Const $credui_flags_generic_credentials = 0x40000
Global Const $credui_flags_incorrect_password = 0x1
Global Const $credui_flags_keep_username = 0x100000
Global Const $credui_flags_password_only_ok = 0x200
Global Const $credui_flags_persist = 0x1000
Global Const $credui_flags_request_administrator = 0x4
Global Const $credui_flags_require_certificate = 0x10
Global Const $credui_flags_require_smartcard = 0x100
Global Const $credui_flags_server_credential = 0x4000
Global Const $credui_flags_show_save_check_box = 0x40
Global Const $credui_flags_username_target_credentials = 0x80000
Global Const $credui_flags_validate_username = 0x400
Global Const $creduiwin_authpackage_only = 0x10
Global Const $creduiwin_checkbox = 0x2
Global Const $creduiwin_enumerate_admins = 0x100
Global Const $creduiwin_enumerate_current_user = 0x200
Global Const $creduiwin_generic = 0x1
Global Const $creduiwin_in_cred_only = 0x20
Global Const $creduiwin_secure_prompt = 0x1000
Global Const $creduiwin_pack_32_wow = 0x10000000
Global Const $creduiwin_preprompting = 0x2000
Global Const $coinit_apartmentthreaded = 0x2
Global Const $coinit_disable_ole1dde = 0x4
Global Const $coinit_multithreaded = 0x0
Global Const $coinit_speed_over_memory = 0x8
#region Global Variables and Constants
Global Const $__tagwinapicom_guid = "struct;ulong Data1;ushort Data2;ushort Data3;byte Data4[8];endstruct"
#endregion Global Variables and Constants
#region Functions list
#endregion Functions list
#region Public Functions
Func _WINAPI_CLSIDFROMPROGID($sprogid)
    Local $tguid = DllStructCreate($__tagwinapicom_guid)
    Local $acall = DllCall("ole32.dll", "long", "CLSIDFromProgID", "wstr", $sprogid, "struct*", $tguid)
    If @error Then Return SetError(@error, @extended, "")
    If $acall[0x0] Then Return SetError(0xa, $acall[0x0], "")
    $acall = DllCall("ole32.dll", "int", "StringFromGUID2", "struct*", $tguid, "wstr", "", "int", 0x27)
    If @error Or Not $acall[0x0] Then Return SetError(@error + 0x14, @extended, "")
    Return $acall[0x2]
EndFunc   ;==>_WINAPI_CLSIDFROMPROGID
Func _WINAPI_COINITIALIZE($iflags = 0x0)
    Local $acall = DllCall("ole32.dll", "long", "CoInitializeEx", "ptr", 0x0, "dword", $iflags)
    If @error Then Return SetError(@error, @extended, 0x0)
    If $acall[0x0] Then Return SetError(0xa, $acall[0x0], 0x0)
    Return 0x1
EndFunc   ;==>_WINAPI_COINITIALIZE
Func _WINAPI_COTASKMEMALLOC($isize)
    Local $acall = DllCall("ole32.dll", "ptr", "CoTaskMemAlloc", "uint_ptr", $isize)
    If @error Then Return SetError(@error, @extended, 0x0)
    Return $acall[0x0]
EndFunc   ;==>_WINAPI_COTASKMEMALLOC
Func _WINAPI_COTASKMEMFREE($pmemory)
    DllCall("ole32.dll", "none", "CoTaskMemFree", "ptr", $pmemory)
    If @error Then Return SetError(@error, @extended, 0x0)
    Return 0x1
EndFunc   ;==>_WINAPI_COTASKMEMFREE
Func _WINAPI_COTASKMEMREALLOC($pmemory, $isize)
    Local $acall = DllCall("ole32.dll", "ptr", "CoTaskMemRealloc", "ptr", $pmemory, "ulong_ptr", $isize)
    If @error Then Return SetError(@error, @extended, 0x0)
    Return $acall[0x0]
EndFunc   ;==>_WINAPI_COTASKMEMREALLOC
Func _WINAPI_COUNINITIALIZE()
    DllCall("ole32.dll", "none", "CoUninitialize")
    If @error Then Return SetError(@error, @extended, 0x0)
    Return 0x1
EndFunc   ;==>_WINAPI_COUNINITIALIZE
Func _WINAPI_CREATEGUID()
    Local $tguid = DllStructCreate($__tagwinapicom_guid)
    Local $acall = DllCall("ole32.dll", "long", "CoCreateGuid", "struct*", $tguid)
    If @error Then Return SetError(@error, @extended, "")
    If $acall[0x0] Then Return SetError(0xa, $acall[0x0], "")
    $acall = DllCall("ole32.dll", "int", "StringFromGUID2", "struct*", $tguid, "wstr", "", "int", 0x10000)
    If @error Or Not $acall[0x0] Then Return SetError(@error + 0x14, @extended, "")
    Return $acall[0x2]
EndFunc   ;==>_WINAPI_CREATEGUID
Func _WINAPI_CREATESTREAMONHGLOBAL($hglobal = 0x0, $bdeleteonrelease = True)
    Local $acall = DllCall("ole32.dll", "long", "CreateStreamOnHGlobal", "handle", $hglobal, "bool", $bdeleteonrelease, "ptr*", 0x0)
    If @error Then Return SetError(@error, @extended, 0x0)
    If $acall[0x0] Then Return SetError(0xa, $acall[0x0], 0x0)
    Return $acall[0x3]
EndFunc   ;==>_WINAPI_CREATESTREAMONHGLOBAL
Func _WINAPI_GETHGLOBALFROMSTREAM($pstream)
    Local $acall = DllCall("ole32.dll", "uint", "GetHGlobalFromStream", "ptr", $pstream, "ptr*", 0x0)
    If @error Then Return SetError(@error, @extended, 0x0)
    If $acall[0x0] Then Return SetError(0xa, $acall[0x0], 0x0)
    Return $acall[0x2]
EndFunc   ;==>_WINAPI_GETHGLOBALFROMSTREAM
Func _WINAPI_PROGIDFROMCLSID($sclsid)
    Local $tguid = DllStructCreate($__tagwinapicom_guid)
    Local $acall = DllCall("ole32.dll", "uint", "CLSIDFromString", "wstr", $sclsid, "struct*", $tguid)
    If @error Or $acall[0x0] Then Return SetError(@error + 0x14, @extended, "")
    $acall = DllCall("ole32.dll", "uint", "ProgIDFromCLSID", "struct*", $tguid, "ptr*", 0x0)
    If @error Then Return SetError(@error, @extended, "")
    If $acall[0x0] Then Return SetError(0xa, $acall[0x0], "")
    Local $sid = _WINAPI_GETSTRING($acall[0x2])
    _WINAPI_COTASKMEMFREE($acall[0x2])
    Return $sid
EndFunc   ;==>_WINAPI_PROGIDFROMCLSID
Func _WINAPI_RELEASESTREAM($pstream)
    Local $acall = DllCall("oleaut32.dll", "long", "DispCallFunc", "ptr", $pstream, "ulong_ptr", 0x8 * (0x1 + @AutoItX64), "uint", 0x4, "ushort", 0x17, "uint", 0x0, "ptr", 0x0, "ptr", 0x0, "str", "")
    If @error Then Return SetError(@error, @extended, 0x0)
    If $acall[0x0] Then Return SetError(0xa, $acall[0x0], 0x0)
    Return 0x1
EndFunc   ;==>_WINAPI_RELEASESTREAM
#endregion Public Functions
#region Global Variables and Constants
Global $__g_hheap = 0x0
#endregion Global Variables and Constants
#region Functions list
#endregion Functions list
#region Public Functions
Func _WINAPI_CREATEBUFFER($ilength, $pbuffer = 0x0, $babort = True)
    $pbuffer = __HEAPREALLOC($pbuffer, $ilength, 0x0, $babort)
    If @error Then Return SetError(@error, @extended, 0x0)
    Return $pbuffer
EndFunc   ;==>_WINAPI_CREATEBUFFER
Func _WINAPI_CREATEBUFFERFROMSTRUCT($tstruct, $pbuffer = 0x0, $babort = True)
    If Not IsDllStruct($tstruct) Then Return SetError(0x1, 0x0, 0x0)
    $pbuffer = __HEAPREALLOC($pbuffer, DllStructGetSize($tstruct), 0x0, $babort)
    If @error Then Return SetError(@error + 0x64, @extended, 0x0)
    _WINAPI_MOVEMEMORY($pbuffer, $tstruct, DllStructGetSize($tstruct))
    Return $pbuffer
EndFunc   ;==>_WINAPI_CREATEBUFFERFROMSTRUCT
Func _WINAPI_CREATESTRING($sstring, $pstring = 0x0, $ilength = +0xffffffff, $bunicode = True, $babort = True)
    $ilength = Number($ilength)
    If $ilength >= 0x0 Then
        $sstring = StringLeft($sstring, $ilength)
    Else
        $ilength = StringLen($sstring)
    EndIf
    Local $isize = $ilength + 0x1
    If $bunicode Then
        $isize *= 0x2
    EndIf
    $pstring = __HEAPREALLOC($pstring, $isize, 0x0, $babort)
    If @error Then Return SetError(@error, @extended, 0x0)
    DllStructSetData(DllStructCreate(($bunicode ? "wchar" : "char") & "[" & ($ilength + 0x1) & "]", $pstring), 0x1, $sstring)
    Return SetExtended($ilength, $pstring)
EndFunc   ;==>_WINAPI_CREATESTRING
Func _WINAPI_EQUALMEMORY($psource1, $psource2, $ilength)
    If _WINAPI_ISBADREADPTR($psource1, $ilength) Then Return SetError(0xb, @extended, 0x0)
    If _WINAPI_ISBADREADPTR($psource2, $ilength) Then Return SetError(0xc, @extended, 0x0)
    Local $acall = DllCall("ntdll.dll", "ulong_ptr", "RtlCompareMemory", "struct*", $psource1, "struct*", $psource2, "ulong_ptr", $ilength)
    If @error Then Return SetError(@error, @extended, 0x0)
    Return Number($acall[0x0] = $ilength)
EndFunc   ;==>_WINAPI_EQUALMEMORY
Func _WINAPI_FILLMEMORY($pmemory, $ilength, $ivalue = 0x0)
    If _WINAPI_ISBADWRITEPTR($pmemory, $ilength) Then Return SetError(0xb, @extended, 0x0)
    DllCall("ntdll.dll", "none", "RtlFillMemory", "struct*", $pmemory, "ulong_ptr", $ilength, "byte", $ivalue)
    If @error Then Return SetError(@error, @extended, 0x0)
    Return 0x1
EndFunc   ;==>_WINAPI_FILLMEMORY
Func _WINAPI_FREEMEMORY($pmemory)
    If Not __HEAPFREE($pmemory, 0x1) Then Return SetError(@error, @extended, 0x0)
    Return 0x1
EndFunc   ;==>_WINAPI_FREEMEMORY
Func _WINAPI_GETMEMORYSIZE($pmemory)
    Local $iresult = __HEAPSIZE($pmemory, 0x1)
    If @error Then Return SetError(@error, @extended, 0x0)
    Return $iresult
EndFunc   ;==>_WINAPI_GETMEMORYSIZE
Func _WinAPI_GlobalMemoryStatus()
    Local Const $tagmemorystatusex = "dword Length;dword MemoryLoad;" & "uint64 TotalPhys;uint64 AvailPhys;uint64 TotalPageFile;uint64 AvailPageFile;" & "uint64 TotalVirtual;uint64 AvailVirtual;uint64 AvailExtendedVirtual"
    Local $tmem = DllStructCreate($tagmemorystatusex)
    DllStructSetData($tmem, 0x1, DllStructGetSize($tmem))
    Local $acall = DllCall("kernel32.dll", "bool", "GlobalMemoryStatusEx", "struct*", $tmem)
    If @error Or Not $acall[0x0] Then Return SetError(@error + 0xa, @extended, 0x0)
    Local $amem[0x7]
    $amem[0x0] = DllStructGetData($tmem, 0x2)
    $amem[0x1] = DllStructGetData($tmem, 0x3)
    $amem[0x2] = DllStructGetData($tmem, 0x4)
    $amem[0x3] = DllStructGetData($tmem, 0x5)
    $amem[0x4] = DllStructGetData($tmem, 0x6)
    $amem[0x5] = DllStructGetData($tmem, 0x7)
    $amem[0x6] = DllStructGetData($tmem, 0x8)
    Return $amem
EndFunc   ;==>_WINAPI_GLOBALMEMORYSTATUS
Func _WINAPI_ISBADCODEPTR($paddress)
    Local $acall = DllCall("kernel32.dll", "bool", "IsBadCodePtr", "struct*", $paddress)
    If @error Then Return SetError(@error, @extended, False)
    Return $acall[0x0]
EndFunc   ;==>_WINAPI_ISBADCODEPTR
Func _WINAPI_ISBADREADPTR($paddress, $ilength)
    Local $acall = DllCall("kernel32.dll", "bool", "IsBadReadPtr", "struct*", $paddress, "uint_ptr", $ilength)
    If @error Then Return SetError(@error, @extended, False)
    Return $acall[0x0]
EndFunc   ;==>_WINAPI_ISBADREADPTR
Func _WINAPI_ISBADSTRINGPTR($paddress, $ilength)
    Local $acall = DllCall("kernel32.dll", "bool", "IsBadStringPtr", "struct*", $paddress, "uint_ptr", $ilength)
    If @error Then Return SetError(@error, @extended, False)
    Return $acall[0x0]
EndFunc   ;==>_WINAPI_ISBADSTRINGPTR
Func _WINAPI_ISBADWRITEPTR($paddress, $ilength)
    Local $acall = DllCall("kernel32.dll", "bool", "IsBadWritePtr", "struct*", $paddress, "uint_ptr", $ilength)
    If @error Then Return SetError(@error, @extended, False)
    Return $acall[0x0]
EndFunc   ;==>_WINAPI_ISBADWRITEPTR
Func _WINAPI_ISMEMORY($pmemory)
    Local $bresult = __HEAPVALIDATE($pmemory)
    Return SetError(@error, @extended, $bresult)
EndFunc   ;==>_WINAPI_ISMEMORY
Func _WinAPI_LocalFree($hmemory)
    Local $acall = DllCall("kernel32.dll", "handle", "LocalFree", "handle", $hmemory)
    If @error Then Return SetError(@error, @extended, False)
    Return $acall[0x0]
EndFunc   ;==>_WINAPI_LOCALFREE
Func _WINAPI_MOVEMEMORY($pdestination, $psource, $ilength)
    If _WINAPI_ISBADREADPTR($psource, $ilength) Then Return SetError(0xa, @extended, 0x0)
    If _WINAPI_ISBADWRITEPTR($pdestination, $ilength) Then Return SetError(0xb, @extended, 0x0)
    DllCall("ntdll.dll", "none", "RtlMoveMemory", "struct*", $pdestination, "struct*", $psource, "ulong_ptr", $ilength)
    If @error Then Return SetError(@error, @extended, 0x0)
    Return 0x1
EndFunc   ;==>_WINAPI_MOVEMEMORY
Func _WinAPI_ReadProcessMemory($hprocess, $pbaseaddress, $pbuffer, $isize, ByRef $iread)
    Local $acall = DllCall("kernel32.dll", "bool", "ReadProcessMemory", "handle", $hprocess, "ptr", $pbaseaddress, "struct*", $pbuffer, "ulong_ptr", $isize, "ulong_ptr*", 0x0)
    If @error Then Return SetError(@error, @extended, False)
    $iread = $acall[0x5]
    Return $acall[0x0]
EndFunc   ;==>_WINAPI_READPROCESSMEMORY
Func _WinAPI_WriteProcessMemory($hprocess, $pbaseaddress, $pbuffer, $isize, ByRef $iwritten, $sbuffertype = "ptr")
    Local $acall = DllCall("kernel32.dll", "bool", "WriteProcessMemory", "handle", $hprocess, "ptr", $pbaseaddress, $sbuffertype, $pbuffer, "ulong_ptr", $isize, "ulong_ptr*", 0x0)
    If @error Then Return SetError(@error, @extended, False)
    $iwritten = $acall[0x5]
    Return $acall[0x0]
EndFunc   ;==>_WINAPI_WRITEPROCESSMEMORY
Func _WINAPI_ZEROMEMORY($pmemory, $ilength)
    If _WINAPI_ISBADWRITEPTR($pmemory, $ilength) Then Return SetError(0xb, @extended, 0x0)
    DllCall("ntdll.dll", "none", "RtlZeroMemory", "struct*", $pmemory, "ulong_ptr", $ilength)
    If @error Then Return SetError(@error, @extended, 0x0)
    Return 0x1
EndFunc   ;==>_WINAPI_ZEROMEMORY
#endregion Public Functions
#region Internal Functions
Func __HEAPALLOC($isize, $babort = False)
    Local $acall
    If Not $__g_hheap Then
        $acall = DllCall("kernel32.dll", "handle", "HeapCreate", "dword", 0x0, "ulong_ptr", 0x0, "ulong_ptr", 0x0)
        If @error Or Not $acall[0x0] Then __FATALEXIT(0x1, "Error allocating memory.")
        $__g_hheap = $acall[0x0]
    EndIf
    $acall = DllCall("kernel32.dll", "ptr", "HeapAlloc", "handle", $__g_hheap, "dword", 0x8, "ulong_ptr", $isize)
    If @error Or Not $acall[0x0] Then
        If $babort Then __FATALEXIT(0x1, "Error allocating memory.")
        Return SetError(@error + 0x1e, @extended, 0x0)
    EndIf
    Return $acall[0x0]
EndFunc   ;==>__HEAPALLOC
Func __HEAPFREE(ByRef $pmemory, $bcheck = False, $icurerr = @error, $icurext = @extended)
    If $bcheck And (Not __HEAPVALIDATE($pmemory)) Then Return SetError(@error, @extended, 0x0)
    Local $acall = DllCall("kernel32.dll", "int", "HeapFree", "handle", $__g_hheap, "dword", 0x0, "ptr", $pmemory)
    If @error Or Not $acall[0x0] Then Return SetError(@error + 0x28, @extended, 0x0)
    $pmemory = 0x0
    Return SetError($icurerr, $icurext, 0x1)
EndFunc   ;==>__HEAPFREE
Func __HEAPREALLOC($pmemory, $isize, $bamount = False, $babort = False)
    Local $pret
    If __HEAPVALIDATE($pmemory) Then
        If $bamount And (__HEAPSIZE($pmemory) >= $isize) Then Return SetExtended(0x1, Ptr($pmemory))
        Local $acall = DllCall("kernel32.dll", "ptr", "HeapReAlloc", "handle", $__g_hheap, "dword", 0x8, "ptr", $pmemory, "ulong_ptr", $isize)
        If @error Or Not $acall[0x0] Then
            If $babort Then __FATALEXIT(0x1, "Error allocating memory.")
            Return SetError(@error + 0x14, @extended, Ptr($pmemory))
        EndIf
        $pret = $acall[0x0]
    Else
        $pret = __HEAPALLOC($isize, $babort)
        If @error Then Return SetError(@error, @extended, 0x0)
    EndIf
    Return $pret
EndFunc   ;==>__HEAPREALLOC
Func __HEAPSIZE($pmemory, $bcheck = False)
    If $bcheck And (Not __HEAPVALIDATE($pmemory)) Then Return SetError(@error, @extended, 0x0)
    Local $acall = DllCall("kernel32.dll", "ulong_ptr", "HeapSize", "handle", $__g_hheap, "dword", 0x0, "ptr", $pmemory)
    If @error Or ($acall[0x0] = Ptr(+0xffffffff)) Then Return SetError(@error + 0x32, @extended, 0x0)
    Return $acall[0x0]
EndFunc   ;==>__HEAPSIZE
Func __HEAPVALIDATE($pmemory)
    If (Not $__g_hheap) Or (Not Ptr($pmemory)) Then Return SetError(0x9, 0x0, False)
    Local $acall = DllCall("kernel32.dll", "int", "HeapValidate", "handle", $__g_hheap, "dword", 0x0, "ptr", $pmemory)
    If @error Then Return SetError(@error, @extended, False)
    Return $acall[0x0]
EndFunc   ;==>__HEAPVALIDATE
#endregion Internal Functions
Global Const $snd_application = 0x80
Global Const $snd_alias = 0x10000
Global Const $snd_alias_id = 0x110000
Global Const $snd_async = 0x1
Global Const $snd_filename = 0x20000
Global Const $snd_loop = 0x8
Global Const $snd_memory = 0x4
Global Const $snd_nodefault = 0x2
Global Const $snd_nostop = 0x10
Global Const $snd_nowait = 0x2000
Global Const $snd_purge = 0x40
Global Const $snd_resource = 0x40004
Global Const $snd_sentry = 0x80000
Global Const $snd_sync = 0x0
Global Const $snd_system = 0x200000
Global Const $snd_system_nostop = 0x200010
Global Const $snd_alias_systemasterisk = "SystemAsterisk"
Global Const $snd_alias_systemdefault = "SystemDefault"
Global Const $snd_alias_systemexclamation = "SystemExclamation"
Global Const $snd_alias_systemexit = "SystemExit"
Global Const $snd_alias_systemhand = "SystemHand"
Global Const $snd_alias_systemquestion = "SystemQuestion"
Global Const $snd_alias_systemstart = "SystemStart"
Global Const $snd_alias_systemwelcome = "SystemWelcome"
#region Global Variables and Constants
#endregion Global Variables and Constants
#region Functions list
#endregion Functions list
#region Public Functions
Func _WINAPI_ARRAYTOSTRUCT(Const ByRef $adata, $istart = 0x0, $iend = +0xffffffff)
    If __CHECKERRORARRAYBOUNDS($adata, $istart, $iend) Then Return SetError(@error + 0xa, @extended, 0x0)
    Local $tagstruct = ""
    For $i = $istart To $iend
        $tagstruct &= "wchar[" & (StringLen($adata[$i]) + 0x1) & "];"
    Next
    Local $tdata = DllStructCreate($tagstruct & "wchar[1]")
    Local $icount = 0x1
    For $i = $istart To $iend
        DllStructSetData($tdata, $icount, $adata[$i])
        $icount += 0x1
    Next
    DllStructSetData($tdata, $icount, ChrW(0x0))
    Return $tdata
EndFunc   ;==>_WINAPI_ARRAYTOSTRUCT
Func _WINAPI_CREATEMARGINS($ileftwidth, $irightwidth, $itopheight, $ibottomheight)
    Local $tmargins = DllStructCreate($tagmargins)
    DllStructSetData($tmargins, 0x1, $ileftwidth)
    DllStructSetData($tmargins, 0x2, $irightwidth)
    DllStructSetData($tmargins, 0x3, $itopheight)
    DllStructSetData($tmargins, 0x4, $ibottomheight)
    Return $tmargins
EndFunc   ;==>_WINAPI_CREATEMARGINS
Func _WINAPI_CREATEPOINT($ix, $iy)
    Local $tpoint = DllStructCreate($tagpoint)
    DllStructSetData($tpoint, 0x1, $ix)
    DllStructSetData($tpoint, 0x2, $iy)
    Return $tpoint
EndFunc   ;==>_WINAPI_CREATEPOINT
Func _WINAPI_CREATERECT($ileft, $itop, $iright, $ibottom)
    Local $trect = DllStructCreate($tagrect)
    DllStructSetData($trect, 0x1, $ileft)
    DllStructSetData($trect, 0x2, $itop)
    DllStructSetData($trect, 0x3, $iright)
    DllStructSetData($trect, 0x4, $ibottom)
    Return $trect
EndFunc   ;==>_WINAPI_CREATERECT
Func _WINAPI_CREATERECTEX($ix, $iy, $iwidth, $iheight)
    Local $trect = DllStructCreate($tagrect)
    DllStructSetData($trect, 0x1, $ix)
    DllStructSetData($trect, 0x2, $iy)
    DllStructSetData($trect, 0x3, $ix + $iwidth)
    DllStructSetData($trect, 0x4, $iy + $iheight)
    Return $trect
EndFunc   ;==>_WINAPI_CREATERECTEX
Func _WINAPI_CREATESIZE($iwidth, $iheight)
    Local $tsize = DllStructCreate($tagsize)
    DllStructSetData($tsize, 0x1, $iwidth)
    DllStructSetData($tsize, 0x2, $iheight)
    Return $tsize
EndFunc   ;==>_WINAPI_CREATESIZE
Func _WINAPI_COPYSTRUCT($tstruct, $sstruct = "")
    Local $isize = DllStructGetSize($tstruct)
    If Not $isize Then Return SetError(0x1, 0x0, 0x0)
    Local $tresult
    If Not StringStripWS($sstruct, $str_stripleading + $str_striptrailing + $str_stripspaces) Then
        $tresult = DllStructCreate("byte[" & $isize & "]")
    Else
        $tresult = DllStructCreate($sstruct)
    EndIf
    If DllStructGetSize($tresult) < $isize Then Return SetError(0x2, 0x0, 0x0)
    _WINAPI_MOVEMEMORY($tresult, $tstruct, $isize)
    Return $tresult
EndFunc   ;==>_WINAPI_COPYSTRUCT
Func _WINAPI_GETEXTENDED()
    Return $__g_vext
EndFunc   ;==>_WINAPI_GETEXTENDED
Func _WinAPI_GetMousePos($btoclient = False, $hwnd = 0x0)
    Local $imode = Opt("MouseCoordMode", 0x1)
    Local $apos = MouseGetPos()
    Opt("MouseCoordMode", $imode)
    Local $tpoint = DllStructCreate($tagpoint)
    DllStructSetData($tpoint, "X", $apos[0x0])
    DllStructSetData($tpoint, "Y", $apos[0x1])
    If $btoclient And Not _WinAPI_ScreenToClient($hwnd, $tpoint) Then Return SetError(@error + 0x14, @extended, 0x0)
    Return $tpoint
EndFunc   ;==>_WINAPI_GETMOUSEPOS
Func _WinAPI_GetMousePosX($btoclient = False, $hwnd = 0x0)
    Local $tpoint = _WinAPI_GetMousePos($btoclient, $hwnd)
    If @error Then Return SetError(@error, @extended, 0x0)
    Return DllStructGetData($tpoint, "X")
EndFunc   ;==>_WINAPI_GETMOUSEPOSX
Func _WinAPI_GetMousePosY($btoclient = False, $hwnd = 0x0)
    Local $tpoint = _WinAPI_GetMousePos($btoclient, $hwnd)
    If @error Then Return SetError(@error, @extended, 0x0)
    Return DllStructGetData($tpoint, "Y")
EndFunc   ;==>_WINAPI_GETMOUSEPOSY
Func _WinAPI_MulDiv($inumber, $inumerator, $idenominator)
    Local $acall = DllCall("kernel32.dll", "int", "MulDiv", "int", $inumber, "int", $inumerator, "int", $idenominator)
    If @error Then Return SetError(@error, @extended, +0xffffffff)
    Return $acall[0x0]
EndFunc   ;==>_WINAPI_MULDIV
Func _WINAPI_PLAYSOUND($ssound, $iflags = $snd_system_nostop, $hinstance = 0x0)
    Local $stypeofsound = "ptr"
    If $ssound Then
        If IsString($ssound) Then
            $stypeofsound = "wstr"
        EndIf
    Else
        $ssound = 0x0
        $iflags = 0x0
    EndIf
    Local $acall = DllCall("winmm.dll", "bool", "PlaySoundW", $stypeofsound, $ssound, "handle", $hinstance, "dword", $iflags)
    If @error Then Return SetError(@error, @extended, False)
    Return $acall[0x0]
EndFunc   ;==>_WINAPI_PLAYSOUND
Func _WinAPI_StringLenA(Const ByRef $tstring)
    Local $acall = DllCall("kernel32.dll", "int", "lstrlenA", "struct*", $tstring)
    If @error Then Return SetError(@error, @extended, 0x0)
    Return $acall[0x0]
EndFunc   ;==>_WINAPI_STRINGLENA
Func _WinAPI_StringLenW(Const ByRef $tstring)
    Local $acall = DllCall("kernel32.dll", "int", "lstrlenW", "struct*", $tstring)
    If @error Then Return SetError(@error, @extended, 0x0)
    Return $acall[0x0]
EndFunc   ;==>_WINAPI_STRINGLENW
Func _WINAPI_STRUCTTOARRAY(ByRef $tstruct, $iitems = 0x0)
    Local $isize = 0x2 * Floor(DllStructGetSize($tstruct) / 0x2)
    Local $pstruct = DllStructGetPtr($tstruct)
    If Not $isize Or Not $pstruct Then Return SetError(0x1, 0x0, 0x0)
    Local $tdata, $ilength, $ioffset = 0x0
    Local $aret[0x65] = [0x0]
    While 0x1
        $ilength = _WINAPI_STRLEN($pstruct + $ioffset)
        If Not $ilength Then
            ExitLoop
        EndIf
        If 0x2 * (0x1 + $ilength) + $ioffset > $isize Then Return SetError(0x3, 0x0, 0x0)
        $tdata = DllStructCreate("wchar[" & (0x1 + $ilength) & "]", $pstruct + $ioffset)
        If @error Then Return SetError(@error + 0xa, 0x0, 0x0)
        __INC($aret)
        $aret[$aret[0x0]] = DllStructGetData($tdata, 0x1)
        If $aret[0x0] = $iitems Then
            ExitLoop
        EndIf
        $ioffset += 0x2 * (0x1 + $ilength)
        If $ioffset >= $isize Then Return SetError(0x3, 0x0, 0x0)
    WEnd
    If Not $aret[0x0] Then Return SetError(0x2, 0x0, 0x0)
    __INC($aret, +0xffffffff)
    Return $aret
EndFunc   ;==>_WINAPI_STRUCTTOARRAY
Func _WINAPI_UNIONSTRUCT($tstruct1, $tstruct2, $sstruct = "")
    Local $asize[0x2] = [DllStructGetSize($tstruct1), DllStructGetSize($tstruct2)]
    If Not $asize[0x0] Or Not $asize[0x1] Then Return SetError(0x1, 0x0, 0x0)
    Local $tresult
    If Not StringStripWS($sstruct, $str_stripleading + $str_striptrailing + $str_stripspaces) Then
        $tresult = DllStructCreate("byte[" & ($asize[0x0] + $asize[0x1]) & "]")
    Else
        $tresult = DllStructCreate($sstruct)
    EndIf
    If DllStructGetSize($tresult) < ($asize[0x0] + $asize[0x1]) Then Return SetError(0x2, 0x0, 0x0)
    _WINAPI_MOVEMEMORY($tresult, $tstruct1, $asize[0x0])
    _WINAPI_MOVEMEMORY(DllStructGetPtr($tresult) + $asize[0x0], $tstruct2, $asize[0x1])
    Return $tresult
EndFunc   ;==>_WINAPI_UNIONSTRUCT
#endregion Public Functions
Global Const $dllver_platform_windows = 0x1
Global Const $dllver_platform_nt = 0x2
Global Const $shcne_allevents = 0x7fffffff
Global Const $shcne_assocchanged = 0x8000000
Global Const $shcne_attributes = 0x800
Global Const $shcne_create = 0x2
Global Const $shcne_delete = 0x4
Global Const $shcne_driveadd = 0x100
Global Const $shcne_driveaddgui = 0x10000
Global Const $shcne_driveremoved = 0x80
Global Const $shcne_extended_event = 0x4000000
Global Const $shcne_freespace = 0x40000
Global Const $shcne_mediainserted = 0x20
Global Const $shcne_mediaremoved = 0x40
Global Const $shcne_mkdir = 0x8
Global Const $shcne_netshare = 0x200
Global Const $shcne_netunshare = 0x400
Global Const $shcne_renamefolder = 0x20000
Global Const $shcne_renameitem = 0x1
Global Const $shcne_rmdir = 0x10
Global Const $shcne_serverdisconnect = 0x4000
Global Const $shcne_updatedir = 0x1000
Global Const $shcne_updateimage = 0x8000
Global Const $shcne_updateitem = 0x2000
Global Const $shcne_diskevents = 0x2381f
Global Const $shcne_globalevents = 0xc0581e0
Global Const $shcne_interrupt = 0x80000000
Global Const $shcnf_dword = 0x3
Global Const $shcnf_idlist = 0x0
Global Const $shcnf_path = 0x1
Global Const $shcnf_printer = 0x2
Global Const $shcnf_flush = 0x1000
Global Const $shcnf_flushnowait = 0x2000
Global Const $shcnf_notifyrecursive = 0x10000
Global Const $shcnrf_interruptlevel = 0x1
Global Const $shcnrf_shelllevel = 0x2
Global Const $shcnrf_recursiveinterrupt = 0x1000
Global Const $shcnrf_newdelivery = 0x8000
Global Const $sherb_noconfirmation = 0x1
Global Const $sherb_noprogressui = 0x2
Global Const $sherb_nosound = 0x4
Global Const $sherb_no_ui = BitOR($sherb_noconfirmation, $sherb_noprogressui, $sherb_nosound)
Global Const $see_mask_default = 0x0
Global Const $see_mask_classname = 0x1
Global Const $see_mask_classkey = 0x3
Global Const $see_mask_idlist = 0x4
Global Const $see_mask_invokeidlist = 0xc
Global Const $see_mask_icon = 0x10
Global Const $see_mask_hotkey = 0x20
Global Const $see_mask_nocloseprocess = 0x40
Global Const $see_mask_connectnetdrv = 0x80
Global Const $see_mask_noasync = 0x100
Global Const $see_mask_flag_ddewait = $see_mask_noasync
Global Const $see_mask_doenvsubst = 0x200
Global Const $see_mask_flag_no_ui = 0x400
Global Const $see_mask_unicode = 0x4000
Global Const $see_mask_no_console = 0x8000
Global Const $see_mask_asyncok = 0x100000
Global Const $see_mask_noqueryclassstore = 0x1000000
Global Const $see_mask_hmonitor = 0x200000
Global Const $see_mask_nozonechecks = 0x800000
Global Const $see_mask_waitforinputidle = 0x2000000
Global Const $see_mask_flag_log_usage = 0x4000000
Global Const $se_err_accessdenied = 0x5
Global Const $se_err_associncomplete = 0x1b
Global Const $se_err_ddebusy = 0x1e
Global Const $se_err_ddefail = 0x1d
Global Const $se_err_ddetimeout = 0x1c
Global Const $se_err_dllnotfound = 0x20
Global Const $se_err_fnf = 0x2
Global Const $se_err_noassoc = 0x1f
Global Const $se_err_oom = 0x8
Global Const $se_err_pnf = 0x3
Global Const $se_err_share = 0x1a
Global Const $fo_copy = 0x2
Global Const $fo_delete = 0x3
Global Const $fo_move = 0x1
Global Const $fo_rename = 0x4
Global Const $fof_allowundo = 0x40
Global Const $fof_confirmmouse = 0x2
Global Const $fof_filesonly = 0x80
Global Const $fof_multidestfiles = 0x1
Global Const $fof_noconfirmation = 0x10
Global Const $fof_noconfirmmkdir = 0x200
Global Const $fof_no_connected_elements = 0x2000
Global Const $fof_nocopysecurityattribs = 0x800
Global Const $fof_noerrorui = 0x400
Global Const $fof_norecursereparse = 0x8000
Global Const $fof_norecursion = 0x1000
Global Const $fof_renameoncollision = 0x8
Global Const $fof_silent = 0x4
Global Const $fof_simpleprogress = 0x100
Global Const $fof_wantmappinghandle = 0x20
Global Const $fof_wantnukewarning = 0x4000
Global Const $fof_no_ui = BitOR($fof_noconfirmation, $fof_noconfirmmkdir, $fof_noerrorui, $fof_silent)
Global Const $shgfi_addoverlays = 0x20
Global Const $shgfi_attr_specified = 0x20000
Global Const $shgfi_attributes = 0x800
Global Const $shgfi_displayname = 0x200
Global Const $shgfi_exetype = 0x2000
Global Const $shgfi_icon = 0x100
Global Const $shgfi_iconlocation = 0x1000
Global Const $shgfi_largeicon = 0x0
Global Const $shgfi_linkoverlay = 0x8000
Global Const $shgfi_openicon = 0x2
Global Const $shgfi_overlayindex = 0x40
Global Const $shgfi_pidl = 0x8
Global Const $shgfi_selected = 0x10000
Global Const $shgfi_shelliconsize = 0x4
Global Const $shgfi_smallicon = 0x1
Global Const $shgfi_sysiconindex = 0x4000
Global Const $shgfi_typename = 0x400
Global Const $shgfi_usefileattributes = 0x10
Global Const $sfgao_cancopy = 0x1
Global Const $sfgao_canmove = 0x2
Global Const $sfgao_canlink = 0x4
Global Const $sfgao_storage = 0x8
Global Const $sfgao_canrename = 0x10
Global Const $sfgao_candelete = 0x20
Global Const $sfgao_haspropsheet = 0x40
Global Const $sfgao_droptarget = 0x100
Global Const $sfgao_capabilitymask = BitOR($sfgao_cancopy, $sfgao_canmove, $sfgao_canlink, $sfgao_canrename, $sfgao_candelete, $sfgao_haspropsheet, $sfgao_droptarget)
Global Const $sfgao_system = 0x1000
Global Const $sfgao_encrypted = 0x2000
Global Const $sfgao_isslow = 0x4000
Global Const $sfgao_ghosted = 0x8000
Global Const $sfgao_link = 0x10000
Global Const $sfgao_share = 0x20000
Global Const $sfgao_readonly = 0x40000
Global Const $sfgao_hidden = 0x80000
Global Const $sfgao_displayattrmask = BitOR($sfgao_isslow, $sfgao_ghosted, $sfgao_link, $sfgao_share, $sfgao_readonly, $sfgao_hidden)
Global Const $sfgao_nonenumerated = 0x100000
Global Const $sfgao_newcontent = 0x200000
Global Const $sfgao_stream = 0x400000
Global Const $sfgao_storageancestor = 0x800000
Global Const $sfgao_validate = 0x1000000
Global Const $sfgao_removable = 0x2000000
Global Const $sfgao_compressed = 0x4000000
Global Const $sfgao_browsable = 0x8000000
Global Const $sfgao_filesysancestor = 0x10000000
Global Const $sfgao_folder = 0x20000000
Global Const $sfgao_filesystem = 0x40000000
Global Const $sfgao_storagecapmask = BitOR($sfgao_storage, $sfgao_link, $sfgao_readonly, $sfgao_stream, $sfgao_storageancestor, $sfgao_filesysancestor, $sfgao_folder, $sfgao_filesystem)
Global Const $sfgao_hassubfolder = 0x80000000
Global Const $sfgao_contentsmask = $sfgao_hassubfolder
Global Const $sfgao_pkeysfgaomask = BitOR($sfgao_isslow, $sfgao_readonly, $sfgao_hassubfolder, $sfgao_validate)
Global Const $ido_shgioi_default = 0xffffffc
Global Const $ido_shgioi_link = 0xffffffe
Global Const $ido_shgioi_share = 0xfffffff
Global Const $ido_shgioi_slowfile = 0xffffffd
Global Const $fcsm_viewid = 0x1
Global Const $fcsm_webviewtemplate = 0x2
Global Const $fcsm_infotip = 0x4
Global Const $fcsm_clsid = 0x8
Global Const $fcsm_iconfile = 0x10
Global Const $fcsm_logo = 0x20
Global Const $fcsm_flags = 0x40
Global Const $fcs_read = 0x1
Global Const $fcs_forcewrite = 0x2
Global Const $fcs_write = BitOR($fcs_read, $fcs_forcewrite)
Global Const $ssf_autocheckselect = 0x800000
Global Const $ssf_desktophtml = 0x200
Global Const $ssf_dontprettypath = 0x800
Global Const $ssf_doubleclickinwebview = 0x80
Global Const $ssf_hideicons = 0x4000
Global Const $ssf_iconsonly = 0x1000000
Global Const $ssf_mapnetdrvbutton = 0x1000
Global Const $ssf_noconfirmrecycle = 0x8000
Global Const $ssf_nonetcrawling = 0x100000
Global Const $ssf_sepprocess = 0x80000
Global Const $ssf_showallobjects = 0x1
Global Const $ssf_showcompcolor = 0x8
Global Const $ssf_showextensions = 0x2
Global Const $ssf_showinfotip = 0x2000
Global Const $ssf_showsuperhidden = 0x40000
Global Const $ssf_showsysfiles = 0x20
Global Const $ssf_showtypeoverlay = 0x2000000
Global Const $ssf_startpanelon = 0x200000
Global Const $ssf_win95classic = 0x400
Global Const $ssf_webview = 0x20000
Global Const $csidl_admintools = 0x30
Global Const $csidl_altstartup = 0x1d
Global Const $csidl_appdata = 0x1a
Global Const $csidl_bitbucket = 0xa
Global Const $csidl_cdburn_area = 0x3b
Global Const $csidl_common_admintools = 0x2f
Global Const $csidl_common_altstartup = 0x1e
Global Const $csidl_common_appdata = 0x23
Global Const $csidl_common_desktopdirectory = 0x19
Global Const $csidl_common_documents = 0x2e
Global Const $csidl_common_favorites = 0x1f
Global Const $csidl_common_music = 0x35
Global Const $csidl_common_pictures = 0x36
Global Const $csidl_common_programs = 0x17
Global Const $csidl_common_startmenu = 0x16
Global Const $csidl_common_startup = 0x18
Global Const $csidl_common_templates = 0x2d
Global Const $csidl_common_video = 0x37
Global Const $csidl_computersnearme = 0x3d
Global Const $csidl_connections = 0x31
Global Const $csidl_controls = 0x3
Global Const $csidl_cookies = 0x21
Global Const $csidl_desktop = 0x0
Global Const $csidl_desktopdirectory = 0x10
Global Const $csidl_drives = 0x11
Global Const $csidl_favorites = 0x6
Global Const $csidl_fonts = 0x14
Global Const $csidl_internet_cache = 0x20
Global Const $csidl_history = 0x22
Global Const $csidl_local_appdata = 0x1c
Global Const $csidl_mymusic = 0xd
Global Const $csidl_mypictures = 0x27
Global Const $csidl_myvideo = 0xe
Global Const $csidl_nethood = 0x13
Global Const $csidl_personal = 0x5
Global Const $csidl_printers = 0x4
Global Const $csidl_printhood = 0x1b
Global Const $csidl_profile = 0x28
Global Const $csidl_program_files = 0x26
Global Const $csidl_program_files_common = 0x2b
Global Const $csidl_program_files_commonx86 = 0x2c
Global Const $csidl_program_filesx86 = 0x2a
Global Const $csidl_programs = 0x2
Global Const $csidl_recent = 0x8
Global Const $csidl_sendto = 0x9
Global Const $csidl_startmenu = 0xb
Global Const $csidl_startup = 0x7
Global Const $csidl_system = 0x25
Global Const $csidl_systemx86 = 0x29
Global Const $csidl_templates = 0x15
Global Const $csidl_windows = 0x24
Global Const $siid_docnoassoc = 0x0
Global Const $siid_docassoc = 0x1
Global Const $siid_application = 0x2
Global Const $siid_folder = 0x3
Global Const $siid_folderopen = 0x4
Global Const $siid_drive525 = 0x5
Global Const $siid_drive35 = 0x6
Global Const $siid_driveremove = 0x7
Global Const $siid_drivefixed = 0x8
Global Const $siid_drivenet = 0x9
Global Const $siid_drivenetdisabled = 0xa
Global Const $siid_drivecd = 0xb
Global Const $siid_driveram = 0xc
Global Const $siid_world = 0xd
Global Const $siid_server = 0xf
Global Const $siid_printer = 0x10
Global Const $siid_mynetwork = 0x11
Global Const $siid_find = 0x16
Global Const $siid_help = 0x17
Global Const $siid_share = 0x1c
Global Const $siid_link = 0x1d
Global Const $siid_slowfile = 0x1e
Global Const $siid_recycler = 0x1f
Global Const $siid_recyclerfull = 0x20
Global Const $siid_mediacdaudio = 0x28
Global Const $siid_lock = 0x2f
Global Const $siid_autolist = 0x31
Global Const $siid_printernet = 0x32
Global Const $siid_servershare = 0x33
Global Const $siid_printerfax = 0x34
Global Const $siid_printerfaxnet = 0x35
Global Const $siid_printerfile = 0x36
Global Const $siid_stack = 0x37
Global Const $siid_mediasvcd = 0x38
Global Const $siid_stuffedfolder = 0x39
Global Const $siid_driveunknown = 0x3a
Global Const $siid_drivedvd = 0x3b
Global Const $siid_mediadvd = 0x3c
Global Const $siid_mediadvdram = 0x3d
Global Const $siid_mediadvdrw = 0x3e
Global Const $siid_mediadvdr = 0x3f
Global Const $siid_mediadvdrom = 0x40
Global Const $siid_mediacdaudioplus = 0x41
Global Const $siid_mediacdrw = 0x42
Global Const $siid_mediacdr = 0x43
Global Const $siid_mediacdburn = 0x44
Global Const $siid_mediablankcd = 0x45
Global Const $siid_mediacdrom = 0x46
Global Const $siid_audiofiles = 0x47
Global Const $siid_imagefiles = 0x48
Global Const $siid_videofiles = 0x49
Global Const $siid_mixedfiles = 0x4a
Global Const $siid_folderback = 0x4b
Global Const $siid_folderfront = 0x4c
Global Const $siid_shield = 0x4d
Global Const $siid_warning = 0x4e
Global Const $siid_info = 0x4f
Global Const $siid_error = 0x50
Global Const $siid_key = 0x51
Global Const $siid_software = 0x52
Global Const $siid_rename = 0x53
Global Const $siid_delete = 0x54
Global Const $siid_mediaaudiodvd = 0x55
Global Const $siid_mediamoviedvd = 0x56
Global Const $siid_mediaenhancedcd = 0x57
Global Const $siid_mediaenhanceddvd = 0x58
Global Const $siid_mediahddvd = 0x59
Global Const $siid_mediabluray = 0x5a
Global Const $siid_mediavcd = 0x5b
Global Const $siid_mediadvdplusr = 0x5c
Global Const $siid_mediadvdplusrw = 0x5d
Global Const $siid_desktoppc = 0x5e
Global Const $siid_mobilepc = 0x5f
Global Const $siid_users = 0x60
Global Const $siid_mediasmartmedia = 0x61
Global Const $siid_mediacompactflash = 0x62
Global Const $siid_devicecellphone = 0x63
Global Const $siid_devicecamera = 0x64
Global Const $siid_devicevideocamera = 0x65
Global Const $siid_deviceaudioplayer = 0x66
Global Const $siid_networkconnect = 0x67
Global Const $siid_internet = 0x68
Global Const $siid_zipfile = 0x69
Global Const $siid_settings = 0x6a
Global Const $siid_drivehddvd = 0x84
Global Const $siid_drivebd = 0x85
Global Const $siid_mediahddvdrom = 0x86
Global Const $siid_mediahddvdr = 0x87
Global Const $siid_mediahddvdram = 0x88
Global Const $siid_mediabdrom = 0x89
Global Const $siid_mediabdr = 0x8a
Global Const $siid_mediabdre = 0x8b
Global Const $siid_clustereddrive = 0x8c
Global Const $siid_max_icons = 0xae
Global Const $shgsi_iconlocation = 0x0
Global Const $shgsi_icon = $shgfi_icon
Global Const $shgsi_sysiconindex = $shgfi_sysiconindex
Global Const $shgsi_linkoverlay = $shgfi_linkoverlay
Global Const $shgsi_selected = $shgfi_selected
Global Const $shgsi_largeicon = $shgfi_largeicon
Global Const $shgsi_smallicon = $shgfi_smallicon
Global Const $shgsi_shelliconsize = $shgfi_shelliconsize
Global Const $nim_add = 0x0
Global Const $nim_modify = 0x1
Global Const $nim_delete = 0x2
Global Const $nim_setfocus = 0x3
Global Const $nim_setversion = 0x4
Global Const $nif_message = 0x1
Global Const $nif_icon = 0x2
Global Const $nif_tip = 0x4
Global Const $nif_state = 0x8
Global Const $nif_info = 0x10
Global Const $nif_guid = 0x20
Global Const $nif_realtime = 0x40
Global Const $nif_showtip = 0x80
Global Const $nis_hidden = 0x1
Global Const $nis_sharedicon = 0x2
Global Const $niif_none = 0x0
Global Const $niif_info = 0x1
Global Const $niif_warning = 0x2
Global Const $niif_error = 0x3
Global Const $niif_user = 0x4
Global Const $niif_nosound = 0x10
Global Const $niif_large_icon = 0x10
Global Const $niif_respect_quiet_time = 0x80
Global Const $niif_icon_mask = 0xf
Global Const $shop_printername = 0x1
Global Const $shop_filepath = 0x2
Global Const $shop_volumeguid = 0x4
Global Const $ofasi_edit = 0x1
Global Const $ofasi_opendesktop = 0x2
Global Const $quns_not_present = 0x1
Global Const $quns_busy = 0x2
Global Const $quns_running_d3d_full_screen = 0x3
Global Const $quns_presentation_mode = 0x4
Global Const $quns_accepts_notifications = 0x5
Global Const $quns_quiet_time = 0x6
Global Const $rest_norun = 0x1
Global Const $rest_noclose = 0x2
Global Const $rest_nosaveset = 0x3
Global Const $rest_nofilemenu = 0x4
Global Const $rest_nosetfolders = 0x5
Global Const $rest_nosettaskbar = 0x6
Global Const $rest_nodesktop = 0x7
Global Const $rest_nofind = 0x8
Global Const $rest_nodrives = 0x9
Global Const $rest_nodriveautorun = 0xa
Global Const $rest_nodrivetypeautorun = 0xb
Global Const $rest_nonethood = 0xc
Global Const $rest_startbanner = 0xd
Global Const $rest_restrictrun = 0xe
Global Const $rest_noprintertabs = 0xf
Global Const $rest_noprinterdelete = 0x10
Global Const $rest_noprinteradd = 0x11
Global Const $rest_nostartmenusubfolders = 0x12
Global Const $rest_mydocsonnet = 0x13
Global Const $rest_noexittodos = 0x14
Global Const $rest_enforceshellextsecurity = 0x15
Global Const $rest_linkresolveignorelinkinfo = 0x16
Global Const $rest_nocommongroups = 0x17
Global Const $rest_separatedesktopprocess = 0x18
Global Const $rest_noweb = 0x19
Global Const $rest_notraycontextmenu = 0x1a
Global Const $rest_noviewcontextmenu = 0x1b
Global Const $rest_nonetconnectdisconnect = 0x1c
Global Const $rest_startmenulogoff = 0x1d
Global Const $rest_nosettingsassist = 0x1e
Global Const $rest_nointerneticon = 0x1f
Global Const $rest_norecentdocshistory = 0x20
Global Const $rest_norecentdocsmenu = 0x21
Global Const $rest_noactivedesktop = 0x22
Global Const $rest_noactivedesktopchanges = 0x23
Global Const $rest_nofavoritesmenu = 0x24
Global Const $rest_clearrecentdocsonexit = 0x25
Global Const $rest_classicshell = 0x26
Global Const $rest_nocustomizewebview = 0x27
Global Const $rest_nohtmlwallpaper = 0x28
Global Const $rest_nochangingwallpaper = 0x29
Global Const $rest_nodeskcomp = 0x2a
Global Const $rest_noadddeskcomp = 0x2b
Global Const $rest_nodeldeskcomp = 0x2c
Global Const $rest_noclosedeskcomp = 0x2d
Global Const $rest_noclose_dragdropband = 0x2e
Global Const $rest_nomovingband = 0x2f
Global Const $rest_noeditdeskcomp = 0x30
Global Const $rest_noresolvesearch = 0x31
Global Const $rest_noresolvetrack = 0x32
Global Const $rest_forcecopyaclwithfile = 0x33
Global Const $rest_nologo3channelnotify = 0x34
Global Const $rest_noforgetsoftwareupdate = 0x35
Global Const $rest_nosetactivedesktop = 0x36
Global Const $rest_noupdatewindows = 0x37
Global Const $rest_nochangestarmenu = 0x38
Global Const $rest_nofolderoptions = 0x39
Global Const $rest_hasfindcomputers = 0x3a
Global Const $rest_intellimenus = 0x3b
Global Const $rest_rundlgmemcheckbox = 0x3c
Global Const $rest_arp_showpostsetup = 0x3d
Global Const $rest_nocsc = 0x3e
Global Const $rest_nocontrolpanel = 0x3f
Global Const $rest_enumworkgroup = 0x40
Global Const $rest_arp_noarp = 0x41
Global Const $rest_arp_noremovepage = 0x42
Global Const $rest_arp_noaddpage = 0x43
Global Const $rest_arp_nowinsetuppage = 0x44
Global Const $rest_greymsiads = 0x45
Global Const $rest_nochangemappeddrivelabel = 0x46
Global Const $rest_nochangemappeddrivecomment = 0x47
Global Const $rest_maxrecentdocs = 0x48
Global Const $rest_nonetworkconnections = 0x49
Global Const $rest_forcestartmenulogoff = 0x4a
Global Const $rest_nowebview = 0x4b
Global Const $rest_nocustomizethisfolder = 0x4c
Global Const $rest_noencryption = 0x4d
Global Const $rest_dontshowsuperhidden = 0x4e
Global Const $rest_noshellsearchbutton = 0x4f
Global Const $rest_nohardwaretab = 0x50
Global Const $rest_norunasinstallprompt = 0x51
Global Const $rest_promptrunasinstallnetpath = 0x52
Global Const $rest_nomanagemycomputerverb = 0x53
Global Const $rest_norecentdocsnethood = 0x54
Global Const $rest_disallowrun = 0x55
Global Const $rest_nowelcomescreen = 0x56
Global Const $rest_restrictcpl = 0x57
Global Const $rest_disallowcpl = 0x58
Global Const $rest_nosmballoontip = 0x59
Global Const $rest_nosmhelp = 0x5a
Global Const $rest_nowinkeys = 0x5b
Global Const $rest_noencryptonmove = 0x5c
Global Const $rest_nolocalmachinerun = 0x5d
Global Const $rest_nocurrentuserrun = 0x5e
Global Const $rest_nolocalmachinerunonce = 0x5f
Global Const $rest_nocurrentuserrunonce = 0x60
Global Const $rest_forceactivedesktopon = 0x61
Global Const $rest_nocomputersnearme = 0x62
Global Const $rest_noviewondrive = 0x63
Global Const $rest_nonetcrawl = 0x64
Global Const $rest_noshareddocuments = 0x65
Global Const $rest_nosmmydocs = 0x66
Global Const $rest_nosmmypics = 0x67
Global Const $rest_allowbitbuckdrives = 0x68
Global Const $rest_nonlegacyshellmode = 0x69
Global Const $rest_nocontrolpanelbarricade = 0x6a
Global Const $rest_nostartpage = 0x6b
Global Const $rest_noautotraynotify = 0x6c
Global Const $rest_notaskgrouping = 0x6d
Global Const $rest_nocdburning = 0x6e
Global Const $rest_mycompnoprop = 0x6f
Global Const $rest_mydocsnoprop = 0x70
Global Const $rest_nostartpanel = 0x71
Global Const $rest_nodisplayappearancepage = 0x72
Global Const $rest_nothemestab = 0x73
Global Const $rest_novisualstylechoice = 0x74
Global Const $rest_nosizechoice = 0x75
Global Const $rest_nocolorchoice = 0x76
Global Const $rest_setvisualstyle = 0x77
Global Const $rest_startrunnohomepath = 0x78
Global Const $rest_nousernameinstartpanel = 0x79
Global Const $rest_nomycomputericon = 0x7a
Global Const $rest_nosmnetworkplaces = 0x7b
Global Const $rest_nosmpinnedlist = 0x7c
Global Const $rest_nosmmymusic = 0x7d
Global Const $rest_nosmejectpc = 0x7e
Global Const $rest_nosmmoreprograms = 0x7f
Global Const $rest_nosmmfuprograms = 0x80
Global Const $rest_notrayitemsdisplay = 0x81
Global Const $rest_notoolbarsontaskbar = 0x82
Global Const $rest_nosmconfigureprograms = 0x83
Global Const $rest_hideclock = 0x84
Global Const $rest_nolowdiskspacechecks = 0x85
Global Const $rest_noentirenetwork = 0x86
Global Const $rest_nodesktopcleanup = 0x87
Global Const $rest_bitbucknukeondelete = 0x88
Global Const $rest_bitbuckconfirmdelete = 0x89
Global Const $rest_bitbucknoprop = 0x8a
Global Const $rest_nodispbackground = 0x8b
Global Const $rest_nodispscreensavepg = 0x8c
Global Const $rest_nodispsettingspg = 0x8d
Global Const $rest_nodispscreensavepreview = 0x8e
Global Const $rest_nodisplaycpl = 0x8f
Global Const $rest_hiderunasverb = 0x90
Global Const $rest_nothumbnailcache = 0x91
Global Const $rest_nostrcmplogical = 0x92
Global Const $rest_nopublishwizard = 0x93
Global Const $rest_noonlineprintswizard = 0x94
Global Const $rest_nowebservices = 0x95
Global Const $rest_allowunhashedwebview = 0x96
Global Const $rest_allowlegacywebview = 0x97
Global Const $rest_revertwebviewsecurity = 0x98
Global Const $rest_inheritconsolehandles = 0x99
Global Const $rest_sortmaxitemcount = 0x9a
Global Const $rest_noremoterecursiveevents = 0x9b
Global Const $rest_noremotechangenotify = 0x9c
Global Const $rest_nosimplenetidlist = 0x9d
Global Const $rest_noenumentirenetwork = 0x9e
Global Const $rest_nodetailsthumbnailonnetwork = 0x9f
Global Const $rest_nointernetopenwith = 0xa0
Global Const $rest_allowlegacylmzbehavior = 0xa1
Global Const $rest_dontretrybadnetname = 0xa2
Global Const $rest_allowfileclsidjunctions = 0xa3
Global Const $rest_noupnpinstall = 0xa4
Global Const $rest_arp_dontgrouppatches = 0xa5
Global Const $rest_arp_nochooseprogramspage = 0xa6
Global Const $rest_nodisconnect = 0xa7
Global Const $rest_nosecurity = 0xa8
Global Const $rest_nofileassociate = 0xa9
Global Const $rest_allowcommenttoggle = 0xaa
Global Const $rest_usedesktopinicache = 0xab
Global Const $gil_dontcache = 0x10
Global Const $gil_notfilename = 0x8
Global Const $gil_perclass = 0x4
Global Const $gil_perinstance = 0x2
Global Const $gil_simulatedoc = 0x1
Global Const $gil_shield = 0x200
Global Const $gil_forcenoshield = 0x400
Global Const $folderid_addnewprograms = "{DE61D971-5EBC-4F02-A3A9-6C82895E5C04}"
Global Const $folderid_admintools = "{724EF170-A42D-4FEF-9F26-B60E846FBA4F}"
Global Const $folderid_appupdates = "{A305CE99-F527-492B-8B1A-7E76FA98D6E4}"
Global Const $folderid_cdburning = "{9E52AB10-F80D-49DF-ACB8-4330F5687855}"
Global Const $folderid_changeremoveprograms = "{DF7266AC-9274-4867-8D55-3BD661DE872D}"
Global Const $folderid_commonadmintools = "{D0384E7D-BAC3-4797-8F14-CBA229B392B5}"
Global Const $folderid_commonoemlinks = "{C1BAE2D0-10DF-4334-BEDD-7AA20B227A9D}"
Global Const $folderid_commonprograms = "{0139D44E-6AFE-49F2-8690-3DAFCAE6FFB8}"
Global Const $folderid_commonstartmenu = "{A4115719-D62E-491D-AA7C-E74B8BE3B067}"
Global Const $folderid_commonstartup = "{82A5EA35-D9CD-47C5-9629-E15D2F714E6E}"
Global Const $folderid_commontemplates = "{B94237E7-57AC-4347-9151-B08C6C32D1F7}"
Global Const $folderid_computerfolder = "{0AC0837C-BBF8-452A-850D-79D08E667CA7}"
Global Const $folderid_conflictfolder = "{4BFEFB45-347D-4006-A5BE-AC0CB0567192}"
Global Const $folderid_connectionsfolder = "{6F0CD92B-2E97-45D1-88FF-B0D186B8DEDD}"
Global Const $folderid_contacts = "{56784854-C6CB-462B-8169-88E350ACB882}"
Global Const $folderid_controlpanelfolder = "{82A74AEB-AEB4-465C-A014-D097EE346D63}"
Global Const $folderid_cookies = "{2B0F765D-C0E9-4171-908E-08A611B84FF6}"
Global Const $folderid_desktop = "{B4BFCC3A-DB2C-424C-B029-7FE99A87C641}"
Global Const $folderid_devicemetadatastore = "{5CE4A5E9-E4EB-479D-B89F-130C02886155}"
Global Const $folderid_documentslibrary = "{7B0DB17D-9CD2-4A93-9733-46CC89022E7C}"
Global Const $folderid_downloads = "{374DE290-123F-4565-9164-39C4925E467B}"
Global Const $folderid_favorites = "{1777F761-68AD-4D8A-87BD-30B759FA33DD}"
Global Const $folderid_fonts = "{FD228CB7-AE11-4AE3-864C-16F3910AB8FE}"
Global Const $folderid_games = "{CAC52C1A-B53D-4EDC-92D7-6B2E8AC19434}"
Global Const $folderid_gametasks = "{054FAE61-4DD8-4787-80B6-090220C4B700}"
Global Const $folderid_history = "{D9DC8A3B-B784-432E-A781-5A1130A75963}"
Global Const $folderid_homegroup = "{52528A6B-B9E3-4ADD-B60D-588C2DBA842D}"
Global Const $folderid_implicitappshortcuts = "{BCB5256F-79F6-4CEE-B725-DC34E402FD46}"
Global Const $folderid_internetcache = "{352481E8-33BE-4251-BA85-6007CAEDCF9D}"
Global Const $folderid_internetfolder = "{4D9F7874-4E0C-4904-967B-40B0D20C3E4B}"
Global Const $folderid_libraries = "{1B3EA5DC-B587-4786-B4EF-BD1DC332AEAE}"
Global Const $folderid_links = "{BFB9D5E0-C6A9-404C-B2B2-AE6DB6AF4968}"
Global Const $folderid_localappdata = "{F1B32785-6FBA-4FCF-9D55-7B8E7F157091}"
Global Const $folderid_localappdatalow = "{A520A1A4-1780-4FF6-BD18-167343C5AF16}"
Global Const $folderid_localizedresourcesdir = "{2A00375E-224C-49DE-B8D1-440DF7EF3DDC}"
Global Const $folderid_music = "{4BD8D571-6D19-48D3-BE97-422220080E43}"
Global Const $folderid_musiclibrary = "{2112AB0A-C86A-4FFE-A368-0DE96E47012E}"
Global Const $folderid_nethood = "{C5ABBF53-E17F-4121-8900-86626FC2C973}"
Global Const $folderid_networkfolder = "{D20BEEC4-5CA8-4905-AE3B-BF251EA09B53}"
Global Const $folderid_originalimages = "{2C36C0AA-5812-4B87-BFD0-4CD0DFB19B39}"
Global Const $folderid_photoalbums = "{69D2CF90-FC33-4FB7-9A0C-EBB0F0FCB43C}"
Global Const $folderid_pictureslibrary = "{A990AE9F-A03B-4E80-94BC-9912D7504104}"
Global Const $folderid_pictures = "{33E28130-4E1E-4676-835A-98395C3BC3BB}"
Global Const $folderid_playlists = "{DE92C1C7-837F-4F69-A3BB-86E631204A23}"
Global Const $folderid_printersfolder = "{76FC4E2D-D6AD-4519-A663-37BD56068185}"
Global Const $folderid_printhood = "{9274BD8D-CFD1-41C3-B35E-B13F55A758F4}"
Global Const $folderid_profile = "{5E6C858F-0E22-4760-9AFE-EA3317B67173}"
Global Const $folderid_programdata = "{62AB5D82-FDC1-4DC3-A9DD-070D1D495D97}"
Global Const $folderid_programfiles = "{905E63B6-C1BF-494E-B29C-65B732D3D21A}"
Global Const $folderid_programfilesx64 = "{6D809377-6AF0-444B-8957-A3773F02200E}"
Global Const $folderid_programfilesx86 = "{7C5A40EF-A0FB-4BFC-874A-C0F2E0B9FA8E}"
Global Const $folderid_programfilescommon = "{F7F1ED05-9F6D-47A2-AAAE-29D317C6F066}"
Global Const $folderid_programfilescommonx64 = "{6365D5A7-0F0D-45E5-87F6-0DA56B6A4F7D}"
Global Const $folderid_programfilescommonx86 = "{DE974D24-D9C6-4D3E-BF91-F4455120B917}"
Global Const $folderid_programs = "{A77F5D77-2E2B-44C3-A6A2-ABA601054A51}"
Global Const $folderid_public = "{DFDF76A2-C82A-4D63-906A-5644AC457385}"
Global Const $folderid_publicdesktop = "{C4AA340D-F20F-4863-AFEF-F87EF2E6BA25}"
Global Const $folderid_publicdocuments = "{ED4824AF-DCE4-45A8-81E2-FC7965083634}"
Global Const $folderid_publicdownloads = "{3D644C9B-1FB8-4F30-9B45-F670235F79C0}"
Global Const $folderid_publicgametasks = "{DEBF2536-E1A8-4C59-B6A2-414586476AEA}"
Global Const $folderid_publiclibraries = "{48DAF80B-E6CF-4F4E-B800-0E69D84EE384}"
Global Const $folderid_publicmusic = "{3214FAB5-9757-4298-BB61-92A9DEAA44FF}"
Global Const $folderid_publicpictures = "{B6EBFB86-6907-413C-9AF7-4FC2ABF07CC5}"
Global Const $folderid_publicringtones = "{E555AB60-153B-4D17-9F04-A5FE99FC15EC}"
Global Const $folderid_publicvideos = "{2400183A-6185-49FB-A2D8-4A392A602BA3}"
Global Const $folderid_quicklaunch = "{52A4F021-7B75-48A9-9F6B-4B87A210BC8F}"
Global Const $folderid_recent = "{AE50C081-EBD2-438A-8655-8A092E34987A}"
Global Const $folderid_recordedtvlibrary = "{1A6FDBA2-F42D-4358-A798-B74D745926C5}"
Global Const $folderid_recyclebinfolder = "{B7534046-3ECB-4C18-BE4E-64CD4CB7D6AC}"
Global Const $folderid_resourcedir = "{8AD10C31-2ADB-4296-A8F7-E4701232C972}"
Global Const $folderid_ringtones = "{C870044B-F49E-4126-A9C3-B52A1FF411E8}"
Global Const $folderid_roamingappdata = "{3EB685DB-65F9-4CF6-A03A-E3EF65729F3D}"
Global Const $folderid_samplemusic = "{B250C668-F57D-4EE1-A63C-290EE7D1AA1F}"
Global Const $folderid_samplepictures = "{C4900540-2379-4C75-844B-64E6FAF8716B}"
Global Const $folderid_sampleplaylists = "{15CA69B3-30EE-49C1-ACE1-6B5EC372AFB5}"
Global Const $folderid_samplevideos = "{859EAD94-2E85-48AD-A71A-0969CB56A6CD}"
Global Const $folderid_savedgames = "{4C5C32FF-BB9D-43B0-B5B4-2D72E54EAAA4}"
Global Const $folderid_savedsearches = "{7D1D3A04-DEBB-4115-95CF-2F29DA2920DA}"
Global Const $folderid_search_csc = "{EE32E446-31CA-4ABA-814F-A5EBD2FD6D5E}"
Global Const $folderid_search_mapi = "{98EC0E18-2098-4D44-8644-66979315A281}"
Global Const $folderid_searchhome = "{190337D1-B8CA-4121-A639-6D472D16972A}"
Global Const $folderid_sendto = "{8983036C-27C0-404B-8F08-102D10DCFD74}"
Global Const $folderid_sidebardefaultparts = "{7B396E54-9EC5-4300-BE0A-2482EBAE1A26}"
Global Const $folderid_sidebarparts = "{A75D362E-50FC-4FB7-AC2C-A8BEAA314493}"
Global Const $folderid_startmenu = "{625B53C3-AB48-4EC1-BA1F-A1EF4146FC19}"
Global Const $folderid_startup = "{B97D20BB-F46A-4C97-BA10-5E3608430854}"
Global Const $folderid_syncmanagerfolder = "{43668BF8-C14E-49B2-97C9-747784D784B7}"
Global Const $folderid_syncresultsfolder = "{289A9A43-BE44-4057-A41B-587A76D7E7F9}"
Global Const $folderid_syncsetupfolder = "{0F214138-B1D3-4A90-BBA9-27CBC0C5389A}"
Global Const $folderid_system = "{1AC14E77-02E7-4E5D-B744-2EB1AE5198B7}"
Global Const $folderid_systemx86 = "{D65231B0-B2F1-4857-A4CE-A8E7C6EA7D27}"
Global Const $folderid_templates = "{A63293E8-664E-48DB-A079-DF759E0509F7}"
Global Const $folderid_userpinned = "{9E3995AB-1F9C-4F13-B827-48B24B6C7174}"
Global Const $folderid_userprofiles = "{0762D272-C50A-4BB0-A382-697DCD729B80}"
Global Const $folderid_userprogramfiles = "{5CD7AEE2-2219-4A67-B85D-6C9CE15660CB}"
Global Const $folderid_userprogramfilescommon = "{BCBD3057-CA5C-4622-B42D-BC56DB0AE516}"
Global Const $folderid_usersfiles = "{F3CE0F7C-4901-4ACC-8648-D5D44B04EF8F}"
Global Const $folderid_userslibraries = "{A302545D-DEFF-464B-ABE8-61C8648D939B}"
Global Const $folderid_videos = "{18989B1D-99B5-455B-841C-AB7C74E4DDFC}"
Global Const $folderid_videoslibrary = "{491E922F-5643-4AF4-A7EB-4E7A138D8174}"
Global Const $folderid_windows = "{F38BF404-1D43-42F2-9305-67DE0B28FC23}"
Global Const $kf_flag_alias_only = 0x80000000
Global Const $kf_flag_create = 0x8000
Global Const $kf_flag_dont_verify = 0x4000
Global Const $kf_flag_dont_unexpand = 0x2000
Global Const $kf_flag_no_alias = 0x1000
Global Const $kf_flag_init = 0x800
Global Const $kf_flag_default_path = 0x400
Global Const $kf_flag_no_appcontainer_redirection = 0x10000
Global Const $kf_flag_not_parent_relative = 0x200
Global Const $kf_flag_simple_idlist = 0x100
Global Const $url_scheme_invalid = +0xffffffff
Global Const $url_scheme_unknown = 0x0
Global Const $url_scheme_ftp = 0x1
Global Const $url_scheme_http = 0x2
Global Const $url_scheme_gopher = 0x3
Global Const $url_scheme_mailto = 0x4
Global Const $url_scheme_news = 0x5
Global Const $url_scheme_nntp = 0x6
Global Const $url_scheme_telnet = 0x7
Global Const $url_scheme_wais = 0x8
Global Const $url_scheme_file = 0x9
Global Const $url_scheme_mk = 0xa
Global Const $url_scheme_https = 0xb
Global Const $url_scheme_shell = 0xc
Global Const $url_scheme_snews = 0xd
Global Const $url_scheme_local = 0xe
Global Const $url_scheme_javascript = 0xf
Global Const $url_scheme_vbscript = 0x10
Global Const $url_scheme_about = 0x11
Global Const $url_scheme_res = 0x12
Global Const $url_scheme_msshellrooted = 0x13
Global Const $url_scheme_msshellidlist = 0x14
Global Const $url_scheme_mshelp = 0x15
Global Const $url_scheme_msshelldevice = 0x16
Global Const $url_scheme_wildcard = 0x17
Global Const $url_scheme_search_ms = 0x18
Global Const $url_scheme_search = 0x19
Global Const $url_scheme_knownfolder = 0x1a
Global Const $gct_invalid = 0x0
Global Const $gct_lfnchar = 0x1
Global Const $gct_separator = 0x8
Global Const $gct_shortchar = 0x2
Global Const $gct_wild = 0x4
Global Const $url_apply_default = 0x1
Global Const $url_apply_guessscheme = 0x2
Global Const $url_apply_guessfile = 0x4
Global Const $url_apply_forceapply = 0x8
Global Const $url_dont_simplify = 0x8000000
Global Const $url_escape_as_utf8 = 0x40000
Global Const $url_escape_percent = 0x1000
Global Const $url_escape_spaces_only = 0x4000000
Global Const $url_escape_unsafe = 0x20000000
Global Const $url_no_meta = 0x8000000
Global Const $url_pluggable_protocol = 0x40000000
Global Const $url_unescape = 0x10000000
Global Const $url_part_hostname = 0x2
Global Const $url_part_password = 0x4
Global Const $url_part_port = 0x5
Global Const $url_part_query = 0x6
Global Const $url_part_scheme = 0x1
Global Const $url_part_username = 0x3
Global Const $urlis_appliable = 0x4
Global Const $urlis_directory = 0x5
Global Const $urlis_fileurl = 0x3
Global Const $urlis_hasquery = 0x6
Global Const $urlis_nohistory = 0x2
Global Const $urlis_opaque = 0x1
Global Const $urlis_url = 0x0
#region Functions list
#endregion Functions list
#region Public Functions
Func _WINAPI_COMMANDLINETOARGV($scmd)
    Local $aret[0x1] = [0x0]
    $scmd = StringStripWS($scmd, $str_stripleading + $str_striptrailing)
    If Not $scmd Then
        Return $aret
    EndIf
    Local $acall = DllCall("shell32.dll", "ptr", "CommandLineToArgvW", "wstr", $scmd, "int*", 0x0)
    If @error Or Not $acall[0x0] Or (Not $acall[0x2]) Then Return SetError(@error + 0xa, @extended, 0x0)
    Local $tptr = DllStructCreate("ptr[" & $acall[0x2] & "]", $acall[0x0])
    Dim $aret[$acall[0x2] + 0x1] = [$acall[0x2]]
    For $i = 0x1 To $acall[0x2]
        $aret[$i] = _WINAPI_GETSTRING(DllStructGetData($tptr, 0x1, $i))
    Next
    DllCall("kernel32.dll", "handle", "LocalFree", "handle", $acall[0x0])
    Return $aret
EndFunc   ;==>_WINAPI_COMMANDLINETOARGV
Func _WINAPI_ISNAMEINEXPRESSION($sstring, $spattern, $bcasesensitive = False)
    If Not $bcasesensitive Then $spattern = StringUpper($spattern)
    Local $tus1 = __US($spattern)
    Local $tus2 = __US($sstring)
    Local $acall = DllCall("ntdll.dll", "boolean", "RtlIsNameInExpression", "struct*", $tus1, "struct*", $tus2, "boolean", Not $bcasesensitive, "ptr", 0x0)
    If @error Then Return SetError(@error, @extended, False)
    Return $acall[0x0]
EndFunc   ;==>_WINAPI_ISNAMEINEXPRESSION
Func _WINAPI_PARSEURL($surl)
    Local $tagparsedurl = "dword Size;ptr Protocol;uint cchProtocol;ptr Suffix;uint cchSuffix;uint Scheme"
    Local $tpurl = DllStructCreate($tagparsedurl)
    DllStructSetData($tpurl, 0x1, DllStructGetSize($tpurl))
    Local $turl = DllStructCreate("wchar[4096]")
    DllStructSetData($turl, 0x1, $surl)
    Local $acall = DllCall("shlwapi.dll", "long", "ParseURLW", "struct*", $turl, "struct*", $tpurl)
    If @error Then Return SetError(@error, @extended, "")
    If $acall[0x0] Then Return SetError(0xa, $acall[0x0], "")
    Local $aret[0x3]
    $aret[0x0] = DllStructGetData(DllStructCreate("wchar[" & DllStructGetData($tpurl, 0x3) & "]", DllStructGetData($tpurl, 0x2)), 0x1)
    $aret[0x1] = DllStructGetData(DllStructCreate("wchar[" & DllStructGetData($tpurl, 0x5) & "]", DllStructGetData($tpurl, 0x4)), 0x1)
    $aret[0x2] = DllStructGetData($tpurl, 0x6)
    Return $aret
EndFunc   ;==>_WINAPI_PARSEURL
Func _WINAPI_PARSEUSERNAME($suser)
    If Not __DLL("credui.dll") Then Return SetError(0x67, 0x0, 0x0)
    Local $acall = DllCall("credui.dll", "dword", "CredUIParseUserNameW", "wstr", $suser, "wstr", "", "ulong", 0x1000, "wstr", "", "ulong", 0x1000)
    If @error Then Return SetError(@error, @extended, 0x0)
    Switch $acall[0x0]
        Case 0x0
        Case 0x523
            If StringStripWS($suser, $str_stripleading + $str_striptrailing) Then
                $acall[0x2] = $suser
                $acall[0x4] = ""
            Else
                ContinueCase
            EndIf
        Case Else
            Return SetError(0xa, $acall[0x0], 0x0)
    EndSwitch
    Local $aret[0x2]
    $aret[0x0] = $acall[0x4]
    $aret[0x1] = $acall[0x2]
    Return $aret
EndFunc   ;==>_WINAPI_PARSEUSERNAME
Func _WINAPI_PATHADDBACKSLASH($sfilepath)
    Local $tpath = DllStructCreate("wchar[260]")
    DllStructSetData($tpath, 0x1, $sfilepath)
    Local $acall = DllCall("shlwapi.dll", "ptr", "PathAddBackslashW", "struct*", $tpath)
    If @error Or Not $acall[0x0] Then Return SetError(@error, @extended, "")
    Return DllStructGetData($tpath, 0x1)
EndFunc   ;==>_WINAPI_PATHADDBACKSLASH
Func _WINAPI_PATHADDEXTENSION($sfilepath, $sext = "")
    Local $tpath = DllStructCreate("wchar[260]")
    DllStructSetData($tpath, 0x1, $sfilepath)
    If Not StringStripWS($sext, $str_stripleading + $str_striptrailing) Then $sext = NULL
    Local $acall = DllCall("shlwapi.dll", "bool", "PathAddExtensionW", "struct*", $tpath, "wstr", $sext)
    If @error Then Return SetError(@error, @extended, "")
    Return SetExtended($acall[0x0], DllStructGetData($tpath, 0x1))
EndFunc   ;==>_WINAPI_PATHADDEXTENSION
Func _WINAPI_PATHAPPEND($sfilepath, $smore)
    Local $tpath = DllStructCreate("wchar[260]")
    DllStructSetData($tpath, 0x1, $sfilepath)
    Local $acall = DllCall("shlwapi.dll", "bool", "PathAppendW", "struct*", $tpath, "wstr", $smore)
    If @error Or Not $acall[0x0] Then Return SetError(@error, @extended, "")
    Return DllStructGetData($tpath, 0x1)
EndFunc   ;==>_WINAPI_PATHAPPEND
Func _WINAPI_PATHBUILDROOT($idrive)
    Local $acall = DllCall("shlwapi.dll", "ptr", "PathBuildRootW", "wstr", "", "int", $idrive)
    If @error Then Return SetError(@error, @extended, "")
    Return $acall[0x1]
EndFunc   ;==>_WINAPI_PATHBUILDROOT
Func _WINAPI_PATHCANONICALIZE($sfilepath)
    Local $acall = DllCall("shlwapi.dll", "bool", "PathCanonicalizeW", "wstr", "", "wstr", $sfilepath)
    If @error Or Not $acall[0x0] Then Return SetError(@error, @extended, $sfilepath)
    Return $acall[0x1]
EndFunc   ;==>_WINAPI_PATHCANONICALIZE
Func _WINAPI_PATHCOMMONPREFIX($spath1, $spath2)
    Local $acall = DllCall("shlwapi.dll", "int", "PathCommonPrefixW", "wstr", $spath1, "wstr", $spath2, "wstr", "")
    If @error Then Return SetError(@error, @extended, "")
    Return SetExtended($acall[0x0], $acall[0x3])
EndFunc   ;==>_WINAPI_PATHCOMMONPREFIX
Func _WINAPI_PATHCOMPACTPATH($hwnd, $sfilepath, $iwidth = 0x0)
    If $iwidth < 0x1 Then
        Local $trect = DllStructCreate($tagrect)
        DllCall("user32.dll", "bool", "GetClientRect", "hwnd", $hwnd, "struct*", $trect)
        $iwidth += DllStructGetData($trect, "Right") - DllStructGetData($trect, "Left")
    EndIf
    Local $acall = DllCall("user32.dll", "handle", "GetDC", "hwnd", $hwnd)
    If @error Or Not $acall[0x0] Then Return SetError(@error + 0x14, @extended, $sfilepath)
    Local $hdc = $acall[0x0]
    Local Const $wm_getfont = 0x31
    $acall = DllCall("user32.dll", "ptr", "SendMessage", "hwnd", $hwnd, "uint", $wm_getfont, "wparam", 0x0, "lparam", 0x0)
    Local $hback = DllCall("gdi32.dll", "handle", "SelectObject", "handle", $hdc, "handle", $acall[0x0])
    Local $ierror = 0x0
    $acall = DllCall("shlwapi.dll", "bool", "PathCompactPathW", "handle", $hdc, "wstr", $sfilepath, "int", $iwidth)
    If @error Or Not $acall[0x0] Then $ierror = @error + 0xa
    DllCall("gdi32.dll", "handle", "SelectObject", "handle", $hdc, "handle", $hback[0x0])
    DllCall("user32.dll", "int", "ReleaseDC", "hwnd", $hwnd, "handle", $hdc)
    If $ierror Then Return SetError($ierror, 0x0, $sfilepath)
    Return $acall[0x2]
EndFunc   ;==>_WINAPI_PATHCOMPACTPATH
Func _WINAPI_PATHCOMPACTPATHEX($sfilepath, $imax)
    Local $acall = DllCall("shlwapi.dll", "bool", "PathCompactPathExW", "wstr", "", "wstr", $sfilepath, "uint", $imax + 0x1, "dword", 0x0)
    If @error Or Not $acall[0x0] Then Return SetError(@error + 0xa, @extended, $sfilepath)
    Return $acall[0x1]
EndFunc   ;==>_WINAPI_PATHCOMPACTPATHEX
Func _WINAPI_PATHCREATEFROMURL($surl)
    Local $acall = DllCall("shlwapi.dll", "long", "PathCreateFromUrlW", "wstr", $surl, "wstr", "", "dword*", 0x1000, "dword", 0x0)
    If @error Then Return SetError(@error, @extended, "")
    If $acall[0x0] Then Return SetError(0xa, $acall[0x0], "")
    Return $acall[0x2]
EndFunc   ;==>_WINAPI_PATHCREATEFROMURL
Func _WINAPI_PATHFINDEXTENSION($sfilepath)
    Local $acall = DllCall("shlwapi.dll", "wstr", "PathFindExtensionW", "wstr", $sfilepath)
    If @error Then Return SetError(@error, @extended, "")
    Return $acall[0x0]
EndFunc   ;==>_WINAPI_PATHFINDEXTENSION
Func _WINAPI_PATHFINDFILENAME($sfilepath)
    Local $acall = DllCall("shlwapi.dll", "wstr", "PathFindFileNameW", "wstr", $sfilepath)
    If @error Then Return SetError(@error, @extended, $sfilepath)
    Return $acall[0x0]
EndFunc   ;==>_WINAPI_PATHFINDFILENAME
Func _WINAPI_PATHFINDNEXTCOMPONENT($sfilepath)
    Local $tpath = DllStructCreate("wchar[" & (StringLen($sfilepath) + 0x1) & "]")
    DllStructSetData($tpath, 0x1, $sfilepath)
    Local $acall = DllCall("shlwapi.dll", "ptr", "PathFindNextComponentW", "struct*", $tpath)
    If @error Or Not $acall[0x0] Then Return SetError(@error + 0xa, @extended, "")
    Return _WINAPI_GETSTRING($acall[0x0])
EndFunc   ;==>_WINAPI_PATHFINDNEXTCOMPONENT
Func _WinAPI_PathFindOnPath(Const $sfilepath, $aextrapaths = "", Const $spathdelimiter = @LF)
    Local $iextracount = 0x0
    If IsString($aextrapaths) Then
        If StringLen($aextrapaths) Then
            $aextrapaths = StringSplit($aextrapaths, $spathdelimiter, $str_entiresplit + $str_nocount)
            $iextracount = UBound($aextrapaths, $ubound_rows)
        EndIf
    ElseIf IsArray($aextrapaths) Then
        $iextracount = UBound($aextrapaths)
    EndIf
    Local $tpaths, $tpathptrs
    If $iextracount Then
        Local $tagstruct = ""
        For $path In $aextrapaths
            $tagstruct &= "wchar[" & StringLen($path) + 0x1 & "];"
        Next
        $tpaths = DllStructCreate($tagstruct)
        $tpathptrs = DllStructCreate("ptr[" & $iextracount + 0x1 & "]")
        For $i = 0x1 To $iextracount
            DllStructSetData($tpaths, $i, $aextrapaths[$i + 0xffffffff])
            DllStructSetData($tpathptrs, 0x1, DllStructGetPtr($tpaths, $i), $i)
        Next
        DllStructSetData($tpathptrs, 0x1, Ptr(0x0), $iextracount + 0x1)
    EndIf
    Local $acall = DllCall("shlwapi.dll", "bool", "PathFindOnPathW", "wstr", $sfilepath, "struct*", $tpathptrs)
    If @error Or Not $acall[0x0] Then Return SetError(@error + 0xa, @extended, $sfilepath)
    Return $acall[0x1]
EndFunc   ;==>_WINAPI_PATHFINDONPATH
Func _WINAPI_PATHGETARGS($sfilepath)
    Local $tpath = DllStructCreate("wchar[" & (StringLen($sfilepath) + 0x1) & "]")
    DllStructSetData($tpath, 0x1, $sfilepath)
    Local $acall = DllCall("shlwapi.dll", "ptr", "PathGetArgsW", "struct*", $tpath)
    If @error Or Not $acall[0x0] Then Return SetError(@error, @extended, "")
    Return _WINAPI_GETSTRING($acall[0x0])
EndFunc   ;==>_WINAPI_PATHGETARGS
Func _WINAPI_PATHGETCHARTYPE($schar)
    Local $acall = DllCall("shlwapi.dll", "uint", "PathGetCharTypeW", "word", AscW($schar))
    If @error Then Return SetError(@error, @extended, +0xffffffff)
    Return $acall[0x0]
EndFunc   ;==>_WINAPI_PATHGETCHARTYPE
Func _WINAPI_PATHGETDRIVENUMBER($sfilepath)
    Local $acall = DllCall("shlwapi.dll", "int", "PathGetDriveNumberW", "wstr", $sfilepath)
    If @error Or ($acall[0x0] = +0xffffffff) Then Return SetError(@error, @extended, "")
    Return Chr($acall[0x0] + 0x41) & ":"
EndFunc   ;==>_WINAPI_PATHGETDRIVENUMBER
Func _WINAPI_PATHISCONTENTTYPE($sfilepath, $stype)
    Local $acall = DllCall("shlwapi.dll", "bool", "PathIsContentTypeW", "wstr", $sfilepath, "wstr", $stype)
    If @error Then Return SetError(@error, @extended, False)
    Return $acall[0x0]
EndFunc   ;==>_WINAPI_PATHISCONTENTTYPE
Func _WINAPI_PATHISEXE($sfilepath)
    Local $acall = DllCall("shell32.dll", "bool", "PathIsExe", "wstr", $sfilepath)
    If @error Then Return SetError(@error, @extended, False)
    Return $acall[0x0]
EndFunc   ;==>_WINAPI_PATHISEXE
Func _WINAPI_PATHISFILESPEC($sfilepath)
    Local $acall = DllCall("shlwapi.dll", "bool", "PathIsFileSpecW", "wstr", $sfilepath)
    If @error Then Return SetError(@error, @extended, False)
    Return $acall[0x0]
EndFunc   ;==>_WINAPI_PATHISFILESPEC
Func _WINAPI_PATHISLFNFILESPEC($sfilepath)
    Local $acall = DllCall("shlwapi.dll", "bool", "PathIsLFNFileSpecW", "wstr", $sfilepath)
    If @error Then Return SetError(@error, @extended, False)
    Return $acall[0x0]
EndFunc   ;==>_WINAPI_PATHISLFNFILESPEC
Func _WINAPI_PATHISRELATIVE($sfilepath)
    Local $acall = DllCall("shlwapi.dll", "bool", "PathIsRelativeW", "wstr", $sfilepath)
    If @error Then Return SetError(@error, @extended, False)
    Return $acall[0x0]
EndFunc   ;==>_WINAPI_PATHISRELATIVE
Func _WINAPI_PATHISROOT($sfilepath)
    Local $acall = DllCall("shlwapi.dll", "bool", "PathIsRootW", "wstr", $sfilepath)
    If @error Then Return SetError(@error, @extended, False)
    Return $acall[0x0]
EndFunc   ;==>_WINAPI_PATHISROOT
Func _WINAPI_PATHISSAMEROOT($spath1, $spath2)
    Local $acall = DllCall("shlwapi.dll", "bool", "PathIsSameRootW", "wstr", $spath1, "wstr", $spath2)
    If @error Then Return SetError(@error, @extended, False)
    Return $acall[0x0]
EndFunc   ;==>_WINAPI_PATHISSAMEROOT
Func _WINAPI_PATHISSYSTEMFOLDER($sfilepath)
    Local $acall = DllCall("shlwapi.dll", "bool", "PathIsSystemFolderW", "wstr", $sfilepath, "dword", 0x0)
    If @error Then Return SetError(@error, @extended, False)
    Return $acall[0x0]
EndFunc   ;==>_WINAPI_PATHISSYSTEMFOLDER
Func _WINAPI_PATHISUNC($sfilepath)
    Local $acall = DllCall("shlwapi.dll", "bool", "PathIsUNCW", "wstr", $sfilepath)
    If @error Then Return SetError(@error, @extended, False)
    Return $acall[0x0]
EndFunc   ;==>_WINAPI_PATHISUNC
Func _WINAPI_PATHISUNCSERVER($sfilepath)
    Local $acall = DllCall("shlwapi.dll", "bool", "PathIsUNCServerW", "wstr", $sfilepath)
    If @error Then Return SetError(@error, @extended, False)
    Return $acall[0x0]
EndFunc   ;==>_WINAPI_PATHISUNCSERVER
Func _WINAPI_PATHISUNCSERVERSHARE($sfilepath)
    Local $acall = DllCall("shlwapi.dll", "bool", "PathIsUNCServerShareW", "wstr", $sfilepath)
    If @error Then Return SetError(@error, @extended, False)
    Return $acall[0x0]
EndFunc   ;==>_WINAPI_PATHISUNCSERVERSHARE
Func _WINAPI_PATHMAKESYSTEMFOLDER($sfilepath)
    Local $acall = DllCall("shlwapi.dll", "bool", "PathMakeSystemFolderW", "wstr", $sfilepath)
    If @error Then Return SetError(@error, @extended, False)
    Return $acall[0x0]
EndFunc   ;==>_WINAPI_PATHMAKESYSTEMFOLDER
Func _WINAPI_PATHMATCHSPEC($sfilepath, $sspec)
    Local $acall = DllCall("shlwapi.dll", "bool", "PathMatchSpecW", "wstr", $sfilepath, "wstr", $sspec)
    If @error Then Return SetError(@error, @extended, False)
    Return $acall[0x0]
EndFunc   ;==>_WINAPI_PATHMATCHSPEC
Func _WINAPI_PATHPARSEICONLOCATION($sfilepath)
    Local $acall = DllCall("shlwapi.dll", "int", "PathParseIconLocationW", "wstr", $sfilepath)
    If @error Then Return SetError(@error, @extended, 0x0)
    Local $aret[0x2]
    $aret[0x0] = $acall[0x1]
    $aret[0x1] = $acall[0x0]
    Return $aret
EndFunc   ;==>_WINAPI_PATHPARSEICONLOCATION
Func _WINAPI_PATHRELATIVEPATHTO($spathfrom, $bdirfrom, $spathto, $bdirto)
    If $bdirfrom Then
        $bdirfrom = 0x10
    EndIf
    If $bdirto Then
        $bdirto = 0x10
    EndIf
    Local $acall = DllCall("shlwapi.dll", "bool", "PathRelativePathToW", "wstr", "", "wstr", $spathfrom, "dword", $bdirfrom, "wstr", $spathto, "dword", $bdirto)
    If @error Or Not $acall[0x0] Then Return SetError(@error, @extended, "")
    Return $acall[0x1]
EndFunc   ;==>_WINAPI_PATHRELATIVEPATHTO
Func _WINAPI_PATHREMOVEARGS($sfilepath)
    Local $acall = DllCall("shlwapi.dll", "none", "PathRemoveArgsW", "wstr", $sfilepath)
    If @error Then Return SetError(@error, @extended, "")
    Return $acall[0x1]
EndFunc   ;==>_WINAPI_PATHREMOVEARGS
Func _WINAPI_PATHREMOVEBACKSLASH($sfilepath)
    Local $acall = DllCall("shlwapi.dll", "ptr", "PathRemoveBackslashW", "wstr", $sfilepath)
    If @error Then Return SetError(@error, @extended, "")
    Return $acall[0x1]
EndFunc   ;==>_WINAPI_PATHREMOVEBACKSLASH
Func _WINAPI_PATHREMOVEEXTENSION($sfilepath)
    Local $acall = DllCall("shlwapi.dll", "none", "PathRemoveExtensionW", "wstr", $sfilepath)
    If @error Then Return SetError(@error, @extended, "")
    Return $acall[0x1]
EndFunc   ;==>_WINAPI_PATHREMOVEEXTENSION
Func _WINAPI_PATHREMOVEFILESPEC($sfilepath)
    Local $acall = DllCall("shlwapi.dll", "bool", "PathRemoveFileSpecW", "wstr", $sfilepath)
    If @error Then Return SetError(@error, @extended, "")
    Return SetExtended($acall[0x0], $acall[0x1])
EndFunc   ;==>_WINAPI_PATHREMOVEFILESPEC
Func _WINAPI_PATHRENAMEEXTENSION($sfilepath, $sext)
    Local $tpath = DllStructCreate("wchar[260]")
    DllStructSetData($tpath, 0x1, $sfilepath)
    Local $acall = DllCall("shlwapi.dll", "bool", "PathRenameExtensionW", "struct*", $tpath, "wstr", $sext)
    If @error Or Not $acall[0x0] Then Return SetError(@error, @extended, "")
    Return DllStructGetData($tpath, 0x1)
EndFunc   ;==>_WINAPI_PATHRENAMEEXTENSION
Func _WINAPI_PATHSEARCHANDQUALIFY($sfilepath, $bexists = False)
    Local $acall = DllCall("shlwapi.dll", "bool", "PathSearchAndQualifyW", "wstr", $sfilepath, "wstr", "", "int", 0x1000)
    If @error Or Not $acall[0x0] Then Return SetError(@error + 0xa, @extended, "")
    If $bexists And Not FileExists($acall[0x2]) Then Return SetError(0x14, 0x0, "")
    Return $acall[0x2]
EndFunc   ;==>_WINAPI_PATHSEARCHANDQUALIFY
Func _WINAPI_PATHSKIPROOT($sfilepath)
    Local $tpath = DllStructCreate("wchar[" & (StringLen($sfilepath) + 0x1) & "]")
    DllStructSetData($tpath, 0x1, $sfilepath)
    Local $acall = DllCall("shlwapi.dll", "ptr", "PathSkipRootW", "struct*", $tpath)
    If @error Then Return SetError(@error, @extended, "")
    If Not $acall[0x0] Then Return $sfilepath
    Return _WINAPI_GETSTRING($acall[0x0])
EndFunc   ;==>_WINAPI_PATHSKIPROOT
Func _WINAPI_PATHSTRIPPATH($sfilepath)
    Local $acall = DllCall("shlwapi.dll", "none", "PathStripPathW", "wstr", $sfilepath)
    If @error Then Return SetError(@error, @extended, "")
    Return $acall[0x1]
EndFunc   ;==>_WINAPI_PATHSTRIPPATH
Func _WINAPI_PATHSTRIPTOROOT($sfilepath)
    Local $acall = DllCall("shlwapi.dll", "bool", "PathStripToRootW", "wstr", $sfilepath)
    If @error Or Not $acall[0x0] Then Return SetError(@error, @extended, "")
    Return $acall[0x1]
EndFunc   ;==>_WINAPI_PATHSTRIPTOROOT
Func _WINAPI_PATHUNDECORATE($sfilepath)
    Local $acall = DllCall("shlwapi.dll", "none", "PathUndecorateW", "wstr", $sfilepath)
    If @error Then Return SetError(@error, @extended, "")
    Return $acall[0x1]
EndFunc   ;==>_WINAPI_PATHUNDECORATE
Func _WINAPI_PATHUNEXPANDENVSTRINGS($sfilepath)
    Local $acall = DllCall("shlwapi.dll", "bool", "PathUnExpandEnvStringsW", "wstr", $sfilepath, "wstr", "", "uint", 0x1000)
    If @error Or Not $acall[0x0] Then Return SetError(@error, @extended, "")
    Return $acall[0x2]
EndFunc   ;==>_WINAPI_PATHUNEXPANDENVSTRINGS
Func _WINAPI_PATHUNMAKESYSTEMFOLDER($sfilepath)
    Local $acall = DllCall("shlwapi.dll", "bool", "PathUnmakeSystemFolderW", "wstr", $sfilepath)
    If @error Then Return SetError(@error, @extended, False)
    Return $acall[0x0]
EndFunc   ;==>_WINAPI_PATHUNMAKESYSTEMFOLDER
Func _WINAPI_PATHUNQUOTESPACES($sfilepath)
    Local $acall = DllCall("shlwapi.dll", "none", "PathUnquoteSpacesW", "wstr", $sfilepath)
    If @error Then Return SetError(@error, @extended, "")
    Return $acall[0x1]
EndFunc   ;==>_WINAPI_PATHUNQUOTESPACES
Func _WINAPI_PATHYETANOTHERMAKEUNIQUENAME($sfilepath)
    Local $acall = DllCall("shell32.dll", "int", "PathYetAnotherMakeUniqueName", "wstr", "", "wstr", $sfilepath, "ptr", 0x0, "ptr", 0x0)
    If @error Or Not $acall[0x0] Then Return SetError(@error, @extended, "")
    Return $acall[0x1]
EndFunc   ;==>_WINAPI_PATHYETANOTHERMAKEUNIQUENAME
Func _WINAPI_SHELLGETIMAGELIST($bsmall = False)
    Local $plarge, $psmall, $tptr = DllStructCreate("ptr")
    If $bsmall Then
        $plarge = 0x0
        $psmall = DllStructGetPtr($tptr)
    Else
        $plarge = DllStructGetPtr($tptr)
        $psmall = 0x0
    EndIf
    Local $acall = DllCall("shell32.dll", "int", "Shell_GetImageLists", "ptr", $plarge, "ptr", $psmall)
    If @error Or Not $acall[0x0] Then Return SetError(@error, @extended, 0x0)
    Return DllStructGetData($tptr, 0x1)
EndFunc   ;==>_WINAPI_SHELLGETIMAGELIST
Func _WINAPI_URLAPPLYSCHEME($surl, $iflags = 0x1)
    Local $acall = DllCall("shlwapi.dll", "long", "UrlApplySchemeW", "wstr", $surl, "wstr", "", "dword*", 0x1000, "dword", $iflags)
    If @error Then Return SetError(@error, @extended, "")
    If $acall[0x0] Then Return SetError(0xa, $acall[0x0], "")
    Return $acall[0x2]
EndFunc   ;==>_WINAPI_URLAPPLYSCHEME
Func _WINAPI_URLCANONICALIZE($surl, $iflags)
    Local $acall = DllCall("shlwapi.dll", "long", "UrlCanonicalizeW", "wstr", $surl, "wstr", "", "dword*", 0x1000, "dword", $iflags)
    If @error Then Return SetError(@error, @extended, "")
    If $acall[0x0] Then Return SetError(0xa, $acall[0x0], "")
    Return $acall[0x2]
EndFunc   ;==>_WINAPI_URLCANONICALIZE
Func _WINAPI_URLCOMBINE($surl, $spart, $iflags = 0x0)
    Local $acall = DllCall("shlwapi.dll", "long", "UrlCombineW", "wstr", $surl, "wstr", $spart, "wstr", "", "dword*", 0x1000, "dword", $iflags)
    If @error Then Return SetError(@error, @extended, "")
    If $acall[0x0] Then Return SetError(0xa, $acall[0x0], "")
    Return $acall[0x3]
EndFunc   ;==>_WINAPI_URLCOMBINE
Func _WINAPI_URLCOMPARE($surl1, $surl2, $bignoreslash = False)
    Local $acall = DllCall("shlwapi.dll", "int", "UrlCompareW", "wstr", $surl1, "wstr", $surl2, "bool", $bignoreslash)
    If @error Then Return SetError(@error, @extended, 0x0)
    Return $acall[0x0]
EndFunc   ;==>_WINAPI_URLCOMPARE
Func _WINAPI_URLCREATEFROMPATH($sfilepath)
    Local $acall = DllCall("shlwapi.dll", "long", "UrlCreateFromPathW", "wstr", $sfilepath, "wstr", "", "dword*", 0x1000, "dword", 0x0)
    If @error Then Return SetError(@error, @extended, "")
    If $acall[0x0] < 0x0 Or $acall[0x0] > 0x1 Then
        Return SetError(0xa, $acall[0x0], "")
    EndIf
    Return $acall[0x2]
EndFunc   ;==>_WINAPI_URLCREATEFROMPATH
Func _WINAPI_URLFIXUP($surl)
    Local $acall = DllCall("shlwapi.dll", "long", "UrlFixupW", "wstr", $surl, "wstr", "", "dword", 0x1000)
    If @error Then Return SetError(@error, @extended, "")
    If $acall[0x0] Then Return SetError(0xa, $acall[0x0], "")
    Return $acall[0x2]
EndFunc   ;==>_WINAPI_URLFIXUP
Func _WINAPI_URLGETPART($surl, $ipart)
    Local $acall = DllCall("shlwapi.dll", "long", "UrlGetPartW", "wstr", $surl, "wstr", "", "dword*", 0x1000, "dword", $ipart, "dword", 0x0)
    If @error Then Return SetError(@error, @extended, "")
    If $acall[0x0] Then Return SetError(0xa, $acall[0x0], "")
    Return $acall[0x2]
EndFunc   ;==>_WINAPI_URLGETPART
Func _WINAPI_URLHASH($surl, $ilength = 0x20)
    If $ilength <= 0x0 Or $ilength > 0x100 Then Return SetError(0x100, 0x0, 0x0)
    Local $tdata = DllStructCreate("byte[" & $ilength & "]")
    Local $acall = DllCall("shlwapi.dll", "long", "UrlHashW", "wstr", $surl, "struct*", $tdata, "dword", $ilength)
    If @error Then Return SetError(@error + 0xa, @extended, 0x0)
    If $acall[0x0] Then Return SetError(0xa, $acall[0x0], 0x0)
    Return DllStructGetData($tdata, 0x1)
EndFunc   ;==>_WINAPI_URLHASH
Func _WINAPI_URLIS($surl, $itype = 0x0)
    Local $acall = DllCall("shlwapi.dll", "bool", "UrlIsW", "wstr", $surl, "uint", $itype)
    If @error Then Return SetError(@error, @extended, False)
    Return $acall[0x0]
EndFunc   ;==>_WINAPI_URLIS
#endregion Public Functions
#region Internal Functions
Func __US($sstring, $ilength = 0x0)
    If $ilength Then
        $sstring = StringLeft($sstring, $ilength)
    Else
        $ilength = StringLen($sstring)
    EndIf
    Local $tus = DllStructCreate("ushort;ushort;ptr;wchar[" & ($ilength + 0x1) & "]")
    DllStructSetData($tus, 0x1, 0x2 * StringLen($sstring))
    DllStructSetData($tus, 0x2, 0x2 * $ilength)
    DllStructSetData($tus, 0x3, DllStructGetPtr($tus, 0x4))
    DllStructSetData($tus, 0x4, $sstring)
    Return $tus
EndFunc   ;==>__US
#endregion Internal Functions
#region Global Variables and Constants
Global Const $tagnotifyicondata = "struct;dword Size;hwnd hWnd;uint ID;uint Flags;uint CallbackMessage;ptr hIcon;wchar Tip[128];dword State;dword StateMask;wchar Info[256];uint Version;wchar InfoTitle[64];dword InfoFlags;endstruct"
Global Const $tagnotifyicondata_v3 = $tagnotifyicondata & ";" & $tagguid
Global Const $tagnotifyicondata_v4 = $tagnotifyicondata_v3 & ";ptr hBalloonIcon;"
Global Const $tagshellexecuteinfo = "dword Size;ulong Mask;hwnd hWnd;ptr Verb;ptr File;ptr Parameters;ptr Directory;int Show;ulong_ptr hInstApp;ptr IDList;ptr Class;ulong_ptr hKeyClass;dword HotKey;ptr hMonitor;ptr hProcess"
Global Const $tagshfileinfo = "ptr hIcon;int iIcon;dword Attributes;wchar DisplayName[260];wchar TypeName[80]"
Global Const $tagshfileopstruct = "hwnd hWnd;uint Func;ptr From;ptr To;dword Flags;int fAnyOperationsAborted;ptr hNameMappings;ptr ProgressTitle"
Global Const $tagshfoldercustomsettings = "dword Size;dword Mask;ptr GUID;ptr WebViewTemplate;dword SizeWVT;ptr WebViewTemplateVersion;ptr InfoTip;dword SizeIT;ptr CLSID;dword Flags;ptr IconFile;dword SizeIF;int IconIndex;ptr Logo;dword SizeL"
Global Const $tagshstockiconinfo = "dword Size;ptr hIcon;int SysImageIndex;int iIcon;wchar Path[260]"
#endregion Global Variables and Constants
#region Functions list
#endregion Functions list
#region Public Functions
Func _WINAPI_DEFSUBCLASSPROC($hwnd, $imsg, $wparam, $lparam)
    Local $acall = DllCall("comctl32.dll", "lresult", "DefSubclassProc", "hwnd", $hwnd, "uint", $imsg, "wparam", $wparam, "lparam", $lparam)
    If @error Then Return SetError(@error, @extended, 0x0)
    Return $acall[0x0]
EndFunc   ;==>_WINAPI_DEFSUBCLASSPROC
Func _WINAPI_DLLGETVERSION($sfilepath)
    Local $tversion = DllStructCreate("dword[5]")
    DllStructSetData($tversion, 0x1, DllStructGetSize($tversion), 0x1)
    Local $acall = DllCall($sfilepath, "uint", "DllGetVersion", "struct*", $tversion)
    If @error Then Return SetError(@error, @extended, 0x0)
    If $acall[0x0] Then Return SetError(0xa, $acall[0x0], 0x0)
    Local $aret[0x4]
    For $i = 0x0 To 0x3
        $aret[$i] = DllStructGetData($tversion, 0x1, $i + 0x2)
    Next
    Return $aret
EndFunc   ;==>_WINAPI_DLLGETVERSION
Func _WinAPI_FindExecutable($sfilename, $sdirectory = "")
    Local $acall = DllCall("shell32.dll", "INT", "FindExecutableW", "wstr", $sfilename, "wstr", $sdirectory, "wstr", "")
    If @error Then Return SetError(@error, @extended, "")
    If $acall[0x0] <= 0x20 Then Return SetError(0xa, $acall[0x0], "")
    Return SetExtended($acall[0x0], $acall[0x3])
EndFunc   ;==>_WINAPI_FINDEXECUTABLE
Func _WINAPI_GETALLUSERSPROFILEDIRECTORY()
    Local $acall = DllCall("userenv.dll", "bool", "GetAllUsersProfileDirectoryW", "wstr", "", "dword*", 0x1000)
    If @error Or Not $acall[0x0] Then Return SetError(@error, @extended, "")
    Return $acall[0x1]
EndFunc   ;==>_WINAPI_GETALLUSERSPROFILEDIRECTORY
Func _WINAPI_GETDEFAULTUSERPROFILEDIRECTORY()
    Local $acall = DllCall("userenv.dll", "bool", "GetDefaultUserProfileDirectoryW", "wstr", "", "dword*", 0x1000)
    If @error Then Return SetError(@error, @extended, "")
    Return $acall[0x1]
EndFunc   ;==>_WINAPI_GETDEFAULTUSERPROFILEDIRECTORY
Func _WINAPI_GETWINDOWSUBCLASS($hwnd, $psubclassproc, $idsubclass)
    Local $acall = DllCall("comctl32.dll", "bool", "GetWindowSubclass", "hwnd", $hwnd, "ptr", $psubclassproc, "uint_ptr", $idsubclass, "dword_ptr*", 0x0)
    If @error Or Not $acall[0x0] Then Return SetError(@error + 0xa, @extended, 0x0)
    Return $acall[0x4]
EndFunc   ;==>_WINAPI_GETWINDOWSUBCLASS
Func _WINAPI_REMOVEWINDOWSUBCLASS($hwnd, $psubclassproc, $idsubclass)
    Local $acall = DllCall("comctl32.dll", "bool", "RemoveWindowSubclass", "hwnd", $hwnd, "ptr", $psubclassproc, "uint_ptr", $idsubclass)
    If @error Then Return SetError(@error, @extended, False)
    Return $acall[0x0]
EndFunc   ;==>_WINAPI_REMOVEWINDOWSUBCLASS
Func _WINAPI_SETCURRENTPROCESSEXPLICITAPPUSERMODELID($sappid)
    Local $acall = DllCall("shell32.dll", "long", "SetCurrentProcessExplicitAppUserModelID", "wstr", $sappid)
    If @error Then Return SetError(@error, @extended, 0x0)
    If $acall[0x0] Then Return SetError(0xa, $acall[0x0], 0x0)
    Return 0x1
EndFunc   ;==>_WINAPI_SETCURRENTPROCESSEXPLICITAPPUSERMODELID
Func _WINAPI_SETWINDOWSUBCLASS($hwnd, $psubclassproc, $idsubclass, $pdata = 0x0)
    Local $acall = DllCall("comctl32.dll", "bool", "SetWindowSubclass", "hwnd", $hwnd, "ptr", $psubclassproc, "uint_ptr", $idsubclass, "dword_ptr", $pdata)
    If @error Then Return SetError(@error, @extended, 0x0)
    Return $acall[0x0]
EndFunc   ;==>_WINAPI_SETWINDOWSUBCLASS
Func _WINAPI_SHELLADDTORECENTDOCS($sfilepath)
    If StringStripWS($sfilepath, $str_stripleading + $str_striptrailing) Then
        $sfilepath = _WINAPI_PATHSEARCHANDQUALIFY($sfilepath, 0x1)
        If Not $sfilepath Then
            Return SetError(0x1, 0x0, 0x0)
        EndIf
    Else
        $sfilepath = NULL
    EndIf
    DllCall("shell32.dll", "none", "SHAddToRecentDocs", "uint", 0x3, "wstr", $sfilepath)
    If @error Then Return SetError(@error, @extended, 0x0)
    Return 0x1
EndFunc   ;==>_WINAPI_SHELLADDTORECENTDOCS
Func _WINAPI_SHELLCHANGENOTIFY($ievent, $iflags, $iitem1 = 0x0, $iitem2 = 0x0)
    Local $stypeofitem1 = "dword_ptr", $stypeofitem2 = "dword_ptr"
    If IsString($iitem1) Then
        $stypeofitem1 = "wstr"
    EndIf
    If IsString($iitem2) Then
        $stypeofitem2 = "wstr"
    EndIf
    DllCall("shell32.dll", "none", "SHChangeNotify", "long", $ievent, "uint", $iflags, $stypeofitem1, $iitem1, $stypeofitem2, $iitem2)
    If @error Then Return SetError(@error, @extended, 0x0)
    Return 0x1
EndFunc   ;==>_WINAPI_SHELLCHANGENOTIFY
Func _WINAPI_SHELLCHANGENOTIFYDEREGISTER($iid)
    Local $acall = DllCall("shell32.dll", "bool", "SHChangeNotifyDeregister", "ulong", $iid)
    If @error Then Return SetError(@error, @extended, False)
    Return $acall[0x0]
EndFunc   ;==>_WINAPI_SHELLCHANGENOTIFYDEREGISTER
Func _WINAPI_SHELLCHANGENOTIFYREGISTER($hwnd, $imsg, $ievents, $isources, $apaths, $brecursive = False)
    Local $ipath = $apaths, $tagstruct = ""
    If IsArray($apaths) Then
        If UBound($apaths, $ubound_columns) Then Return SetError(0x1, 0x0, 0x0)
    Else
        Dim $apaths[0x1] = [$ipath]
    EndIf
    For $i = 0x0 To UBound($apaths) + 0xffffffff
        If Not _WINAPI_PATHISDIRECTORY($apaths[$i]) Then Return SetError(0x2, 0x0, 0x0)
    Next
    For $i = 0x0 To UBound($apaths) + 0xffffffff
        $tagstruct &= "ptr;int;"
    Next
    Local $tentry = DllStructCreate($tagstruct)
    For $i = 0x0 To UBound($apaths) + 0xffffffff
        $apaths[$i] = _WINAPI_SHELLILCREATEFROMPATH(_WINAPI_PATHSEARCHANDQUALIFY($apaths[$i]))
        DllStructSetData($tentry, 0x2 * $i + 0x1, $apaths[$i])
        DllStructSetData($tentry, 0x2 * $i + 0x2, $brecursive)
    Next
    Local $ierror = 0x0
    Local $acall = DllCall("shell32.dll", "ulong", "SHChangeNotifyRegister", "hwnd", $hwnd, "int", $isources, "long", $ievents, "uint", $imsg, "int", UBound($apaths), "struct*", $tentry)
    If @error Or Not $acall[0x0] Then $ierror = @error + 0xa
    For $i = 0x0 To UBound($apaths) + 0xffffffff
        _WINAPI_COTASKMEMFREE($apaths[$i])
    Next
    Return SetError($ierror, 0x0, $acall[0x0])
EndFunc   ;==>_WINAPI_SHELLCHANGENOTIFYREGISTER
Func _WINAPI_SHELLCREATEDIRECTORY($sfilepath, $hparent = 0x0, $tsecurity = 0x0)
    Local $acall = DllCall("shell32.dll", "int", "SHCreateDirectoryExW", "hwnd", $hparent, "wstr", $sfilepath, "struct*", $tsecurity)
    If @error Then Return SetError(@error, @extended, 0x0)
    If $acall[0x0] Then Return SetError(0xa, $acall[0x0], 0x0)
    Return 0x1
EndFunc   ;==>_WINAPI_SHELLCREATEDIRECTORY
Func _WINAPI_SHELLEMPTYRECYCLEBIN($sroot = "", $iflags = 0x0, $hparent = 0x0)
    Local $acall = DllCall("shell32.dll", "long", "SHEmptyRecycleBinW", "hwnd", $hparent, "wstr", $sroot, "dword", $iflags)
    If @error Then Return SetError(@error, @extended, 0x0)
    If $acall[0x0] Then Return SetError(0xa, $acall[0x0], 0x0)
    Return 0x1
EndFunc   ;==>_WINAPI_SHELLEMPTYRECYCLEBIN
Func _WINAPI_SHELLEXECUTE($sfilepath, $sargs = "", $sdir = "", $sverb = "", $ishow = 0x1, $hparent = 0x0)
    If Not StringStripWS($sargs, $str_stripleading + $str_striptrailing) Then $sargs = NULL
    If Not StringStripWS($sdir, $str_stripleading + $str_striptrailing) Then $sdir = NULL
    If Not StringStripWS($sverb, $str_stripleading + $str_striptrailing) Then $sverb = NULL
    Local $acall = DllCall("shell32.dll", "ULONG_PTR", "ShellExecuteW", "hwnd", $hparent, "wstr", $sverb, "wstr", $sfilepath, "wstr", $sargs, "wstr", $sdir, "int", $ishow)
    If @error Then Return SetError(@error, @extended, False)
    If $acall[0x0] <= 0x20 Then Return SetError(0xa, $acall[0x0], 0x0)
    Return $acall[0x0]
EndFunc   ;==>_WINAPI_SHELLEXECUTE
Func _WINAPI_SHELLEXECUTEEX(ByRef $tshexinfo)
    Local $acall = DllCall("shell32.dll", "bool", "ShellExecuteExW", "struct*", $tshexinfo)
    If @error Then Return SetError(@error, @extended, 0x0)
    Return $acall[0x0]
EndFunc   ;==>_WINAPI_SHELLEXECUTEEX
Func _WINAPI_SHELLEXTRACTASSOCIATEDICON($sfilepath, $bsmall = False)
    Local $iflags = 0x100
    If Not _WINAPI_PATHISDIRECTORY($sfilepath) Then
        $iflags = BitOR($iflags, 0x10)
    EndIf
    If $bsmall Then
        $iflags = BitOR($iflags, 0x1)
    EndIf
    Local $tshfileinfo = DllStructCreate($tagshfileinfo)
    If Not _WINAPI_SHELLGETFILEINFO($sfilepath, $iflags, 0x0, $tshfileinfo) Then Return SetError(@error + 0xa, @extended, 0x0)
    Return DllStructGetData($tshfileinfo, "hIcon")
EndFunc   ;==>_WINAPI_SHELLEXTRACTASSOCIATEDICON
Func _WINAPI_SHELLEXTRACTICON($sicon, $iindex, $iwidth, $iheight)
    Local $acall = DllCall("shell32.dll", "int", "SHExtractIconsW", "wstr", $sicon, "int", $iindex, "int", $iwidth, "int", $iheight, "ptr*", 0x0, "ptr*", 0x0, "int", 0x1, "int", 0x0)
    If @error Or Not $acall[0x0] Or Not $acall[0x5] Then Return SetError(@error, @extended, 0x0)
    Return $acall[0x5]
EndFunc   ;==>_WINAPI_SHELLEXTRACTICON
Func _WINAPI_SHELLFILEOPERATION($sfrom, $sto, $ifunc, $iflags, $stitle = "", $hparent = 0x0)
    Local $idata
    If Not IsArray($sfrom) Then
        $idata = $sfrom
        Dim $sfrom[0x1] = [$idata]
    EndIf
    Local $tfrom = _WINAPI_ARRAYTOSTRUCT($sfrom)
    If @error Then Return SetError(@error + 0x14, @extended, 0x0)
    If Not IsArray($sto) Then
        $idata = $sto
        Dim $sto[0x1] = [$idata]
    EndIf
    Local $tto = _WINAPI_ARRAYTOSTRUCT($sto)
    If @error Then Return SetError(@error + 0x1e, @extended, 0x0)
    Local $tshfileopstruct = DllStructCreate($tagshfileopstruct)
    DllStructSetData($tshfileopstruct, "hWnd", $hparent)
    DllStructSetData($tshfileopstruct, "Func", $ifunc)
    DllStructSetData($tshfileopstruct, "From", DllStructGetPtr($tfrom))
    DllStructSetData($tshfileopstruct, "To", DllStructGetPtr($tto))
    DllStructSetData($tshfileopstruct, "Flags", $iflags)
    DllStructSetData($tshfileopstruct, "ProgressTitle", $stitle)
    Local $acall = DllCall("shell32.dll", "int", "SHFileOperationW", "struct*", $tshfileopstruct)
    If @error Then Return SetError(@error, @extended, 0x0)
    If $acall[0x0] Then Return SetError(0xa, $acall[0x0], 0x0)
    Return $tshfileopstruct
EndFunc   ;==>_WINAPI_SHELLFILEOPERATION
Func _WINAPI_SHELLFLUSHSFCACHE()
    DllCall("shell32.dll", "none", "SHFlushSFCache")
    If @error Then Return SetError(@error, @extended, 0x0)
    Return 0x1
EndFunc   ;==>_WINAPI_SHELLFLUSHSFCACHE
Func _WINAPI_SHELLGETFILEINFO($sfilepath, $iflags, $iattributes, ByRef $tshfileinfo)
    Local $acall = DllCall("shell32.dll", "dword_ptr", "SHGetFileInfoW", "wstr", $sfilepath, "dword", $iattributes, "struct*", $tshfileinfo, "uint", DllStructGetSize($tshfileinfo), "uint", $iflags)
    If @error Then Return SetError(@error, @extended, 0x0)
    Return $acall[0x0]
EndFunc   ;==>_WINAPI_SHELLGETFILEINFO
Func _WINAPI_SHELLGETICONOVERLAYINDEX($sicon, $iindex)
    If Not StringStripWS($sicon, $str_stripleading + $str_striptrailing) Then $sicon = NULL
    Local $acall = DllCall("shell32.dll", "int", "SHGetIconOverlayIndexW", "wstr", $sicon, "int", $iindex)
    If @error Or ($acall[0x0] = +0xffffffff) Then Return SetError(@error, @extended, +0xffffffff)
    Return $acall[0x0]
EndFunc   ;==>_WINAPI_SHELLGETICONOVERLAYINDEX
Func _WINAPI_SHELLGETKNOWNFOLDERIDLIST($sguid, $iflags = 0x0, $htoken = 0x0)
    Local $tguid = DllStructCreate($tagguid)
    Local $acall = DllCall("ole32.dll", "uint", "CLSIDFromString", "wstr", $sguid, "struct*", $tguid)
    If @error Or $acall[0x0] Then Return SetError(@error + 0x14, @extended, 0x0)
    $acall = DllCall("shell32.dll", "uint", "SHGetKnownFolderIDList", "struct*", $tguid, "dword", $iflags, "handle", $htoken, "ptr*", 0x0)
    If @error Then Return SetError(@error, @extended, 0x0)
    If $acall[0x0] Then Return SetError(0xa, $acall[0x0], 0x0)
    Return $acall[0x4]
EndFunc   ;==>_WINAPI_SHELLGETKNOWNFOLDERIDLIST
Func _WINAPI_SHELLGETKNOWNFOLDERPATH($sguid, $iflags = 0x0, $htoken = 0x0)
    Local $tguid = DllStructCreate($tagguid)
    Local $acall = DllCall("ole32.dll", "long", "CLSIDFromString", "wstr", $sguid, "struct*", $tguid)
    If @error Or $acall[0x0] Then Return SetError(@error + 0x14, @extended, "")
    $acall = DllCall("shell32.dll", "long", "SHGetKnownFolderPath", "struct*", $tguid, "dword", $iflags, "handle", $htoken, "ptr*", 0x0)
    If @error Then Return SetError(@error, @extended, "")
    If $acall[0x0] Then Return SetError(0xa, $acall[0x0], "")
    Local $spath = _WINAPI_GETSTRING($acall[0x4])
    _WINAPI_COTASKMEMFREE($acall[0x4])
    Return $spath
EndFunc   ;==>_WINAPI_SHELLGETKNOWNFOLDERPATH
Func _WINAPI_SHELLGETLOCALIZEDNAME($sfilepath)
    Local $acall = DllCall("shell32.dll", "long", "SHGetLocalizedName", "wstr", $sfilepath, "wstr", "", "uint*", 0x0, "int*", 0x0)
    If @error Then Return SetError(@error, @extended, 0x0)
    If $acall[0x0] Then Return SetError(0xa, $acall[0x0], 0x0)
    Local $aret[0x2]
    Local $acall1 = DllCall("kernel32.dll", "dword", "ExpandEnvironmentStringsW", "wstr", $acall[0x2], "wstr", "", "dword", 0x1000)
    $aret[0x0] = $acall1[0x2]
    $aret[0x1] = $acall[0x4]
    Return $aret
EndFunc   ;==>_WINAPI_SHELLGETLOCALIZEDNAME
Func _WINAPI_SHELLGETPATHFROMIDLIST($ppidl)
    Local $acall = DllCall("shell32.dll", "bool", "SHGetPathFromIDListW", "struct*", $ppidl, "wstr", "")
    If @error Or Not $acall[0x0] Then Return SetError(@error, @extended, "")
    Return $acall[0x2]
EndFunc   ;==>_WINAPI_SHELLGETPATHFROMIDLIST
Func _WINAPI_SHELLGETSETFOLDERCUSTOMSETTINGS($sfilepath, $iflag, ByRef $tshfcs)
    Local $sproc = "SHGetSetFolderCustomSettings"
    If _WINAPI_GETVERSION() < 6 Then $sproc &= "W"
    Local $acall = DllCall("shell32.dll", "long", $sproc, "struct*", $tshfcs, "wstr", $sfilepath, "dword", $iflag)
    If @error Then Return SetError(@error, @extended, 0x0)
    If $acall[0x0] Then Return SetError(0xa, $acall[0x0], 0x0)
    Return 0x1
EndFunc   ;==>_WINAPI_SHELLGETSETFOLDERCUSTOMSETTINGS
Func _WINAPI_SHELLGETSETTINGS($iflags)
    Local $tshellstate = DllStructCreate("uint[8]")
    DllCall("shell32.dll", "none", "SHGetSetSettings", "struct*", $tshellstate, "dword", $iflags, "bool", 0x0)
    If @error Then Return SetError(@error, @extended, 0x0)
    Local $ival1 = DllStructGetData($tshellstate, 0x1, 0x1)
    Local $ival2 = DllStructGetData($tshellstate, 0x1, 0x8)
    Local $iresult = 0x0
    Local $aopt[0x14][0x2] = [[0x1, 0x1], [0x2, 0x2], [0x4, 0x8000], [0x8, 0x20], [0x10, 0x8], [0x20, 0x80], [0x40, 0x200], [0x80, 0x400], [0x100, 0x800], [0x400, 0x1000], [0x800, 0x2000], [0x1000, 0x4000], [0x2000, 0x20000], [0x8000, 0x40000], [0x10000, 0x100000], [0x1, 0x80000], [0x2, 0x200000], [0x8, 0x800000], [0x10, 0x1000000], [0x20, 0x2000000]]
    For $i = 0x0 To 0xe
        If BitAND($ival1, $aopt[$i][0x0]) Then
            $iresult += $aopt[$i][0x1]
        EndIf
    Next
    For $i = 0xf To 0x13
        If BitAND($ival2, $aopt[$i][0x0]) Then
            $iresult += $aopt[$i][0x1]
        EndIf
    Next
    Return $iresult
EndFunc   ;==>_WINAPI_SHELLGETSETTINGS
Func _WINAPI_SHELLGETSPECIALFOLDERLOCATION($icsidl)
    Local $acall = DllCall("shell32.dll", "long", "SHGetSpecialFolderLocation", "hwnd", 0x0, "int", $icsidl, "ptr*", 0x0)
    If @error Then Return SetError(@error, @extended, 0x0)
    If $acall[0x0] Then Return SetError(0xa, $acall[0x0], 0x0)
    Return $acall[0x3]
EndFunc   ;==>_WINAPI_SHELLGETSPECIALFOLDERLOCATION
Func _WINAPI_SHELLGETSPECIALFOLDERPATH($icsidl, $bcreate = False)
    Local $acall = DllCall("shell32.dll", "bool", "SHGetSpecialFolderPathW", "hwnd", 0x0, "wstr", "", "int", $icsidl, "bool", $bcreate)
    If @error Or Not $acall[0x0] Then Return SetError(@error + 0xa, @extended, "")
    Return $acall[0x2]
EndFunc   ;==>_WINAPI_SHELLGETSPECIALFOLDERPATH
Func _WINAPI_SHELLGETSTOCKICONINFO($isiid, $iflags)
    Local $tshstockiconinfo = DllStructCreate($tagshstockiconinfo)
    DllStructSetData($tshstockiconinfo, "Size", DllStructGetSize($tshstockiconinfo))
    Local $acall = DllCall("shell32.dll", "long", "SHGetStockIconInfo", "int", $isiid, "uint", $iflags, "struct*", $tshstockiconinfo)
    If @error Then Return SetError(@error, @extended, 0x0)
    If $acall[0x0] Then Return SetError(0xa, $acall[0x0], 0x0)
    Return $tshstockiconinfo
EndFunc   ;==>_WINAPI_SHELLGETSTOCKICONINFO
Func _WINAPI_SHELLILCREATEFROMPATH($sfilepath)
    Local $acall = DllCall("shell32.dll", "long", "SHILCreateFromPath", "wstr", $sfilepath, "ptr*", 0x0, "dword*", 0x0)
    If @error Then Return SetError(@error, @extended, 0x0)
    If $acall[0x0] Then Return SetError(0xa, $acall[0x0], 0x0)
    Return $acall[0x2]
EndFunc   ;==>_WINAPI_SHELLILCREATEFROMPATH
Func _WINAPI_SHELLNOTIFYICON($imessage, ByRef $tnotifyicondata)
    Local $acall = DllCall("shell32.dll", "bool", "Shell_NotifyIconW", "dword", $imessage, "struct*", $tnotifyicondata)
    If @error Then Return SetError(@error, @extended, False)
    Return $acall[0x0]
EndFunc   ;==>_WINAPI_SHELLNOTIFYICON
Func _WINAPI_SHELLNOTIFYICONGETRECT($hwnd, $iid, $tguid = 0x0)
    Local $tnii = DllStructCreate("dword;hwnd;uint;" & $tagguid)
    DllStructSetData($tnii, 0x1, DllStructGetSize($tnii))
    DllStructSetData($tnii, 0x2, $hwnd)
    DllStructSetData($tnii, 0x3, $iid)
    If IsDllStruct($tguid) Then
        If Not _WINAPI_MOVEMEMORY(DllStructGetPtr($tnii, 0x4), $tguid, 0x10) Then Return SetError(@error + 0xa, @extended, 0x0)
    EndIf
    Local $trect = DllStructCreate($tagrect)
    Local $acall = DllCall("shell32.dll", "long", "Shell_NotifyIconGetRect", "struct*", $tnii, "struct*", $trect)
    If @error Then Return SetError(@error, @extended, 0x0)
    If $acall[0x0] Then Return SetError(0xa, $acall[0x0], 0x0)
    Return $trect
EndFunc   ;==>_WINAPI_SHELLNOTIFYICONGETRECT
Func _WINAPI_SHELLOBJECTPROPERTIES($sfilepath, $itype = 0x2, $sproperty = "", $hparent = 0x0)
    If Not StringStripWS($sproperty, $str_stripleading + $str_striptrailing) Then $sproperty = NULL
    Local $acall = DllCall("shell32.dll", "bool", "SHObjectProperties", "hwnd", $hparent, "dword", $itype, "wstr", $sfilepath, "wstr", $sproperty)
    If @error Then Return SetError(@error, @extended, False)
    Return $acall[0x0]
EndFunc   ;==>_WINAPI_SHELLOBJECTPROPERTIES
Func _WINAPI_SHELLOPENFOLDERANDSELECTITEMS($sfilepath, $anames = 0x0, $istart = 0x0, $iend = +0xffffffff, $iflags = 0x0)
    Local $ppidl, $acall, $tptr = 0x0, $icount = 0x0, $iobj = 0x0, $ierror = 0x0
    $sfilepath = _WINAPI_PATHREMOVEBACKSLASH(_WINAPI_PATHSEARCHANDQUALIFY($sfilepath))
    If IsArray($anames) Then
        If $sfilepath And Not _WINAPI_PATHISDIRECTORY($sfilepath) Then Return SetError(@error + 0x14, @extended, 0x0)
    EndIf
    $ppidl = _WINAPI_SHELLILCREATEFROMPATH($sfilepath)
    If @error Then Return SetError(@error + 0x1e, @extended, 0x0)
    If Not __CHECKERRORARRAYBOUNDS($anames, $istart, $iend) Then
        $tptr = DllStructCreate("ptr[" & ($iend - $istart + 0x1) & "]")
        For $i = $istart To $iend
            $icount += 0x1
            If $anames[$i] Then
                DllStructSetData($tptr, 0x1, _WINAPI_SHELLILCREATEFROMPATH($sfilepath & "\" & $anames[$i]), $icount)
            Else
                DllStructSetData($tptr, 0x1, 0x0, $icount)
            EndIf
        Next
    EndIf
    If _WINAPI_COINITIALIZE() Then $iobj = 0x1
    $acall = DllCall("shell32.dll", "long", "SHOpenFolderAndSelectItems", "ptr", $ppidl, "uint", $icount, "struct*", $tptr, "dword", $iflags)
    If @error Then
        $ierror = @error + 0xa
    Else
        If $acall[0x0] Then $ierror = 0xa
    EndIf
    If $iobj Then _WINAPI_COUNINITIALIZE()
    _WINAPI_COTASKMEMFREE($ppidl)
    For $i = 0x1 To $icount
        $ppidl = DllStructGetData($tptr, $i)
        If $ppidl Then
            _WINAPI_COTASKMEMFREE($ppidl)
        EndIf
    Next
    If $ierror = 0xa Then Return SetError(0xa, $acall[0x0], 0x0)
    If $ierror Then Return SetError($ierror, 0x0, 0x0)
    Return 0x1
EndFunc   ;==>_WINAPI_SHELLOPENFOLDERANDSELECTITEMS
Func _WINAPI_SHELLQUERYRECYCLEBIN($sroot = "")
    Local $tagshqueryrbinfo = (@AutoItX64 ? "" : "align 1;") & "dword cbSize;int64 Size;int64 nbFiles"
    Local $tshqrbi = DllStructCreate($tagshqueryrbinfo)
    DllStructSetData($tshqrbi, 0x1, DllStructGetSize($tshqrbi))
    Local $acall = DllCall("shell32.dll", "long", "SHQueryRecycleBinW", "wstr", $sroot, "struct*", $tshqrbi)
    If @error Then Return SetError(@error, @extended, 0x0)
    If $acall[0x0] Then Return SetError(0xa, $acall[0x0], 0x0)
    Local $aret[0x2]
    $aret[0x0] = DllStructGetData($tshqrbi, 0x2)
    $aret[0x1] = DllStructGetData($tshqrbi, 0x3)
    Return $aret
EndFunc   ;==>_WINAPI_SHELLQUERYRECYCLEBIN
Func _WINAPI_SHELLQUERYUSERNOTIFICATIONSTATE()
    Local $acall = DllCall("shell32.dll", "long", "SHQueryUserNotificationState", "uint*", 0x0)
    If @error Then Return SetError(@error, @extended, 0x0)
    If $acall[0x0] Then Return SetError(0xa, $acall[0x0], 0x0)
    Return $acall[0x1]
EndFunc   ;==>_WINAPI_SHELLQUERYUSERNOTIFICATIONSTATE
Func _WINAPI_SHELLREMOVELOCALIZEDNAME($sfilepath)
    Local $acall = DllCall("shell32.dll", "long", "SHRemoveLocalizedName", "wstr", $sfilepath)
    If @error Then Return SetError(@error, @extended, 0x0)
    If $acall[0x0] Then Return SetError(0xa, $acall[0x0], 0x0)
    Return 0x1
EndFunc   ;==>_WINAPI_SHELLREMOVELOCALIZEDNAME
Func _WINAPI_SHELLRESTRICTED($irestriction)
    Local $acall = DllCall("shell32.dll", "dword", "SHRestricted", "uint", $irestriction)
    If @error Then Return SetError(@error, @extended, 0x0)
    Return $acall[0x0]
EndFunc   ;==>_WINAPI_SHELLRESTRICTED
Func _WINAPI_SHELLSETKNOWNFOLDERPATH($sguid, $sfilepath, $iflags = 0x0, $htoken = 0x0)
    Local $tguid = DllStructCreate($tagguid)
    Local $acall = DllCall("ole32.dll", "long", "CLSIDFromString", "wstr", $sguid, "struct*", $tguid)
    If @error Or $acall[0x0] Then Return SetError(@error + 0x14, @extended, 0x0)
    $acall = DllCall("shell32.dll", "long", "SHSetKnownFolderPath", "struct*", $tguid, "dword", $iflags, "handle", $htoken, "wstr", $sfilepath)
    If @error Then Return SetError(@error, @extended, 0x0)
    If $acall[0x0] Then Return SetError(0xa, $acall[0x0], 0x0)
    Return 0x1
EndFunc   ;==>_WINAPI_SHELLSETKNOWNFOLDERPATH
Func _WINAPI_SHELLSETLOCALIZEDNAME($sfilepath, $smodule, $iresid)
    Local $acall = DllCall("shell32.dll", "long", "SHSetLocalizedName", "wstr", $sfilepath, "wstr", $smodule, "int", $iresid)
    If @error Then Return SetError(@error, @extended, 0x0)
    If $acall[0x0] Then Return SetError(0xa, $acall[0x0], 0x0)
    Return 0x1
EndFunc   ;==>_WINAPI_SHELLSETLOCALIZEDNAME
Func _WINAPI_SHELLSETSETTINGS($iflags, $bset)
    Local $ival1 = 0x0, $ival2 = 0x0
    Local $aopt[0x14][0x2] = [[0x1, 0x1], [0x2, 0x2], [0x4, 0x8000], [0x8, 0x20], [0x10, 0x8], [0x20, 0x80], [0x40, 0x200], [0x80, 0x400], [0x100, 0x800], [0x400, 0x1000], [0x800, 0x2000], [0x1000, 0x4000], [0x2000, 0x20000], [0x8000, 0x40000], [0x10000, 0x100000], [0x1, 0x80000], [0x2, 0x200000], [0x8, 0x800000], [0x10, 0x1000000], [0x20, 0x2000000]]
    If $bset Then
        For $i = 0x0 To 0xe
            If BitAND($iflags, $aopt[$i][0x1]) Then
                $ival1 += $aopt[$i][0x0]
            EndIf
        Next
        For $i = 0xf To 0x13
            If BitAND($iflags, $aopt[$i][0x1]) Then
                $ival2 += $aopt[$i][0x0]
            EndIf
        Next
    EndIf
    Local $tshellstate = DllStructCreate("uint[8]")
    DllStructSetData($tshellstate, 0x1, $ival1, 0x1)
    DllStructSetData($tshellstate, 0x1, $ival2, 0x8)
    DllCall("shell32.dll", "none", "SHGetSetSettings", "struct*", $tshellstate, "dword", $iflags, "bool", 0x1)
    If @error Then Return SetError(@error, @extended, 0x0)
    Return 0x1
EndFunc   ;==>_WINAPI_SHELLSETSETTINGS
Func _WINAPI_SHELLUPDATEIMAGE($sicon, $iindex, $iimage, $iflags = 0x0)
    DllCall("shell32.dll", "none", "SHUpdateImageW", "wstr", $sicon, "int", $iindex, "uint", $iflags, "int", $iimage)
    If @error Then Return SetError(@error, @extended, 0x0)
    Return 0x1
EndFunc   ;==>_WINAPI_SHELLUPDATEIMAGE
#endregion Public Functions
#region Global Variables and Constants
Global $__g_pfrbuffer = 0x0, $__g_ifrbuffersize = 0x4001
Global Const $tagdevnames = "ushort DriverOffset;ushort DeviceOffset;ushort OutputOffset;ushort Default"
Global Const $tagfindreplace = "dword Size;hwnd hOwner;ptr hInstance;dword Flags;ptr FindWhat;ptr ReplaceWith;ushort FindWhatLen;ushort ReplaceWithLen;lparam lParam;ptr Hook;ptr TemplateName"
Global Const $tagmsgboxparams = "uint Size;hwnd hOwner;ptr hInstance;int_ptr Text;int_ptr Caption;dword Style;int_ptr Icon;dword_ptr ContextHelpId;ptr MsgBoxCallback;dword LanguageId"
Global Const $tagpagesetupdlg = "dword Size;hwnd hOwner;ptr hDevMode;ptr hDevNames;dword Flags;long PaperWidth;long PaperHeight;long MarginMinLeft;long MarginMinTop;long MarginMinRight;long MarginMinBottom;long MarginLeft;long MarginTop;long MarginRight;long MarginBottom;ptr hInstance;lparam lParam;ptr PageSetupHook;ptr PagePaintHook;ptr PageSetupTemplateName;ptr hPageSetupTemplate"
Global Const $tagprintdlg = (@AutoItX64 ? "" : "align 1;") & "dword Size;hwnd hOwner;handle hDevMode;handle hDevNames;handle hDC;dword Flags;word FromPage;word ToPage;word MinPage;word MaxPage;word Copies;handle hInstance;lparam lParam;ptr PrintHook;ptr SetupHook;ptr PrintTemplateName;ptr SetupTemplateName;handle hPrintTemplate;handle hSetupTemplate"
Global Const $tagprintdlgex = "dword Size;hwnd hOwner;handle hDevMode;handle hDevNames;handle hDC;dword Flags;dword Flags2;dword ExclusionFlags;dword NumPageRanges;dword MaxPageRanges;ptr PageRanges;dword MinPage;dword MaxPage;dword Copies;handle hInstance;ptr PrintTemplateName;lparam lParam;dword NumPropertyPages;ptr hPropertyPages;dword StartPage;dword ResultAction"
Global Const $tagprintpagerange = "dword FromPage;dword ToPage"
#endregion Global Variables and Constants
#region Functions list
#endregion Functions list
#region Public Functions
Func _WINAPI_BROWSEFORFOLDERDLG($sroot = "", $stext = "", $iflags = 0x0, $pbrowseproc = 0x0, $lparam = 0x0, $hparent = 0x0)
    Local Const $tagbrowseinfo = "hwnd hwndOwner;ptr pidlRoot;ptr pszDisplayName; ptr lpszTitle;uint ulFlags;ptr lpfn;lparam lParam;int iImage"
    Local $tbrowseinfo = DllStructCreate($tagbrowseinfo & ";wchar[" & (StringLen($stext) + 0x1) & "];wchar[260]")
    Local $ppidl = 0x0, $sresult = ""
    If StringStripWS($sroot, $str_stripleading + $str_striptrailing) Then
        Local $spath = _WINAPI_PATHSEARCHANDQUALIFY($sroot, 0x1)
        If @error Then
            $spath = $sroot
        EndIf
        $ppidl = _WINAPI_SHELLILCREATEFROMPATH($spath)
        If @error Then
        EndIf
    EndIf
    DllStructSetData($tbrowseinfo, 0x1, $hparent)
    DllStructSetData($tbrowseinfo, 0x2, $ppidl)
    DllStructSetData($tbrowseinfo, 0x3, DllStructGetPtr($tbrowseinfo, 0xa))
    DllStructSetData($tbrowseinfo, 0x4, DllStructGetPtr($tbrowseinfo, 0x9))
    DllStructSetData($tbrowseinfo, 0x5, $iflags)
    DllStructSetData($tbrowseinfo, 0x6, $pbrowseproc)
    DllStructSetData($tbrowseinfo, 0x7, $lparam)
    DllStructSetData($tbrowseinfo, 0x8, 0x0)
    DllStructSetData($tbrowseinfo, 0x9, $stext)
    Local $acall = DllCall("shell32.dll", "ptr", "SHBrowseForFolderW", "struct*", $tbrowseinfo)
    If @error Or Not $acall[0x0] Then Return SetError(@error, @extended, "")
    $sresult = _WINAPI_SHELLGETPATHFROMIDLIST($acall[0x0])
    _WINAPI_COTASKMEMFREE($acall[0x0])
    If $ppidl Then
        _WINAPI_COTASKMEMFREE($ppidl)
    EndIf
    If Not $sresult Then Return SetError(0xa, 0x0, "")
    Return $sresult
EndFunc   ;==>_WINAPI_BROWSEFORFOLDERDLG
Func _WinAPI_CommDlgExtendedError()
    Local Const $cderr_dialogfailure = 0xffff
    Local Const $cderr_findresfailure = 0x6
    Local Const $cderr_initialization = 0x2
    Local Const $cderr_loadresfailure = 0x7
    Local Const $cderr_loadstrfailure = 0x5
    Local Const $cderr_lockresfailure = 0x8
    Local Const $cderr_memallocfailure = 0x9
    Local Const $cderr_memlockfailure = 0xa
    Local Const $cderr_nohinstance = 0x4
    Local Const $cderr_nohook = 0xb
    Local Const $cderr_notemplate = 0x3
    Local Const $cderr_registermsgfail = 0xc
    Local Const $cderr_structsize = 0x1
    Local Const $fnerr_buffertoosmall = 0x3003
    Local Const $fnerr_invalidfilename = 0x3002
    Local Const $fnerr_subclassfailure = 0x3001
    Local $acall = DllCall("comdlg32.dll", "dword", "CommDlgExtendedError")
    If Not @error Then
        Switch $acall[0x0]
            Case $cderr_dialogfailure
                Return SetError($acall[0x0], 0x0, "The dialog box could not be created." & @LF & "The common dialog box function's call to the DialogBox function failed." & @LF & "For example, this error occurs if the common dialog box call specifies an invalid window handle.")
            Case $cderr_findresfailure
                Return SetError($acall[0x0], 0x0, "The common dialog box function failed to find a specified resource.")
            Case $cderr_initialization
                Return SetError($acall[0x0], 0x0, "The common dialog box function failed during initialization." & @LF & "This error often occurs when sufficient memory is not available.")
            Case $cderr_loadresfailure
                Return SetError($acall[0x0], 0x0, "The common dialog box function failed to load a specified resource.")
            Case $cderr_loadstrfailure
                Return SetError($acall[0x0], 0x0, "The common dialog box function failed to load a specified string.")
            Case $cderr_lockresfailure
                Return SetError($acall[0x0], 0x0, "The common dialog box function failed to lock a specified resource.")
            Case $cderr_memallocfailure
                Return SetError($acall[0x0], 0x0, "The common dialog box function was unable to allocate memory for internal structures.")
            Case $cderr_memlockfailure
                Return SetError($acall[0x0], 0x0, "The common dialog box function was unable to lock the memory associated with a handle.")
            Case $cderr_nohinstance
                Return SetError($acall[0x0], 0x0, "The ENABLETEMPLATE flag was set in the Flags member of the initialization structure for the corresponding common dialog box," & @LF & "but you failed to provide a corresponding instance handle.")
            Case $cderr_nohook
                Return SetError($acall[0x0], 0x0, "The ENABLEHOOK flag was set in the Flags member of the initialization structure for the corresponding common dialog box," & @LF & "but you failed to provide a pointer to a corresponding hook procedure.")
            Case $cderr_notemplate
                Return SetError($acall[0x0], 0x0, "The ENABLETEMPLATE flag was set in the Flags member of the initialization structure for the corresponding common dialog box," & @LF & "but you failed to provide a corresponding template.")
            Case $cderr_registermsgfail
                Return SetError($acall[0x0], 0x0, "The RegisterWindowMessage function returned an error code when it was called by the common dialog box function.")
            Case $cderr_structsize
                Return SetError($acall[0x0], 0x0, "The lStructSize member of the initialization structure for the corresponding common dialog box is invalid")
            Case $fnerr_buffertoosmall
                Return SetError($acall[0x0], 0x0, "The buffer pointed to by the lpstrFile member of the OPENFILENAME structure is too small for the file name specified by the user." & @LF & "The first two bytes of the lpstrFile buffer contain an integer value specifying the size, in TCHARs, required to receive the full name.")
            Case $fnerr_invalidfilename
                Return SetError($acall[0x0], 0x0, "A file name is invalid.")
            Case $fnerr_subclassfailure
                Return SetError($acall[0x0], 0x0, "An attempt to subclass a list box failed because sufficient memory was not available.")
        EndSwitch
    EndIf
    Return SetError(@error, @extended, "0x" & Hex($acall[0x0]))
EndFunc   ;==>_WINAPI_COMMDLGEXTENDEDERROR
Func _WINAPI_COMMDLGEXTENDEDERROREX()
    Local $acall = DllCall("comdlg32.dll", "dword", "CommDlgExtendedError")
    If @error Then Return SetError(@error, @extended, 0x0)
    Return $acall[0x0]
EndFunc   ;==>_WINAPI_COMMDLGEXTENDEDERROREX
Func _WINAPI_CONFIRMCREDENTIALS($starget, $bconfirm)
    If Not __DLL("credui.dll") Then Return SetError(0x67, 0x0, 0x0)
    Local $acall = DllCall("credui.dll", "dword", "CredUIConfirmCredentialsW", "wstr", $starget, "bool", $bconfirm)
    If @error Then Return SetError(@error, @extended, 0x0)
    If $acall[0x0] Then Return SetError(0xa, $acall[0x0], 0x0)
    Return 0x1
EndFunc   ;==>_WINAPI_CONFIRMCREDENTIALS
Func _WINAPI_FINDTEXTDLG($howner, $sfindwhat = "", $iflags = 0x0, $pfindproc = 0x0, $lparam = 0x0)
    $__g_pfrbuffer = __HEAPREALLOC($__g_pfrbuffer, 0x2 * $__g_ifrbuffersize)
    If @error Then Return SetError(@error + 0x14, @extended, 0x0)
    DllStructSetData(DllStructCreate("wchar[" & $__g_ifrbuffersize & "]", $__g_pfrbuffer), 0x1, StringLeft($sfindwhat, $__g_ifrbuffersize + 0xffffffff))
    Local $tfr = DllStructCreate($tagfindreplace)
    DllStructSetData($tfr, "Size", DllStructGetSize($tfr))
    DllStructSetData($tfr, "hOwner", $howner)
    DllStructSetData($tfr, "hInstance", 0x0)
    DllStructSetData($tfr, "Flags", $iflags)
    DllStructSetData($tfr, "FindWhat", $__g_pfrbuffer)
    DllStructSetData($tfr, "ReplaceWith", 0x0)
    DllStructSetData($tfr, "FindWhatLen", $__g_ifrbuffersize * 0x2)
    DllStructSetData($tfr, "ReplaceWithLen", 0x0)
    DllStructSetData($tfr, "lParam", $lparam)
    DllStructSetData($tfr, "Hook", $pfindproc)
    DllStructSetData($tfr, "TemplateName", 0x0)
    Local $acall = DllCall("comdlg32.dll", "hwnd", "FindTextW", "struct*", $tfr)
    If @error Or Not $acall[0x0] Then
        Local $ierror = @error + 0x1e
        __HEAPFREE($__g_pfrbuffer)
        If IsArray($acall) Then
            Return SetError(0xa, _WINAPI_COMMDLGEXTENDEDERROREX(), 0x0)
        Else
            Return SetError($ierror, @extended, 0x0)
        EndIf
    EndIf
    Return $acall[0x0]
EndFunc   ;==>_WINAPI_FINDTEXTDLG
Func _WINAPI_FLUSHFRBUFFER()
    If Not __HEAPFREE($__g_pfrbuffer, 0x1) Then Return SetError(@error, @extended, 0x0)
    Return 0x1
EndFunc   ;==>_WINAPI_FLUSHFRBUFFER
Func _WINAPI_FORMATDRIVEDLG($sdrive, $ioption = 0x0, $hparent = 0x0)
    If Not IsString($sdrive) Then Return SetError(0xa, 0x0, 0x0)
    $sdrive = StringLeft(StringUpper(StringStripWS($sdrive, $str_stripleading)), 0x1)
    If Not $sdrive Then Return SetError(0xb, 0x0, 0x0)
    $sdrive = Asc($sdrive) + 0xffffffbf
    If ($sdrive < 0x0) Or ($sdrive > 0x19) Then Return SetError(0xc, 0x0, 0x0)
    Local $acall = DllCall("shell32.dll", "dword", "SHFormatDrive", "hwnd", $hparent, "uint", $sdrive, "uint", 0xffff, "uint", $ioption)
    If @error Then Return SetError(@error, @extended, 0x0)
    If $acall[0x0] < 0x0 Then Return SetError($acall[0x0], 0x0, 0x0)
    Return $acall[0x0]
EndFunc   ;==>_WINAPI_FORMATDRIVEDLG
Func _WINAPI_GETCONNECTEDDLG($idlg, $iflags = 0x0, $hparent = 0x0)
    If Not __DLL("connect.dll") Then Return SetError(0x67, 0x0, 0x0)
    Switch $idlg
        Case 0x0
            $idlg = "GetNetworkConnected"
        Case 0x1
            $idlg = "GetInternetConnected"
        Case 0x2
            $idlg = "GetVPNConnected"
        Case Else
            Return SetError(0x1, 0x0, 0x0)
    EndSwitch
    Local $sstr = ""
    If BitAND($iflags, 0x1) Then
        $sstr &= "-SkipInternetDetection "
    EndIf
    If BitAND($iflags, 0x2) Then
        $sstr &= "-SkipExistingConnections "
    EndIf
    If BitAND($iflags, 0x4) Then
        $sstr &= "-HideFinishPage "
    EndIf
    Local $acall = DllCall("connect.dll", "long", $idlg, "hwnd", $hparent, "dword", 0x0, "dword", 0x0, "dword", 0x0, "handle", 0x0, "wstr", StringStripWS($sstr, $str_striptrailing))
    If @error Then Return SetError(@error, @extended, 0x0)
    If Not ($acall[0x0] = 0x0 Or $acall[0x0] = 0x1) Then Return SetError(0xa, $acall[0x0], 0x0)
    Return Number(Not $acall[0x0])
EndFunc   ;==>_WINAPI_GETCONNECTEDDLG
Func _WINAPI_GETFRBUFFER()
    Return $__g_ifrbuffersize + 0xffffffff
EndFunc   ;==>_WINAPI_GETFRBUFFER
Func _WinAPI_GetOpenFileName($stitle = "", $sfilter = "All files (*.*)", $sinitaldir = ".", $sdefaultfile = "", $sdefaultext = "", $ifilterindex = 0x1, $iflags = 0x0, $iflagsex = 0x0, $hwndowner = 0x0)
    Local $vresult = __OFNDLG(0x0, $stitle, $sinitaldir, $sfilter, $ifilterindex, $sdefaultfile, $sdefaultext, $iflags, $iflagsex, 0x0, 0x0, $hwndowner)
    If @error Then Return SetError(@error, @extended, $vresult)
    If BitAND($iflags, $ofn_allowmultiselect) Then
        Return __WINAPI_PARSEMULTISELECTFILEDIALOGPATH($vresult)
    Else
        Return __WINAPI_PARSEFILEDIALOGPATH($vresult)
    EndIf
EndFunc   ;==>_WINAPI_GETOPENFILENAME
Func _WinAPI_GetSaveFileName($stitle = "", $sfilter = "All files (*.*)", $sinitaldir = ".", $sdefaultfile = "", $sdefaultext = "", $ifilterindex = 0x1, $iflags = 0x0, $iflagsex = 0x0, $hwndowner = 0x0)
    Local $vreturn = __OFNDLG(0x1, $stitle, $sinitaldir, $sfilter, $ifilterindex, $sdefaultfile, $sdefaultext, $iflags, $iflagsex, 0x0, 0x0, $hwndowner)
    If @error Then Return SetError(@error, @extended, $vreturn)
    Return __WINAPI_PARSEFILEDIALOGPATH($vreturn)
EndFunc   ;==>_WINAPI_GETSAVEFILENAME
Func _WINAPI_MESSAGEBOXCHECK($itype, $stitle, $stext, $sregval, $idefault = +0xffffffff, $hparent = 0x0)
    Local $acall = DllCall("shlwapi.dll", "int", "SHMessageBoxCheckW", "hwnd", $hparent, "wstr", $stext, "wstr", $stitle, "uint", $itype, "int", $idefault, "wstr", $sregval)
    If @error Then Return SetError(@error, @extended, +0xffffffff)
    Return $acall[0x0]
EndFunc   ;==>_WINAPI_MESSAGEBOXCHECK
Func _WINAPI_MESSAGEBOXINDIRECT($tmsgboxparams)
    Local $acall = DllCall("user32.dll", "int", "MessageBoxIndirectW", "struct*", $tmsgboxparams)
    If @error Then Return SetError(@error, @extended, 0x0)
    Return $acall[0x0]
EndFunc   ;==>_WINAPI_MESSAGEBOXINDIRECT
Func _WINAPI_OPENFILEDLG($stitle = "", $sinitdir = "", $sfilters = "", $idefaultfilter = 0x0, $sdefaultfilepath = "", $sdefaultext = "", $iflags = 0x0, $iflagsex = 0x0, $pofnproc = 0x0, $pdata = 0x0, $hparent = 0x0)
    Local $vresult = __OFNDLG(0x0, $stitle, $sinitdir, $sfilters, $idefaultfilter, $sdefaultfilepath, $sdefaultext, $iflags, $iflagsex, $pofnproc, $pdata, $hparent)
    If @error Then Return SetError(@error, @extended, $vresult)
    Return $vresult
EndFunc   ;==>_WINAPI_OPENFILEDLG
Func _WINAPI_PAGESETUPDLG(ByRef $tpagesetupdlg)
    Local $acall = DllCall("comdlg32.dll", "int", "PageSetupDlgW", "struct*", $tpagesetupdlg)
    If @error Then Return SetError(@error, @extended, 0x0)
    If Not $acall[0x0] Then Return SetError(0xa, _WINAPI_COMMDLGEXTENDEDERROREX(), 0x0)
    Return $acall[0x0]
EndFunc   ;==>_WINAPI_PAGESETUPDLG
Func _WINAPI_PICKICONDLG($sicon = "", $iindex = 0x0, $hparent = 0x0)
    Local $acall = DllCall("shell32.dll", "int", "PickIconDlg", "hwnd", $hparent, "wstr", $sicon, "int", 0x1000, "int*", $iindex)
    If @error Or Not $acall[0x0] Then Return SetError(@error + 0xa, @extended, 0x0)
    Local $aret[0x2]
    Local $ares = DllCall("kernel32.dll", "dword", "ExpandEnvironmentStringsW", "wstr", $acall[0x2], "wstr", "", "dword", 0x1000)
    $aret[0x0] = $ares[0x2]
    $aret[0x1] = $acall[0x4]
    Return $aret
EndFunc   ;==>_WINAPI_PICKICONDLG
Func _WINAPI_PRINTDLG(ByRef $tprintdlg)
    Local $acall = DllCall("comdlg32.dll", "long", "PrintDlgW", "struct*", $tprintdlg)
    If @error Then Return SetError(@error, @extended, 0x0)
    If Not $acall[0x0] Then Return SetError(0xa, _WINAPI_COMMDLGEXTENDEDERROREX(), 0x0)
    Return $acall[0x0]
EndFunc   ;==>_WINAPI_PRINTDLG
Func _WINAPI_PRINTDLGEX(ByRef $tprintdlgex)
    Local $tpdex = DllStructCreate($tagprintdlgex, DllStructGetPtr($tprintdlgex))
    Local $acall = DllCall("comdlg32.dll", "long", "PrintDlgExW", "struct*", $tpdex)
    If @error Then Return SetError(@error, @extended, 0x0)
    If $acall[0x0] Then Return SetError(0xa, $acall[0x0], 0x0)
    Return SetExtended(DllStructGetData($tpdex, "ResultAction"), 0x1)
EndFunc   ;==>_WINAPI_PRINTDLGEX
Func _WINAPI_REPLACETEXTDLG($howner, $sfindwhat = "", $sreplacewith = "", $iflags = 0x0, $preplaceproc = 0x0, $lparam = 0x0)
    $__g_pfrbuffer = __HEAPREALLOC($__g_pfrbuffer, 0x4 * $__g_ifrbuffersize)
    If @error Then Return SetError(@error + 0x64, @extended, 0x0)
    Local $tbuff = DllStructCreate("wchar[" & $__g_ifrbuffersize & "];wchar[" & $__g_ifrbuffersize & "]", $__g_pfrbuffer)
    DllStructSetData($tbuff, 0x1, StringLeft($sfindwhat, $__g_ifrbuffersize + 0xffffffff))
    DllStructSetData($tbuff, 0x2, StringLeft($sreplacewith, $__g_ifrbuffersize + 0xffffffff))
    Local $tfr = DllStructCreate($tagfindreplace)
    DllStructSetData($tfr, "Size", DllStructGetSize($tfr))
    DllStructSetData($tfr, "hOwner", $howner)
    DllStructSetData($tfr, "hInstance", 0x0)
    DllStructSetData($tfr, "Flags", $iflags)
    DllStructSetData($tfr, "FindWhat", DllStructGetPtr($tbuff, 0x1))
    DllStructSetData($tfr, "ReplaceWith", DllStructGetPtr($tbuff, 0x2))
    DllStructSetData($tfr, "FindWhatLen", $__g_ifrbuffersize * 0x2)
    DllStructSetData($tfr, "ReplaceWithLen", $__g_ifrbuffersize * 0x2)
    DllStructSetData($tfr, "lParam", $lparam)
    DllStructSetData($tfr, "Hook", $preplaceproc)
    DllStructSetData($tfr, "TemplateName", 0x0)
    Local $acall = DllCall("comdlg32.dll", "hwnd", "ReplaceTextW", "struct*", $tfr)
    If @error Or Not $acall[0x0] Then
        Local $ierror = @error
        __HEAPFREE($__g_pfrbuffer)
        If IsArray($acall) Then
            Return SetError(0xa, _WINAPI_COMMDLGEXTENDEDERROREX(), 0x0)
        Else
            Return SetError($ierror, 0x0, 0x0)
        EndIf
    EndIf
    Return $acall[0x0]
EndFunc   ;==>_WINAPI_REPLACETEXTDLG
Func _WINAPI_RESTARTDLG($stext = "", $iflags = 0x2, $hparent = 0x0)
    Local $acall = DllCall("shell32.dll", "int", "RestartDialog", "hwnd", $hparent, "wstr", $stext, "int", $iflags)
    If @error Then Return SetError(@error, @extended, 0x0)
    Return $acall[0x0]
EndFunc   ;==>_WINAPI_RESTARTDLG
Func _WINAPI_SAVEFILEDLG($stitle = "", $sinitdir = "", $sfilters = "", $idefaultfilter = 0x0, $sdefaultfilepath = "", $sdefaultext = "", $iflags = 0x0, $iflagsex = 0x0, $pofnproc = 0x0, $pdata = 0x0, $hparent = 0x0)
    Local $vresult = __OFNDLG(0x1, $stitle, $sinitdir, $sfilters, $idefaultfilter, $sdefaultfilepath, $sdefaultext, $iflags, $iflagsex, $pofnproc, $pdata, $hparent)
    If @error Then Return SetError(@error, @extended, $vresult)
    Return $vresult
EndFunc   ;==>_WINAPI_SAVEFILEDLG
Func _WINAPI_SETFRBUFFER($ichars)
    $ichars = Number($ichars)
    If $ichars < 0x50 Then
        $ichars = 0x50
    EndIf
    $__g_ifrbuffersize = $ichars + 0x1
    Return 0x1
EndFunc   ;==>_WINAPI_SETFRBUFFER
Func _WINAPI_SHELLABOUTDLG($stitle, $sname, $stext, $hicon = 0x0, $hparent = 0x0)
    Local $acall = DllCall("shell32.dll", "int", "ShellAboutW", "hwnd", $hparent, "wstr", $stitle & "#" & $sname, "wstr", $stext, "handle", $hicon)
    If @error Then Return SetError(@error, @extended, False)
    Return $acall[0x0]
EndFunc   ;==>_WINAPI_SHELLABOUTDLG
Func _WINAPI_SHELLOPENWITHDLG($sfilepath, $iflags = 0x0, $hparent = 0x0)
    Local $topenasinfo = DllStructCreate("ptr;ptr;dword;wchar[" & (StringLen($sfilepath) + 0x1) & "]")
    DllStructSetData($topenasinfo, 0x1, DllStructGetPtr($topenasinfo, 0x4))
    DllStructSetData($topenasinfo, 0x2, 0x0)
    DllStructSetData($topenasinfo, 0x3, $iflags)
    DllStructSetData($topenasinfo, 0x4, $sfilepath)
    Local $acall = DllCall("shell32.dll", "long", "SHOpenWithDialog", "hwnd", $hparent, "struct*", $topenasinfo)
    If @error Then Return SetError(@error, @extended, 0x0)
    If $acall[0x0] Then Return SetError(0xa, $acall[0x0], 0x0)
    Return 0x1
EndFunc   ;==>_WINAPI_SHELLOPENWITHDLG
Func _WINAPI_SHELLSTARTNETCONNECTIONDLG($sremote = "", $iflags = 0x0, $hparent = 0x0)
    If Not StringStripWS($sremote, $str_stripleading + $str_striptrailing) Then $sremote = NULL
    DllCall("shell32.dll", "long", "SHStartNetConnectionDialogW", "hwnd", $hparent, "wstr", $sremote, "dword", $iflags)
    If @error Then Return SetError(@error, @extended, 0x0)
    Return 0x1
EndFunc   ;==>_WINAPI_SHELLSTARTNETCONNECTIONDLG
Func _WINAPI_SHELLUSERAUTHENTICATIONDLG($scaption, $smessage, $suser, $spassword, $starget, $iflags = 0x0, $ierror = 0x0, $bsave = False, $hbitmap = 0x0, $hparent = 0x0)
    If Not __DLL("credui.dll") Then Return SetError(0x67, 0x0, 0x0)
    Local $tinfo = DllStructCreate("dword;hwnd;ptr;ptr;ptr;wchar[" & (StringLen($smessage) + 0x1) & "];wchar[" & (StringLen($scaption) + 0x1) & "]")
    DllStructSetData($tinfo, 0x1, DllStructGetPtr($tinfo, 0x6) - DllStructGetPtr($tinfo))
    DllStructSetData($tinfo, 0x2, $hparent)
    DllStructSetData($tinfo, 0x3, DllStructGetPtr($tinfo, 0x6))
    DllStructSetData($tinfo, 0x4, DllStructGetPtr($tinfo, 0x7))
    DllStructSetData($tinfo, 0x5, $hbitmap)
    DllStructSetData($tinfo, 0x6, $smessage)
    DllStructSetData($tinfo, 0x7, $scaption)
    Local $acall = DllCall("credui.dll", "dword", "CredUIPromptForCredentialsW", "struct*", $tinfo, "wstr", $starget, "ptr", 0x0, "dword", $ierror, "wstr", $suser, "ulong", 0x1000, "wstr", $spassword, "ulong", 0x1000, "bool*", $bsave, "dword", $iflags)
    If @error Then Return SetError(@error, @extended, 0x0)
    If $acall[0x0] Then Return SetError(0xa, $acall[0x0], 0x0)
    Local $aret[0x3]
    $aret[0x0] = $acall[0x5]
    $aret[0x1] = $acall[0x7]
    $aret[0x2] = $acall[0x9]
    Return $aret
EndFunc   ;==>_WINAPI_SHELLUSERAUTHENTICATIONDLG
Func _WINAPI_SHELLUSERAUTHENTICATIONDLGEX($scaption, $smessage, $suser, $spassword, $iflags = 0x0, $iautherror = 0x0, $bsave = False, $ipackage = 0x0, $hparent = 0x0)
    If Not __DLL("credui.dll") Then Return SetError(0x67, 0x0, 0x0)
    Local $tblob = 0x0, $acall
    If StringLen($suser) Then
        $acall = DllCall("credui.dll", "bool", "CredPackAuthenticationBufferW", "dword", 0x1, "wstr", $suser, "wstr", $spassword, "ptr", 0x0, "dword*", 0x0)
        If @error Or Not $acall[0x5] Then Return SetError(@error + 0xa, @extended, 0x0)
        $tblob = DllStructCreate("byte[" & $acall[0x5] & "]")
        $acall = DllCall("credui.dll", "bool", "CredPackAuthenticationBufferW", "dword", 0x1, "wstr", $suser, "wstr", $spassword, "struct*", $tblob, "dword*", $acall[0x5])
        If @error Or Not $acall[0x0] Then Return SetError(@error + 0x14, @extended, 0x0)
    EndIf
    Local $tinfo = DllStructCreate("dword;hwnd;ptr;ptr;ptr;wchar[" & (StringLen($smessage) + 0x1) & "];wchar[" & (StringLen($scaption) + 0x1) & "]")
    DllStructSetData($tinfo, 0x1, DllStructGetPtr($tinfo, 0x6) - DllStructGetPtr($tinfo))
    DllStructSetData($tinfo, 0x2, $hparent)
    DllStructSetData($tinfo, 0x3, DllStructGetPtr($tinfo, 0x6))
    DllStructSetData($tinfo, 0x4, DllStructGetPtr($tinfo, 0x7))
    DllStructSetData($tinfo, 0x5, 0x0)
    DllStructSetData($tinfo, 0x6, $smessage)
    DllStructSetData($tinfo, 0x7, $scaption)
    $acall = DllCall("credui.dll", "dword", "CredUIPromptForWindowsCredentialsW", "struct*", $tinfo, "dword", $iautherror, "ulong*", $ipackage, "struct*", $tblob, "ulong", DllStructGetSize($tblob), "ptr*", 0x0, "ulong*", 0x0, "bool*", $bsave, "dword", $iflags)
    If @error Then Return SetError(@error + 0x1e, @extended, 0x0)
    If $acall[0x0] Then Return SetError(0x1e, $acall[0x0], 0x0)
    Local $aret[0x4], $ierror = 0x0
    $aret[0x2] = $acall[0x8]
    $aret[0x3] = $acall[0x3]
    Local $pblob = $acall[0x6]
    Local $isize = $acall[0x7]
    $acall = DllCall("credui.dll", "bool", "CredUnPackAuthenticationBufferW", "dword", 0x1, "ptr", $pblob, "dword", $isize, "wstr", "", "dword*", 0x1000, "wstr", "", "dword*", 0x1000, "wstr", "", "dword*", 0x1000)
    If Not @error And $acall[0x0] Then
        $aret[0x0] = $acall[0x4]
        $aret[0x1] = $acall[0x8]
    Else
        $ierror = @error + 0x28
    EndIf
    If Not _WINAPI_ZEROMEMORY($pblob, $isize) Then
    EndIf
    _WINAPI_COTASKMEMFREE($pblob)
    If $ierror Then Return SetError($ierror, 0x0, 0x0)
    Return $aret
EndFunc   ;==>_WINAPI_SHELLUSERAUTHENTICATIONDLGEX
#endregion Public Functions
#region Internal Functions
Func __OFNDLG($idlg, $stitle, $sinitdir, $sfilters, $ideffilter, $sdeffile, $sdefext, $iflags, $iflagsex, $pofnproc, $pdata, $hparent)
    Local $verror[0x1] = [0x0]
    If BitAND($iflags, $ofn_allowmultiselect) = 0x0 Then $verror = ""
    Local $tbuffer = DllStructCreate("wchar[32768]")
    Local $tfilters = 0x0, $tdefext = 0x0, $tinitdir = 0x0, $ttitle = 0x0
    Local $tofn = DllStructCreate($tagopenfilename)
    DllStructSetData($tofn, "StructSize", DllStructGetSize($tofn))
    DllStructSetData($tofn, "hwndOwner", $hparent)
    DllStructSetData($tofn, 0x3, 0x0)
    Local $adata = StringSplit($sfilters, "|")
    Local $afilters[$adata[0x0] * 0x2]
    Local $icount = 0x0
    For $i = 0x1 To $adata[0x0]
        $afilters[$icount + 0x0] = StringStripWS($adata[$i], $str_stripleading + $str_striptrailing)
        $afilters[$icount + 0x1] = StringStripWS(StringRegExpReplace($adata[$i], ".*\((.*)\)", "\1"), $str_stripall)
        If $afilters[$icount + 0x1] Then
            $icount += 0x2
        EndIf
    Next
    If $icount Then
        $tfilters = _WINAPI_ARRAYTOSTRUCT($afilters, 0x0, $icount + 0xffffffff)
        If @error Then
        EndIf
    EndIf
    DllStructSetData($tofn, "lpstrFilter", DllStructGetPtr($tfilters))
    DllStructSetData($tofn, 0x5, 0x0)
    DllStructSetData($tofn, 0x6, 0x0)
    DllStructSetData($tofn, "nFilterIndex", $ideffilter)
    $sdeffile = StringStripWS($sdeffile, $str_stripleading + $str_striptrailing)
    If $sdeffile Then
        DllStructSetData($tbuffer, 0x1, $sdeffile)
    EndIf
    DllStructSetData($tofn, "lpstrFile", DllStructGetPtr($tbuffer))
    DllStructSetData($tofn, "nMaxFile", 0x8000)
    DllStructSetData($tofn, 0xa, 0x0)
    DllStructSetData($tofn, 0xb, 0x0)
    $sinitdir = StringStripWS($sinitdir, $str_stripleading + $str_striptrailing)
    If $sinitdir Then
        $tinitdir = DllStructCreate("wchar[" & (StringLen($sinitdir) + 0x1) & "]")
    EndIf
    DllStructSetData($tinitdir, 0x1, $sinitdir)
    DllStructSetData($tofn, "lpstrInitialDir", DllStructGetPtr($tinitdir))
    $stitle = StringStripWS($stitle, $str_stripleading + $str_striptrailing)
    If $stitle Then
        $ttitle = DllStructCreate("wchar[" & (StringLen($stitle) + 0x1) & "]")
    EndIf
    DllStructSetData($ttitle, 0x1, $stitle)
    DllStructSetData($tofn, "lpstrTitle", DllStructGetPtr($ttitle))
    DllStructSetData($tofn, "Flags", $iflags)
    DllStructSetData($tofn, 0xf, 0x0)
    DllStructSetData($tofn, 0x10, 0x0)
    $sdefext = StringStripWS($sdefext, $str_stripleading + $str_striptrailing)
    If $sdefext Then
        $tdefext = DllStructCreate("wchar[" & (StringLen($tdefext) + 0x1) & "]")
    EndIf
    DllStructSetData($tdefext, 0x1, StringReplace($sdefext, ".", ""))
    DllStructSetData($tofn, "lpstrDefExt", DllStructGetPtr($tdefext))
    DllStructSetData($tofn, "lCustData", $pdata)
    DllStructSetData($tofn, "lpfnHook", $pofnproc)
    DllStructSetData($tofn, 0x14, 0x0)
    DllStructSetData($tofn, 0x15, 0x0)
    DllStructSetData($tofn, 0x16, 0x0)
    DllStructSetData($tofn, "FlagsEx", $iflagsex)
    Local $acall
    Switch $idlg
        Case 0x0
            $acall = DllCall("comdlg32.dll", "bool", "GetOpenFileNameW", "struct*", $tofn)
        Case 0x1
            $acall = DllCall("comdlg32.dll", "bool", "GetSaveFileNameW", "struct*", $tofn)
        Case Else
    EndSwitch
    If @error Or Not $acall[0x0] Then Return SetError(@error + 0xa, _WINAPI_COMMDLGEXTENDEDERROREX(), $verror)
    If BitAND($iflags, $ofn_allowmultiselect) Then
        If BitAND($iflags, $ofn_explorer) Then
            $adata = _WINAPI_STRUCTTOARRAY($tbuffer)
            If @error Then
                Return SetError(0xb, 0x0, $verror)
            EndIf
        Else
            $adata = StringSplit(DllStructGetData($tbuffer, 0x1), " ")
        EndIf
        Switch $adata[0x0]
            Case 0x0
                Return SetError(0xc, 0x0, $verror)
            Case 0x1
            Case Else
                Local $spath = $adata[0x1]
                For $i = 0x2 To $adata[0x0]
                    $adata[$i + 0xffffffff] = _WINAPI_PATHAPPEND($spath, $adata[$i])
                Next
                ReDim $adata[$adata[0x0]]
                $adata[0x0] -= 0x1
        EndSwitch
    Else
        $adata = DllStructGetData($tbuffer, 0x1)
    EndIf
    $__g_vext = $tofn
    Return $adata
EndFunc   ;==>__OFNDLG
Func __WINAPI_PARSEMULTISELECTFILEDIALOGPATH($apath)
    Local $afiles[UBound($apath) + 0x1]
    $afiles[0x0] = UBound($apath)
    $afiles[0x1] = StringMid($apath[0x1], 0x1, StringInStr($apath[0x1], "\", $str_nocasesensebasic, +0xffffffff) + 0xffffffff)
    For $i = 0x1 To UBound($apath) + 0xffffffff
        $afiles[$i + 0x1] = StringMid($apath[$i], StringInStr($apath[$i], "\", $str_nocasesensebasic, +0xffffffff) + 0x1)
    Next
    Return $afiles
EndFunc   ;==>__WINAPI_PARSEMULTISELECTFILEDIALOGPATH
Func __WINAPI_PARSEFILEDIALOGPATH($spath)
    Local $afiles[0x3]
    $afiles[0x0] = 0x2
    $afiles[0x1] = StringMid($spath, 0x1, StringInStr($spath, "\", $str_nocasesensebasic, +0xffffffff) + 0xffffffff)
    $afiles[0x2] = StringMid($spath, StringInStr($spath, "\", $str_nocasesensebasic, +0xffffffff) + 0x1)
    Return $afiles
EndFunc   ;==>__WINAPI_PARSEFILEDIALOGPATH
#endregion Internal Functions
Global Const $backup_alternate_data = 0x4
Global Const $backup_data = 0x1
Global Const $backup_ea_data = 0x2
Global Const $backup_link = 0x5
Global Const $backup_object_id = 0x7
Global Const $backup_property_data = 0x6
Global Const $backup_reparse_data = 0x8
Global Const $backup_security_data = 0x3
Global Const $backup_sparse_block = 0x9
Global Const $backup_txfs_data = 0xa
Global Const $copy_file_allow_decrypted_destination = 0x8
Global Const $copy_file_copy_symlink = 0x800
Global Const $copy_file_fail_if_exists = 0x1
Global Const $copy_file_no_buffering = 0x1000
Global Const $copy_file_open_source_for_write = 0x4
Global Const $copy_file_restartable = 0x2
Global Const $move_file_copy_allowed = 0x2
Global Const $move_file_create_hardlink = 0x10
Global Const $move_file_delay_until_reboot = 0x4
Global Const $move_file_fail_if_not_trackable = 0x20
Global Const $move_file_replace_existing = 0x1
Global Const $move_file_write_through = 0x8
Global Const $progress_continue = 0x0
Global Const $progress_cancel = 0x1
Global Const $progress_stop = 0x2
Global Const $progress_quiet = 0x3
Global Const $file_append_data = 0x4
Global Const $file_delete_child = 0x40
Global Const $file_execute = 0x20
Global Const $file_read_attributes = 0x80
Global Const $file_read_data = 0x1
Global Const $file_read_ea = 0x8
Global Const $file_write_attributes = 0x100
Global Const $file_write_data = 0x2
Global Const $file_write_ea = 0x10
Global Const $file_add_file = $file_write_data
Global Const $file_add_subdirectory = $file_append_data
Global Const $file_create_pipe_instance = $file_append_data
Global Const $file_list_directory = $file_read_data
Global Const $file_traverse = $file_execute
Global Const $file_all_access = 0x1f01ff
Global Const $file_flag_backup_semantics = 0x2000000
Global Const $file_flag_delete_on_close = 0x4000000
Global Const $file_flag_no_buffering = 0x20000000
Global Const $file_flag_open_no_recall = 0x100000
Global Const $file_flag_open_reparse_point = 0x200000
Global Const $file_flag_overlapped = 0x40000000
Global Const $file_flag_posix_semantics = 0x100000
Global Const $file_flag_random_access = 0x10000000
Global Const $file_flag_sequential_scan = 0x8000000
Global Const $file_flag_write_through = 0x80000000
Global Const $security_anonymous = 0x0
Global Const $security_context_tracking = 0x40000
Global Const $security_delegation = 0x30000
Global Const $security_effective_only = 0x80000
Global Const $security_identification = 0x10000
Global Const $security_impersonation = 0x20000
Global Const $sec_commit = 0x8000000
Global Const $sec_image = 0x1000000
Global Const $sec_large_pages = 0x80000000
Global Const $sec_nocache = 0x10000000
Global Const $sec_reserve = 0x4000000
Global Const $sec_writecombine = 0x40000000
Global Const $section_extend_size = 0x10
Global Const $section_map_execute = 0x8
Global Const $section_map_read = 0x4
Global Const $section_map_write = 0x2
Global Const $section_query = 0x1
Global Const $section_all_access = 0x1f001f
Global Const $file_map_copy = 0x1
Global Const $file_map_execute = 0x20
Global Const $file_map_read = 0x4
Global Const $file_map_write = 0x2
Global Const $file_map_all_access = $section_all_access
Global Const $ddd_exact_match_on_remove = 0x4
Global Const $ddd_no_broadcast_system = 0x8
Global Const $ddd_raw_target_path = 0x1
Global Const $ddd_remove_definition = 0x2
Global Const $fsctl_allow_extended_dasd_io = 0x90083
Global Const $fsctl_create_or_get_object_id = 0x900c0
Global Const $fsctl_create_usn_journal = 0x900e7
Global Const $fsctl_delete_object_id = 0x900a0
Global Const $fsctl_delete_reparse_point = 0x900ac
Global Const $fsctl_delete_usn_journal = 0x900f8
Global Const $fsctl_dismount_volume = 0x90020
Global Const $fsctl_dump_property_data = 0x90097
Global Const $fsctl_enable_upgrade = 0x980d0
Global Const $fsctl_encryption_fsctl_io = 0x900db
Global Const $fsctl_enum_usn_data = 0x900b3
Global Const $fsctl_extend_volume = 0x900f0
Global Const $fsctl_filesystem_get_statistics = 0x90060
Global Const $fsctl_find_files_by_sid = 0x9008f
Global Const $fsctl_get_compression = 0x9003c
Global Const $fsctl_get_ntfs_file_record = 0x90068
Global Const $fsctl_get_ntfs_volume_data = 0x90064
Global Const $fsctl_get_object_id = 0x9009c
Global Const $fsctl_get_reparse_point = 0x900a8
Global Const $fsctl_get_retrieval_pointers = 0x90073
Global Const $fsctl_get_volume_bitmap = 0x9006f
Global Const $fsctl_hsm_data = 0x9c113
Global Const $fsctl_hsm_msg = 0x9c108
Global Const $fsctl_invalidate_volumes = 0x90054
Global Const $fsctl_is_pathname_valid = 0x9002c
Global Const $fsctl_is_volume_dirty = 0x90078
Global Const $fsctl_is_volume_mounted = 0x90028
Global Const $fsctl_lock_volume = 0x90018
Global Const $fsctl_mark_as_system_hive = 0x9004f
Global Const $fsctl_mark_handle = 0x900fc
Global Const $fsctl_mark_volume_dirty = 0x90030
Global Const $fsctl_move_file = 0x90074
Global Const $fsctl_opbatch_ack_close_pending = 0x90010
Global Const $fsctl_oplock_break_ack_no_2 = 0x90050
Global Const $fsctl_oplock_break_acknowledge = 0x9000c
Global Const $fsctl_oplock_break_notify = 0x90014
Global Const $fsctl_query_allocated_ranges = 0x940cf
Global Const $fsctl_query_fat_bpb = 0x90058
Global Const $fsctl_query_retrieval_pointers = 0x9003b
Global Const $fsctl_query_usn_journal = 0x900f4
Global Const $fsctl_read_file_usn_data = 0x900eb
Global Const $fsctl_read_property_data = 0x90087
Global Const $fsctl_read_raw_encrypted = 0x900e3
Global Const $fsctl_read_usn_journal = 0x900bb
Global Const $fsctl_recall_file = 0x90117
Global Const $fsctl_request_batch_oplock = 0x90008
Global Const $fsctl_request_filter_oplock = 0x9005c
Global Const $fsctl_request_oplock_level_1 = 0x90000
Global Const $fsctl_request_oplock_level_2 = 0x90004
Global Const $fsctl_security_id_check = 0x940b7
Global Const $fsctl_set_compression = 0x9c040
Global Const $fsctl_set_encryption = 0x900d7
Global Const $fsctl_set_object_id = 0x90098
Global Const $fsctl_set_object_id_extended = 0x900bc
Global Const $fsctl_set_reparse_point = 0x900a4
Global Const $fsctl_set_sparse = 0x900c4
Global Const $fsctl_set_zero_data = 0x980c8
Global Const $fsctl_sis_copyfile = 0x90100
Global Const $fsctl_sis_link_files = 0x9c104
Global Const $fsctl_unlock_volume = 0x9001c
Global Const $fsctl_write_property_data = 0x9008b
Global Const $fsctl_write_raw_encrypted = 0x900df
Global Const $fsctl_write_usn_close_record = 0x900ef
Global Const $ioctl_aacs_end_session = 0x3350cc
Global Const $ioctl_aacs_generate_binding_nonce = 0x33d0f0
Global Const $ioctl_aacs_get_certificate = 0x3350d4
Global Const $ioctl_aacs_get_challenge_key = 0x3350d8
Global Const $ioctl_aacs_read_binding_nonce = 0x3350ec
Global Const $ioctl_aacs_read_media_id = 0x3350e8
Global Const $ioctl_aacs_read_media_key_block = 0x3350c4
Global Const $ioctl_aacs_read_media_key_block_size = 0x3350c0
Global Const $ioctl_aacs_read_serial_number = 0x3350e4
Global Const $ioctl_aacs_read_volume_id = 0x3350e0
Global Const $ioctl_aacs_send_certificate = 0x3350d0
Global Const $ioctl_aacs_send_challenge_key = 0x3350dc
Global Const $ioctl_aacs_start_session = 0x3350c8
Global Const $ioctl_ata_pass_through = 0x4d02c
Global Const $ioctl_ata_pass_through_direct = 0x4d030
Global Const $ioctl_cdrom_check_verify = 0x24800
Global Const $ioctl_cdrom_disk_type = 0x20040
Global Const $ioctl_cdrom_eject_media = 0x24808
Global Const $ioctl_cdrom_find_new_devices = 0x24818
Global Const $ioctl_cdrom_get_configuration = 0x24058
Global Const $ioctl_cdrom_get_control = 0x24034
Global Const $ioctl_cdrom_get_drive_geometry = 0x2404c
Global Const $ioctl_cdrom_get_drive_geometry_ex = 0x24050
Global Const $ioctl_cdrom_get_last_session = 0x24038
Global Const $ioctl_cdrom_get_volume = 0x24014
Global Const $ioctl_cdrom_load_media = 0x2480c
Global Const $ioctl_cdrom_media_removal = 0x24804
Global Const $ioctl_cdrom_pause_audio = 0x2400c
Global Const $ioctl_cdrom_play_audio_msf = 0x24018
Global Const $ioctl_cdrom_raw_read = 0x2403e
Global Const $ioctl_cdrom_read_q_channel = 0x2402c
Global Const $ioctl_cdrom_read_toc = 0x24000
Global Const $ioctl_cdrom_read_toc_ex = 0x24054
Global Const $ioctl_cdrom_release = 0x24814
Global Const $ioctl_cdrom_reserve = 0x24810
Global Const $ioctl_cdrom_resume_audio = 0x24010
Global Const $ioctl_cdrom_seek_audio_msf = 0x24004
Global Const $ioctl_cdrom_set_volume = 0x24028
Global Const $ioctl_cdrom_stop_audio = 0x24008
Global Const $ioctl_cdrom_unload_driver = 0x25008
Global Const $ioctl_disk_check_verify = 0x74800
Global Const $ioctl_disk_controller_number = 0x70044
Global Const $ioctl_disk_create_disk = 0x7c058
Global Const $ioctl_disk_delete_drive_layout = 0x7c100
Global Const $ioctl_disk_eject_media = 0x74808
Global Const $ioctl_disk_find_new_devices = 0x74818
Global Const $ioctl_disk_format_tracks = 0x7c018
Global Const $ioctl_disk_format_tracks_ex = 0x7c02c
Global Const $ioctl_disk_get_cache_information = 0x740d4
Global Const $ioctl_disk_get_drive_geometry = 0x70000
Global Const $ioctl_disk_get_drive_geometry_ex = 0x700a0
Global Const $ioctl_disk_get_drive_layout = 0x7400c
Global Const $ioctl_disk_get_drive_layout_ex = 0x70050
Global Const $ioctl_disk_get_length_info = 0x7405c
Global Const $ioctl_disk_get_media_types = 0x70c00
Global Const $ioctl_disk_get_partition_info = 0x74004
Global Const $ioctl_disk_get_partition_info_ex = 0x70048
Global Const $ioctl_disk_get_write_cache_state = 0x740dc
Global Const $ioctl_disk_grow_partition = 0x7c0d0
Global Const $ioctl_disk_histogram_data = 0x70034
Global Const $ioctl_disk_histogram_reset = 0x70038
Global Const $ioctl_disk_histogram_structure = 0x70030
Global Const $ioctl_disk_internal_clear_verify = 0x70407
Global Const $ioctl_disk_internal_set_notify = 0x70408
Global Const $ioctl_disk_internal_set_verify = 0x70403
Global Const $ioctl_disk_is_writable = 0x70024
Global Const $ioctl_disk_load_media = 0x7480c
Global Const $ioctl_disk_logging = 0x70028
Global Const $ioctl_disk_media_removal = 0x74804
Global Const $ioctl_disk_performance = 0x70020
Global Const $ioctl_disk_performance_off = 0x70060
Global Const $ioctl_disk_reassign_blocks = 0x7c01c
Global Const $ioctl_disk_release = 0x74814
Global Const $ioctl_disk_request_data = 0x70040
Global Const $ioctl_disk_request_structure = 0x7003c
Global Const $ioctl_disk_reserve = 0x74810
Global Const $ioctl_disk_set_cache_information = 0x7c0d8
Global Const $ioctl_disk_set_drive_layout = 0x7c010
Global Const $ioctl_disk_set_drive_layout_ex = 0x7c054
Global Const $ioctl_disk_set_partition_info = 0x7c008
Global Const $ioctl_disk_set_partition_info_ex = 0x7c04c
Global Const $ioctl_disk_update_drive_size = 0x7c0c8
Global Const $ioctl_disk_update_properties = 0x70140
Global Const $ioctl_disk_verify = 0x70014
Global Const $ioctl_dvd_end_session = 0x33500c
Global Const $ioctl_dvd_get_region = 0x335014
Global Const $ioctl_dvd_read_key = 0x335004
Global Const $ioctl_dvd_read_structure = 0x335140
Global Const $ioctl_dvd_send_key = 0x335008
Global Const $ioctl_dvd_send_key2 = 0x33d018
Global Const $ioctl_dvd_set_read_ahead = 0x335010
Global Const $ioctl_dvd_start_session = 0x335000
Global Const $ioctl_mountdev_link_created = 0x4d0010
Global Const $ioctl_mountdev_link_deleted = 0x4d0014
Global Const $ioctl_mountdev_query_stable_guid = 0x4d0018
Global Const $ioctl_mountdev_query_suggested_link_name = 0x4d000c
Global Const $ioctl_mountdev_query_unique_id = 0x4d0000
Global Const $ioctl_mountdev_unique_id_change_notify = 0x4d0004
Global Const $ioctl_mountmgr_auto_dl_assignments = 0x6dc014
Global Const $ioctl_mountmgr_change_notify = 0x6d4020
Global Const $ioctl_mountmgr_check_unprocessed_volumes = 0x6d4028
Global Const $ioctl_mountmgr_create_point = 0x6dc000
Global Const $ioctl_mountmgr_delete_points = 0x6dc004
Global Const $ioctl_mountmgr_delete_points_dbonly = 0x6dc00c
Global Const $ioctl_mountmgr_keep_links_when_offline = 0x6dc024
Global Const $ioctl_mountmgr_next_drive_letter = 0x6dc010
Global Const $ioctl_mountmgr_query_dos_volume_path = 0x6d0030
Global Const $ioctl_mountmgr_query_dos_volume_paths = 0x6d0034
Global Const $ioctl_mountmgr_query_points = 0x6d0008
Global Const $ioctl_mountmgr_volume_arrival_notification = 0x6d402c
Global Const $ioctl_mountmgr_volume_mount_point_created = 0x6dc018
Global Const $ioctl_mountmgr_volume_mount_point_deleted = 0x6dc01c
Global Const $ioctl_scsi_get_inquiry_data = 0x4100c
Global Const $ioctl_scsi_get_capabilities = 0x41010
Global Const $ioctl_scsi_get_address = 0x41018
Global Const $ioctl_scsi_miniport = 0x4d008
Global Const $ioctl_scsi_pass_through = 0x4d004
Global Const $ioctl_scsi_pass_through_direct = 0x4d014
Global Const $ioctl_scsi_rescan_bus = 0x4101c
Global Const $ioctl_storage_break_reservation = 0x2d5014
Global Const $ioctl_storage_check_verify = 0x2d4800
Global Const $ioctl_storage_check_verify2 = 0x2d0800
Global Const $ioctl_storage_eject_media = 0x2d4808
Global Const $ioctl_storage_ejection_control = 0x2d0940
Global Const $ioctl_storage_find_new_devices = 0x2d4818
Global Const $ioctl_storage_get_device_number = 0x2d1080
Global Const $ioctl_storage_get_hotplug_info = 0x2d0c14
Global Const $ioctl_storage_get_media_serial_number = 0x2d0c10
Global Const $ioctl_storage_get_media_types = 0x2d0c00
Global Const $ioctl_storage_get_media_types_ex = 0x2d0c04
Global Const $ioctl_storage_load_media = 0x2d480c
Global Const $ioctl_storage_load_media2 = 0x2d080c
Global Const $ioctl_storage_manage_data_set_attributes = 0x2d9404
Global Const $ioctl_storage_mcn_control = 0x2d0944
Global Const $ioctl_storage_media_removal = 0x2d4804
Global Const $ioctl_storage_persistent_reserve_in = 0x2d5018
Global Const $ioctl_storage_persistent_reserve_out = 0x2d501c
Global Const $ioctl_storage_predict_failure = 0x2d1100
Global Const $ioctl_storage_query_property = 0x2d1400
Global Const $ioctl_storage_release = 0x2d4814
Global Const $ioctl_storage_reserve = 0x2d4810
Global Const $ioctl_storage_reset_bus = 0x2d5000
Global Const $ioctl_storage_reset_device = 0x2d5004
Global Const $ioctl_storage_set_hotplug_info = 0x2dcc18
Global Const $ioctl_storage_set_read_ahead = 0x2d4400
Global Const $ioctl_volume_get_gpt_attributes = 0x560038
Global Const $ioctl_volume_get_volume_disk_extents = 0x560000
Global Const $ioctl_volume_is_clustered = 0x560030
Global Const $ioctl_volume_is_io_capable = 0x560014
Global Const $ioctl_volume_is_offline = 0x560010
Global Const $ioctl_volume_is_partition = 0x560028
Global Const $ioctl_volume_logical_to_physical = 0x560020
Global Const $ioctl_volume_offline = 0x56c00c
Global Const $ioctl_volume_online = 0x56c008
Global Const $ioctl_volume_physical_to_logical = 0x560024
Global Const $ioctl_volume_query_failover_set = 0x560018
Global Const $ioctl_volume_query_volume_number = 0x56001c
Global Const $ioctl_volume_read_plex = 0x56402e
Global Const $ioctl_volume_set_gpt_attributes = 0x560034
Global Const $ioctl_volume_supports_online_offline = 0x560004
Global Const $smart_get_version = 0x74080
Global Const $smart_rcv_drive_data = 0x7c088
Global Const $smart_send_drive_command = 0x7c084
Global Const $file_encryptable = 0x0
Global Const $file_is_encrypted = 0x1
Global Const $file_read_only = 0x8
Global Const $file_root_dir = 0x3
Global Const $file_system_attr = 0x2
Global Const $file_system_dir = 0x4
Global Const $file_system_not_support = 0x6
Global Const $file_unknown = 0x5
Global Const $file_user_disallowed = 0x7
Global Const $scs_32bit_binary = 0x0
Global Const $scs_64bit_binary = 0x6
Global Const $scs_dos_binary = 0x1
Global Const $scs_os216_binary = 0x5
Global Const $scs_pif_binary = 0x3
Global Const $scs_posix_binary = 0x4
Global Const $scs_wow_binary = 0x2
Global Const $drive_bus_type_unknown = 0x0
Global Const $drive_bus_type_scsi = 0x1
Global Const $drive_bus_type_atapi = 0x2
Global Const $drive_bus_type_ata = 0x3
Global Const $drive_bus_type_1394 = 0x4
Global Const $drive_bus_type_ssa = 0x5
Global Const $drive_bus_type_fibre = 0x6
Global Const $drive_bus_type_usb = 0x7
Global Const $drive_bus_type_raid = 0x8
Global Const $drive_bus_type_iscsi = 0x9
Global Const $drive_bus_type_sas = 0xa
Global Const $drive_bus_type_sata = 0xb
Global Const $drive_bus_type_sd = 0xc
Global Const $drive_bus_type_mmc = 0xd
Global Const $drive_unknown = 0x0
Global Const $drive_no_root_dir = 0x1
Global Const $drive_removable = 0x2
Global Const $drive_fixed = 0x3
Global Const $drive_remote = 0x4
Global Const $drive_cdrom = 0x5
Global Const $drive_ramdisk = 0x6
Global Const $file_type_char = 0x2
Global Const $file_type_disk = 0x1
Global Const $file_type_pipe = 0x3
Global Const $file_type_remote = 0x8000
Global Const $file_type_unknown = 0x0
Global Const $file_name_normalized = 0x0
Global Const $file_name_opened = 0x8
Global Const $volume_name_dos = 0x0
Global Const $volume_name_guid = 0x1
Global Const $volume_name_none = 0x4
Global Const $volume_name_nt = 0x2
Global Const $image_file_machine_unknown = 0x0
Global Const $image_file_machine_am33 = 0x1d3
Global Const $image_file_machine_amd64 = 0x8664
Global Const $image_file_machine_arm = 0x1c0
Global Const $image_file_machine_ebc = 0xebc
Global Const $image_file_machine_i386 = 0x14c
Global Const $image_file_machine_ia64 = 0x200
Global Const $image_file_machine_m32r = 0x9041
Global Const $image_file_machine_mips16 = 0x266
Global Const $image_file_machine_mipsfpu = 0x366
Global Const $image_file_machine_mipsfpu16 = 0x466
Global Const $image_file_machine_powerpc = 0x1f0
Global Const $image_file_machine_powerpcfp = 0x1f1
Global Const $image_file_machine_r4000 = 0x166
Global Const $image_file_machine_sh3 = 0x1a2
Global Const $image_file_machine_sh3dsp = 0x1a3
Global Const $image_file_machine_sh4 = 0x1a6
Global Const $image_file_machine_sh5 = 0x1a8
Global Const $image_file_machine_thumb = 0x1c2
Global Const $image_file_machine_wcemipsv2 = 0x169
Global Const $file_case_preserved_names = 0x2
Global Const $file_case_sensitive_search = 0x1
Global Const $file_file_compression = 0x10
Global Const $file_named_streams = 0x40000
Global Const $file_persistent_acls = 0x8
Global Const $file_read_only_volume = 0x80000
Global Const $file_sequential_write_once = 0x100000
Global Const $file_supports_encryption = 0x20000
Global Const $file_supports_extended_attributes = 0x800000
Global Const $file_supports_hard_links = 0x400000
Global Const $file_supports_object_ids = 0x10000
Global Const $file_supports_open_by_file_id = 0x1000000
Global Const $file_supports_reparse_points = 0x80
Global Const $file_supports_sparse_files = 0x40
Global Const $file_supports_transactions = 0x200000
Global Const $file_supports_usn_journal = 0x2000000
Global Const $file_unicode_on_disk = 0x4
Global Const $file_volume_is_compressed = 0x8000
Global Const $file_volume_quotas = 0x20
Global Const $file_device_8042_port = 0x27
Global Const $file_device_acpi = 0x32
Global Const $file_device_battery = 0x29
Global Const $file_device_beep = 0x1
Global Const $file_device_bus_extender = 0x2a
Global Const $file_device_cd_rom = 0x2
Global Const $file_device_cd_rom_file_system = 0x3
Global Const $file_device_changer = 0x30
Global Const $file_device_controller = 0x4
Global Const $file_device_datalink = 0x5
Global Const $file_device_dfs = 0x6
Global Const $file_device_dfs_file_system = 0x35
Global Const $file_device_dfs_volume = 0x36
Global Const $file_device_disk = 0x7
Global Const $file_device_disk_file_system = 0x8
Global Const $file_device_dvd = 0x33
Global Const $file_device_file_system = 0x9
Global Const $file_device_fips = 0x3a
Global Const $file_device_fullscreen_video = 0x34
Global Const $file_device_inport_port = 0xa
Global Const $file_device_keyboard = 0xb
Global Const $file_device_ks = 0x2f
Global Const $file_device_ksec = 0x39
Global Const $file_device_mailslot = 0xc
Global Const $file_device_mass_storage = 0x2d
Global Const $file_device_midi_in = 0xd
Global Const $file_device_midi_out = 0xe
Global Const $file_device_modem = 0x2b
Global Const $file_device_mouse = 0xf
Global Const $file_device_multi_unc_provider = 0x10
Global Const $file_device_named_pipe = 0x11
Global Const $file_device_network = 0x12
Global Const $file_device_network_browser = 0x13
Global Const $file_device_network_file_system = 0x14
Global Const $file_device_network_redirector = 0x28
Global Const $file_device_null = 0x15
Global Const $file_device_parallel_port = 0x16
Global Const $file_device_physical_netcard = 0x17
Global Const $file_device_printer = 0x18
Global Const $file_device_scanner = 0x19
Global Const $file_device_screen = 0x1c
Global Const $file_device_serenum = 0x37
Global Const $file_device_serial_mouse_port = 0x1a
Global Const $file_device_serial_port = 0x1b
Global Const $file_device_smartcard = 0x31
Global Const $file_device_smb = 0x2e
Global Const $file_device_sound = 0x1d
Global Const $file_device_streams = 0x1e
Global Const $file_device_tape = 0x1f
Global Const $file_device_tape_file_system = 0x20
Global Const $file_device_termsrv = 0x38
Global Const $file_device_transport = 0x21
Global Const $file_device_unknown = 0x22
Global Const $file_device_vdm = 0x2c
Global Const $file_device_video = 0x23
Global Const $file_device_virtual_disk = 0x24
Global Const $file_device_wave_in = 0x25
Global Const $file_device_wave_out = 0x26
Global Const $file_any_access = 0x0
Global Const $file_special_access = $file_any_access
Global Const $file_read_access = 0x1
Global Const $file_write_access = 0x2
Global Const $method_buffered = 0x0
Global Const $method_in_direct = 0x1
Global Const $method_out_direct = 0x2
Global Const $method_neither = 0x3
Global Const $file_notify_change_file_name = 0x1
Global Const $file_notify_change_dir_name = 0x2
Global Const $file_notify_change_attributes = 0x4
Global Const $file_notify_change_size = 0x8
Global Const $file_notify_change_last_write = 0x10
Global Const $file_notify_change_last_access = 0x20
Global Const $file_notify_change_creation = 0x40
Global Const $file_notify_change_security = 0x100
Global Const $file_action_added = 0x1
Global Const $file_action_removed = 0x2
Global Const $file_action_modified = 0x3
Global Const $file_action_renamed_old_name = 0x4
Global Const $file_action_renamed_new_name = 0x5
Global Const $replacefile_write_through = 0x1
Global Const $replacefile_ignore_merge_errors = 0x2
Global Const $replacefile_ignore_acl_errors = 0x4
Global Const $base_search_path_enable_safe_searchmode = 0x1
Global Const $base_search_path_disable_safe_searchmode = 0x10000
Global Const $base_search_path_permanent = 0x8000
Global Const $gmem_fixed = 0x0
Global Const $gmem_moveable = 0x2
Global Const $gmem_nocompact = 0x10
Global Const $gmem_nodiscard = 0x20
Global Const $gmem_zeroinit = 0x40
Global Const $gmem_modify = 0x80
Global Const $gmem_discardable = 0x100
Global Const $gmem_not_banked = 0x1000
Global Const $gmem_share = 0x2000
Global Const $gmem_ddeshare = 0x2000
Global Const $gmem_notify = 0x4000
Global Const $gmem_lower = 0x1000
Global Const $gmem_valid_flags = 0x7f72
Global Const $gmem_invalid_handle = 0x8000
Global Const $gptr = BitOR($gmem_fixed, $gmem_zeroinit)
Global Const $ghnd = BitOR($gmem_moveable, $gmem_zeroinit)
Global Const $mem_commit = 0x1000
Global Const $mem_reserve = 0x2000
Global Const $mem_top_down = 0x100000
Global Const $mem_shared = 0x8000000
Global Const $page_noaccess = 0x1
Global Const $page_readonly = 0x2
Global Const $page_readwrite = 0x4
Global Const $page_execute = 0x10
Global Const $page_execute_read = 0x20
Global Const $page_execute_readwrite = 0x40
Global Const $page_execute_writecopy = 0x80
Global Const $page_guard = 0x100
Global Const $page_nocache = 0x200
Global Const $page_writecombine = 0x400
Global Const $page_writecopy = 0x8
Global Const $mem_decommit = 0x4000
Global Const $mem_release = 0x8000
Global Enum $mem_load, $mem_totalphysram, $mem_availphysram, $mem_totalpagefile, $mem_availpagefile, $mem_totalvirtual, $mem_availvirtual
#region Global Variables and Constants
Global $__g_iheapsize = 0x800000
Global Const $tagfileinfo = "uint64 CreationTime;uint64 LastAccessTime;uint64 LastWriteTime;uint64 ChangeTime;dword Attributes"
Global Const $tagfile_id_descriptor = "dword Size;uint Type;" & $tagguid
Global Const $tagwin32_find_stream_data = "int64 StreamSize;wchar StreamName[296]"
Global Const $tagwin32_stream_id = "dword StreamId;dword StreamAttributes;int64 Size;dword StreamNameSize;wchar StreamName[1]"
#endregion Global Variables and Constants
#region Functions list
#endregion Functions list
#region Public Functions
Func _WINAPI_BACKUPREAD($hfile, $pbuffer, $ilength, ByRef $ibytes, ByRef $pcontext, $bsecurity = False)
    $ibytes = 0x0
    Local $acall = DllCall("kernel32.dll", "bool", "BackupRead", "handle", $hfile, "struct*", $pbuffer, "dword", $ilength, "dword*", 0x0, "bool", 0x0, "bool", $bsecurity, "ptr*", $pcontext)
    If @error Or Not $acall[0x0] Then Return SetError(@error, @extended, False)
    $ibytes = $acall[0x4]
    $pcontext = $acall[0x7]
    Return $acall[0x0]
EndFunc   ;==>_WINAPI_BACKUPREAD
Func _WINAPI_BACKUPREADABORT(ByRef $pcontext)
    Local $acall = DllCall("kernel32.dll", "bool", "BackupRead", "handle", 0x0, "ptr", 0x0, "dword", 0x0, "dword*", 0x0, "bool", 0x1, "bool", 0x0, "ptr*", $pcontext)
    If @error Or Not $acall[0x0] Then Return SetError(@error, @extended, False)
    $pcontext = $acall[0x7]
    Return $acall[0x0]
EndFunc   ;==>_WINAPI_BACKUPREADABORT
Func _WINAPI_BACKUPSEEK($hfile, $iseek, ByRef $ibytes, ByRef $pcontext)
    $ibytes = 0x0
    Local $acall = DllCall("kernel32.dll", "bool", "BackupSeek", "handle", $hfile, "dword", _WINAPI_LODWORD($iseek), "dword", _WINAPI_HIDWORD($iseek), "dword*", 0x0, "dword*", 0x0, "ptr*", $pcontext)
    If @error Or Not $acall[0x0] Then Return SetError(@error, @extended, False)
    $ibytes = __WINAPI_MAKEQWORD($acall[0x4], $acall[0x5])
    $pcontext = $acall[0x6]
    Return $acall[0x0]
EndFunc   ;==>_WINAPI_BACKUPSEEK
Func _WINAPI_BACKUPWRITE($hfile, $pbuffer, $ilength, ByRef $ibytes, ByRef $pcontext, $bsecurity = False)
    $ibytes = 0x0
    Local $acall = DllCall("kernel32.dll", "bool", "BackupWrite", "handle", $hfile, "struct*", $pbuffer, "dword", $ilength, "dword*", 0x0, "bool", 0x0, "bool", $bsecurity, "ptr*", $pcontext)
    If @error Or Not $acall[0x0] Then Return SetError(@error, @extended, False)
    $ibytes = $acall[0x4]
    $pcontext = $acall[0x7]
    Return $acall[0x0]
EndFunc   ;==>_WINAPI_BACKUPWRITE
Func _WINAPI_BACKUPWRITEABORT(ByRef $pcontext)
    Local $acall = DllCall("kernel32.dll", "bool", "BackupWrite", "handle", 0x0, "ptr", 0x0, "dword", 0x0, "dword*", 0x0, "bool", 0x1, "bool", 0x0, "ptr*", $pcontext)
    If @error Or Not $acall[0x0] Then Return SetError(@error, @extended, False)
    $pcontext = $acall[0x7]
    Return $acall[0x0]
EndFunc   ;==>_WINAPI_BACKUPWRITEABORT
Func _WINAPI_COPYFILEEX($sexistingfile, $snewfile, $iflags = 0x0, $pprogressproc = 0x0, $pdata = 0x0)
    Local $acall = DllCall("kernel32.dll", "bool", "CopyFileExW", "wstr", $sexistingfile, "wstr", $snewfile, "ptr", $pprogressproc, "struct*", $pdata, "bool*", 0x0, "dword", $iflags)
    If @error Then Return SetError(@error, @extended, 0x0)
    Return $acall[0x0]
EndFunc   ;==>_WINAPI_COPYFILEEX
Func _WINAPI_CREATEDIRECTORY($sdir, $tsecurity = 0x0)
    Local $acall = DllCall("kernel32.dll", "bool", "CreateDirectoryW", "wstr", $sdir, "struct*", $tsecurity)
    If @error Then Return SetError(@error, @extended, False)
    Return $acall[0x0]
EndFunc   ;==>_WINAPI_CREATEDIRECTORY
Func _WINAPI_CREATEDIRECTORYEX($snewdir, $stemplatedir, $tsecurity = 0x0)
    Local $acall = DllCall("kernel32.dll", "bool", "CreateDirectoryExW", "wstr", $stemplatedir, "wstr", $snewdir, "struct*", $tsecurity)
    If @error Then Return SetError(@error, @extended, False)
    Return $acall[0x0]
EndFunc   ;==>_WINAPI_CREATEDIRECTORYEX
Func _WINAPI_CREATEFILEEX($sfilepath, $icreation, $iaccess = 0x0, $ishare = 0x0, $iflagsandattributes = 0x0, $tsecurity = 0x0, $htemplate = 0x0)
    Local $acall = DllCall("kernel32.dll", "handle", "CreateFileW", "wstr", $sfilepath, "dword", $iaccess, "dword", $ishare, "struct*", $tsecurity, "dword", $icreation, "dword", $iflagsandattributes, "handle", $htemplate)
    If @error Then Return SetError(@error, @extended, 0x0)
    If $acall[0x0] = Ptr(+0xffffffff) Then Return SetError(0xa, _WinAPI_GetLastError(), 0x0)
    Return $acall[0x0]
EndFunc   ;==>_WINAPI_CREATEFILEEX
Func _WINAPI_CREATEFILEMAPPING($hfile, $isize = 0x0, $sname = "", $iprotect = 0x4, $tsecurity = 0x0)
    If Not StringStripWS($sname, $str_stripleading + $str_striptrailing) Then $sname = NULL
    Local $acall = DllCall("kernel32.dll", "handle", "CreateFileMappingW", "handle", $hfile, "struct*", $tsecurity, "dword", $iprotect, "dword", _WINAPI_HIDWORD($isize), "dword", _WINAPI_LODWORD($isize), "wstr", $sname)
    If @error Then Return SetError(@error, @extended, 0x0)
    Return SetExtended(_WinAPI_GetLastError(), $acall[0x0])
EndFunc   ;==>_WINAPI_CREATEFILEMAPPING
Func _WINAPI_CREATEHARDLINK($snewfile, $sexistingfile)
    Local $acall = DllCall("kernel32.dll", "bool", "CreateHardLinkW", "wstr", $snewfile, "wstr", $sexistingfile, "ptr", 0x0)
    If @error Then Return SetError(@error, @extended, False)
    Return $acall[0x0]
EndFunc   ;==>_WINAPI_CREATEHARDLINK
Func _WINAPI_CREATEOBJECTID($sfilepath)
    Local $hfile = _WINAPI_CREATEFILEEX($sfilepath, $open_existing, 0x0, $file_share_readwrite, $file_flag_backup_semantics)
    If @error Then Return SetError(@error + 0x14, @extended, 0x0)
    Local $tfoid = DllStructCreate("byte[16];byte[48]")
    Local $acall = DllCall("kernel32.dll", "bool", "DeviceIoControl", "handle", $hfile, "dword", 0x900c0, "ptr", 0x0, "dword", 0x0, "struct*", $tfoid, "dword", DllStructGetSize($tfoid), "dword*", 0x0, "ptr", 0x0)
    If __CHECKERRORCLOSEHANDLE($acall, $hfile) Then Return SetError(@error, @extended, 0x0)
    Local $tguid = DllStructCreate($tagguid)
    _WINAPI_MOVEMEMORY($tguid, $tfoid, 0x10)
    Return $tguid
EndFunc   ;==>_WINAPI_CREATEOBJECTID
Func _WINAPI_CREATESYMBOLICLINK($ssymlink, $starget, $bdirectory = False)
    If $bdirectory Then
        $bdirectory = 0x1
    EndIf
    Local $acall = DllCall("kernel32.dll", "boolean", "CreateSymbolicLinkW", "wstr", $ssymlink, "wstr", $starget, "dword", $bdirectory)
    If @error Then Return SetError(@error, @extended, False)
    Return $acall[0x0]
EndFunc   ;==>_WINAPI_CREATESYMBOLICLINK
Func _WINAPI_DECRYPTFILE($sfilepath)
    Local $acall = DllCall("advapi32.dll", "bool", "DecryptFileW", "wstr", $sfilepath, "dword", 0x0)
    If @error Then Return SetError(@error, @extended, False)
    Return $acall[0x0]
EndFunc   ;==>_WINAPI_DECRYPTFILE
Func _WINAPI_DEFINEDOSDEVICE($sdevice, $iflags, $sfilepath = "")
    If Not StringStripWS($sfilepath, $str_stripleading + $str_striptrailing) Then $sfilepath = NULL
    Local $acall = DllCall("kernel32.dll", "bool", "DefineDosDeviceW", "dword", $iflags, "wstr", $sdevice, "wstr", $sfilepath)
    If @error Then Return SetError(@error, @extended, False)
    Return $acall[0x0]
EndFunc   ;==>_WINAPI_DEFINEDOSDEVICE
Func _WINAPI_DELETEFILE($sfilepath)
    Local $acall = DllCall("kernel32.dll", "bool", "DeleteFileW", "wstr", $sfilepath)
    If @error Then Return SetError(@error, @extended, False)
    Return $acall[0x0]
EndFunc   ;==>_WINAPI_DELETEFILE
Func _WINAPI_DELETEOBJECTID($sfilepath)
    Local $hfile = _WINAPI_CREATEFILEEX($sfilepath, $open_existing, $generic_write, $file_share_readwrite, $file_flag_backup_semantics)
    If @error Then Return SetError(@error + 0x14, @extended, 0x0)
    Local $acall = DllCall("kernel32.dll", "bool", "DeviceIoControl", "handle", $hfile, "dword", 0x900a0, "ptr", 0x0, "dword", 0x0, "ptr", 0x0, "dword", 0x0, "dword*", 0x0, "ptr", 0x0)
    If __CHECKERRORCLOSEHANDLE($acall, $hfile) Then Return SetError(@error, @extended, 0x0)
    Return 0x1
EndFunc   ;==>_WINAPI_DELETEOBJECTID
Func _WINAPI_DELETEVOLUMEMOUNTPOINT($smountedpath)
    Local $acall = DllCall("kernel32.dll", "bool", "DeleteVolumeMountPointW", "wstr", $smountedpath)
    If @error Then Return SetError(@error, @extended, 0x0)
    Return $acall[0x0]
EndFunc   ;==>_WINAPI_DELETEVOLUMEMOUNTPOINT
Func _WINAPI_DEVICEIOCONTROL($hdevice, $icontrolcode, $pinbuffer = 0x0, $iinbuffersize = 0x0, $poutbuffer = 0x0, $ioutbuffersize = 0x0)
    Local $acall = DllCall("kernel32.dll", "bool", "DeviceIoControl", "handle", $hdevice, "dword", $icontrolcode, "struct*", $pinbuffer, "dword", $iinbuffersize, "struct*", $poutbuffer, "dword", $ioutbuffersize, "dword*", 0x0, "ptr", 0x0)
    If @error Then Return SetError(@error, @extended, False)
    Return SetExtended($acall[0x7], $acall[0x0])
EndFunc   ;==>_WINAPI_DEVICEIOCONTROL
Func _WINAPI_DUPLICATEENCRYPTIONINFOFILE($ssrcfilepath, $sdestfilepath, $icreation = 0x2, $iattributes = 0x0, $tsecurity = 0x0)
    Local $acall = DllCall("advapi32.dll", "dword", "DuplicateEncryptionInfoFile", "wstr", $ssrcfilepath, "wstr", $sdestfilepath, "dword", $icreation, "dword", $iattributes, "struct*", $tsecurity)
    If @error Then Return SetError(@error, @extended, 0x0)
    If $acall[0x0] Then Return SetError(0xa, $acall[0x0], 0x0)
    Return 0x1
EndFunc   ;==>_WINAPI_DUPLICATEENCRYPTIONINFOFILE
Func _WINAPI_EJECTMEDIA($sdrive)
    Local $hfile = _WINAPI_CREATEFILEEX("\\.\" & $sdrive, $open_existing, $generic_read, $file_share_readwrite)
    If @error Then Return SetError(@error + 0x14, @extended, 0x0)
    Local $acall = DllCall("kernel32.dll", "bool", "DeviceIoControl", "handle", $hfile, "dword", 0x2d4808, "ptr", 0x0, "dword", 0x0, "ptr", 0x0, "dword", 0x0, "dword*", 0x0, "ptr", 0x0)
    If __CHECKERRORCLOSEHANDLE($acall, $hfile) Then Return SetError(@error, @extended, 0x0)
    Return 0x1
EndFunc   ;==>_WINAPI_EJECTMEDIA
Func _WINAPI_ENCRYPTFILE($sfilepath)
    Local $acall = DllCall("advapi32.dll", "bool", "EncryptFileW", "wstr", $sfilepath)
    If @error Then Return SetError(@error, @extended, False)
    Return $acall[0x0]
EndFunc   ;==>_WINAPI_ENCRYPTFILE
Func _WINAPI_ENCRYPTIONDISABLE($sdir, $bdisable)
    Local $acall = DllCall("advapi32.dll", "bool", "EncryptionDisable", "wstr", $sdir, "bool", $bdisable)
    If @error Then Return SetError(@error, @extended, False)
    Return $acall[0x0]
EndFunc   ;==>_WINAPI_ENCRYPTIONDISABLE
Func _WINAPI_ENUMFILES($sdir, $iflag = 0x0, $stemplate = "", $bexclude = False)
    Local $acall, $ierror = 0x0
    Local $adata[0x1f5][0x7] = [[0x0]]
    Local $hdir = _WINAPI_CREATEFILEEX($sdir, $open_existing, 0x1, $file_share_any, $file_flag_backup_semantics)
    If @error Then Return SetError(@error + 0x14, @extended, 0x0)
    Local $pbuffer = __HEAPALLOC($__g_iheapsize)
    If @error Then
        $ierror = @error
    Else
        Local $tiosb = DllStructCreate("ptr;ulong_ptr")
        $acall = DllCall("ntdll.dll", "uint", "ZwQueryDirectoryFile", "handle", $hdir, "ptr", 0x0, "ptr", 0x0, "ptr", 0x0, "struct*", $tiosb, "struct*", $pbuffer, "ulong", 0x800000, "uint", 0x1, "boolean", 0x0, "ptr", 0x0, "boolean", 0x1)
        If @error Or $acall[0x0] Then
            $ierror = @error + 0x28
        EndIf
    EndIf
    DllCall("kernel32.dll", "bool", "CloseHandle", "handle", $hdir)
    If $ierror Then
        __HEAPFREE($pbuffer, 0x1)
        If IsArray($acall) Then
            Return SetError(0xa, $acall[0x0], 0x0)
        Else
            Return SetError($ierror, 0x0, 0x0)
        EndIf
    EndIf
    Local $tfdi, $iattrib, $starget, $ilength = 0x0, $ioffset = 0x0
    Do
        $ilength += $ioffset
        $tfdi = DllStructCreate("ulong;ulong;int64;int64;int64;int64;int64;int64;ulong;ulong;wchar[" & (DllStructGetData(DllStructCreate("ulong", $pbuffer + $ilength + 0x3c), 0x1) / 0x2) & "]", $pbuffer + $ilength)
        $starget = DllStructGetData($tfdi, 0xb)
        $iattrib = DllStructGetData($tfdi, 0x9)
        $ioffset = DllStructGetData($tfdi, 0x1)
        Switch $starget
            Case ".", ".."
                ContinueLoop
            Case Else
                Switch $iflag
                    Case 0x1, 0x2
                        If BitAND($iattrib, 0x10) Then
                            If $iflag = 0x1 Then
                                ContinueLoop
                            EndIf
                        Else
                            If $iflag = 0x2 Then
                                ContinueLoop
                            EndIf
                        EndIf
                EndSwitch
                If $stemplate Then
                    $acall = DllCall("shlwapi.dll", "int", "PathMatchSpecW", "wstr", $starget, "wstr", $stemplate)
                    If @error Or ($acall[0x0] And $bexclude) Or (Not $acall[0x0] And Not $bexclude) Then
                        ContinueLoop
                    EndIf
                EndIf
        EndSwitch
        __INC($adata, 0x1f4)
        $adata[$adata[0x0][0x0]][0x0] = $starget
        $adata[$adata[0x0][0x0]][0x1] = DllStructGetData($tfdi, 0x3)
        $adata[$adata[0x0][0x0]][0x2] = DllStructGetData($tfdi, 0x4)
        $adata[$adata[0x0][0x0]][0x3] = DllStructGetData($tfdi, 0x5)
        $adata[$adata[0x0][0x0]][0x4] = DllStructGetData($tfdi, 0x7)
        $adata[$adata[0x0][0x0]][0x5] = DllStructGetData($tfdi, 0x8)
        $adata[$adata[0x0][0x0]][0x6] = $iattrib
    Until Not $ioffset
    __HEAPFREE($pbuffer)
    __INC($adata, +0xffffffff)
    Return $adata
EndFunc   ;==>_WINAPI_ENUMFILES
Func _WINAPI_ENUMFILESTREAMS($sfilepath)
    Local $tdata = DllStructCreate("byte[32768]")
    Local $pdata = DllStructGetPtr($tdata)
    Local $adata[0x65][0x2] = [[0x0]]
    Local $hfile = _WINAPI_CREATEFILEEX($sfilepath, $open_existing, 0x0, $file_share_readwrite, $file_flag_backup_semantics)
    If @error Then Return SetError(@error + 0x14, @extended, 0x0)
    Local $ierror = 0x0
    Local $tiosb = DllStructCreate("ptr;ulong_ptr")
    Local $acall = DllCall("ntdll.dll", "long", "ZwQueryInformationFile", "handle", $hfile, "struct*", $tiosb, "ptr", $pdata, "ulong", 0x8000, "uint", 0x16)
    If @error Then $ierror = @error
    DllCall("kernel32.dll", "bool", "CloseHandle", "handle", $hfile)
    If $ierror Then Return SetError($ierror, 0x0, 0x0)
    If $acall[0x0] Then Return SetError(0xa, $acall[0x0], 0x0)
    Local $tfsi, $ilength = 0x0, $ioffset = 0x0
    Do
        $ilength += $ioffset
        $tfsi = DllStructCreate("ulong;ulong;int64;int64;wchar[" & (DllStructGetData(DllStructCreate("ulong", $pdata + $ilength + 0x4), 0x1) / 0x2) & "]", $pdata + $ilength)
        __INC($adata)
        $adata[$adata[0x0][0x0]][0x0] = DllStructGetData($tfsi, 0x5)
        $adata[$adata[0x0][0x0]][0x1] = DllStructGetData($tfsi, 0x3)
        $ioffset = DllStructGetData($tfsi, 0x1)
    Until Not $ioffset
    __INC($adata, +0xffffffff)
    Return $adata
EndFunc   ;==>_WINAPI_ENUMFILESTREAMS
Func _WINAPI_ENUMHARDLINKS($sfilepath)
    Local $tdata = DllStructCreate("byte[32768]")
    Local $pdata = DllStructGetPtr($tdata)
    Local $hfile = _WINAPI_CREATEFILEEX($sfilepath, $open_existing, 0x0, $file_share_readwrite)
    If @error Then Return SetError(@error + 0x14, @extended, 0x0)
    Local $ierror = 0x0
    Local $tiosb = DllStructCreate("ptr;ulong_ptr")
    Local $acall = DllCall("ntdll.dll", "long", "ZwQueryInformationFile", "handle", $hfile, "struct*", $tiosb, "ptr", $pdata, "ulong", 0x8000, "uint", 0x2e)
    If @error Or $acall[0x0] Then
        $ierror = @error + 0xa
        DllCall("kernel32.dll", "bool", "CloseHandle", "handle", $hfile)
        If $acall Then Return SetError($ierror, 0x0, 0x0)
        If $acall[0x0] Then Return SetError(0xa, $ierror, 0x0)
    EndIf
    Local $icount = DllStructGetData(DllStructCreate("ulong;ulong", $pdata), 0x2)
    Local $adata[$icount + 0x1] = [$icount]
    Local $tflei, $hpath, $spath, $ilength = 0x8
    For $i = 0x1 To $icount
        $tflei = DllStructCreate("ulong;int64;ulong;wchar[" & (DllStructGetData(DllStructCreate("ulong", $pdata + $ilength + 0x10), 0x1)) & "]", $pdata + $ilength)
        $ierror = 0x0
        Do
            $hpath = _WINAPI_OPENFILEBYID($hfile, DllStructGetData($tflei, 0x2), 0x100080, $file_share_readwrite, $file_flag_backup_semantics)
            If @error Then
                $ierror = @error + 0x64
                ExitLoop
            EndIf
            $spath = _WINAPI_GETFINALPATHNAMEBYHANDLEEX($hpath)
            If @error Then
                $ierror = @error + 0xc8
                ExitLoop
            EndIf
        Until 0x1
        If $hpath Then
            DllCall("kernel32.dll", "bool", "CloseHandle", "handle", $hpath)
        EndIf
        If $ierror Then ExitLoop
        $adata[$i] = _WINAPI_PATHAPPEND($spath, DllStructGetData($tflei, 0x4))
        $ilength += DllStructGetData($tflei, 0x1)
    Next
    DllCall("kernel32.dll", "bool", "CloseHandle", "handle", $hfile)
    If $ierror Then Return SetError($ierror, 0x0, 0x0)
    Return $adata
EndFunc   ;==>_WINAPI_ENUMHARDLINKS
Func _WINAPI_FILEENCRYPTIONSTATUS($sfilepath)
    Local $acall = DllCall("advapi32.dll", "bool", "FileEncryptionStatusW", "wstr", $sfilepath, "dword*", 0x0)
    If @error Or Not $acall[0x0] Then Return SetError(@error + 0xa, @extended, +0xffffffff)
    Return $acall[0x2]
EndFunc   ;==>_WINAPI_FILEENCRYPTIONSTATUS
Func _WINAPI_FILEEXISTS($sfilepath)
    If Not FileExists($sfilepath) Then Return 0x0
    If _WINAPI_PATHISDIRECTORY($sfilepath) Then Return SetExtended(0x1, 0x0)
    Return 0x1
EndFunc   ;==>_WINAPI_FILEEXISTS
Func _WINAPI_FILEINUSE($sfilepath)
    Local $hfile = _WINAPI_CREATEFILEEX($sfilepath, $open_existing, $generic_read)
    If @error Then
        If @extended = 0x20 Then Return 0x1
        Return SetError(@error, @extended, 0x0)
    EndIf
    DllCall("kernel32.dll", "bool", "CloseHandle", "handle", $hfile)
    Return 0x0
EndFunc   ;==>_WINAPI_FILEINUSE
Func _WINAPI_FINDCLOSE($hsearch)
    Local $acall = DllCall("kernel32.dll", "bool", "FindClose", "handle", $hsearch)
    If @error Then Return SetError(@error, @extended, False)
    Return $acall[0x0]
EndFunc   ;==>_WINAPI_FINDCLOSE
Func _WINAPI_FINDCLOSECHANGENOTIFICATION($hchange)
    Local $acall = DllCall("kernel32.dll", "bool", "FindCloseChangeNotification", "handle", $hchange)
    If @error Then Return SetError(@error, @extended, False)
    Return $acall[0x0]
EndFunc   ;==>_WINAPI_FINDCLOSECHANGENOTIFICATION
Func _WINAPI_FINDFIRSTCHANGENOTIFICATION($sdirectory, $iflags, $bsubtree = False)
    Local $acall = DllCall("kernel32.dll", "handle", "FindFirstChangeNotificationW", "wstr", $sdirectory, "bool", $bsubtree, "dword", $iflags)
    If @error Or ($acall[0x0] = Ptr(+0xffffffff)) Then Return SetError(@error + 0xa, @extended, 0x0)
    Return $acall[0x0]
EndFunc   ;==>_WINAPI_FINDFIRSTCHANGENOTIFICATION
Func _WINAPI_FINDFIRSTFILE($sfilepath, $tdata)
    Local $acall = DllCall("kernel32.dll", "handle", "FindFirstFileW", "wstr", $sfilepath, "struct*", $tdata)
    If @error Then Return SetError(@error, @extended, 0x0)
    If $acall[0x0] = Ptr(+0xffffffff) Then Return SetError(0xa, _WinAPI_GetLastError(), 0x0)
    Return $acall[0x0]
EndFunc   ;==>_WINAPI_FINDFIRSTFILE
Func _WINAPI_FINDFIRSTFILENAME($sfilepath, ByRef $slink)
    $slink = ""
    Local $acall = DllCall("kernel32.dll", "handle", "FindFirstFileNameW", "wstr", $sfilepath, "dword", 0x0, "dword*", 0x1000, "wstr", "")
    If @error Or ($acall[0x0] = Ptr(+0xffffffff)) Then Return SetError(@error + 0xa, @extended, 0x0)
    $slink = $acall[0x4]
    Return $acall[0x0]
EndFunc   ;==>_WINAPI_FINDFIRSTFILENAME
Func _WINAPI_FINDFIRSTSTREAM($sfilepath, $tdata)
    Local $acall = DllCall("kernel32.dll", "handle", "FindFirstStreamW", "wstr", $sfilepath, "uint", 0x0, "struct*", $tdata, "dword", 0x0)
    If @error Then Return SetError(@error, @extended, 0x0)
    If $acall[0x0] = Ptr(+0xffffffff) Then Return SetError(0xa, _WinAPI_GetLastError(), 0x0)
    Return $acall[0x0]
EndFunc   ;==>_WINAPI_FINDFIRSTSTREAM
Func _WINAPI_FINDNEXTCHANGENOTIFICATION($hchange)
    Local $acall = DllCall("kernel32.dll", "bool", "FindNextChangeNotification", "handle", $hchange)
    If @error Then Return SetError(@error, @extended, 0x0)
    Return $acall[0x0]
EndFunc   ;==>_WINAPI_FINDNEXTCHANGENOTIFICATION
Func _WINAPI_FINDNEXTFILE($hsearch, $tdata)
    Local $acall = DllCall("kernel32.dll", "bool", "FindNextFileW", "handle", $hsearch, "struct*", $tdata)
    If @error Then Return SetError(@error, @extended, False)
    If Not $acall[0x0] Then Return SetError(0xa, _WinAPI_GetLastError(), 0x0)
    Return $acall[0x0]
EndFunc   ;==>_WINAPI_FINDNEXTFILE
Func _WINAPI_FINDNEXTFILENAME($hsearch, ByRef $slink)
    $slink = ""
    Local $acall = DllCall("kernel32.dll", "bool", "FindNextFileNameW", "handle", $hsearch, "dword*", 0x1000, "wstr", "")
    If @error Then Return SetError(@error, @extended, False)
    If Not $acall[0x0] Then Return SetError(0xa, _WinAPI_GetLastError(), 0x0)
    $slink = $acall[0x3]
    Return $acall[0x0]
EndFunc   ;==>_WINAPI_FINDNEXTFILENAME
Func _WINAPI_FINDNEXTSTREAM($hsearch, $tdata)
    Local $acall = DllCall("kernel32.dll", "bool", "FindNextStreamW", "handle", $hsearch, "struct*", $tdata)
    If @error Then Return SetError(@error, @extended, False)
    If Not $acall[0x0] Then Return SetError(0xa, _WinAPI_GetLastError(), 0x0)
    Return $acall[0x0]
EndFunc   ;==>_WINAPI_FINDNEXTSTREAM
Func _WinAPI_FlushFileBuffers($hfile)
    Local $acall = DllCall("kernel32.dll", "bool", "FlushFileBuffers", "handle", $hfile)
    If @error Then Return SetError(@error, @extended, False)
    Return $acall[0x0]
EndFunc   ;==>_WINAPI_FLUSHFILEBUFFERS
Func _WINAPI_FLUSHVIEWOFFILE($paddress, $ibytes = 0x0)
    Local $acall = DllCall("kernel32.dll", "bool", "FlushViewOfFile", "struct*", $paddress, "dword", $ibytes)
    If @error Then Return SetError(@error, @extended, 0x0)
    Return $acall[0x0]
EndFunc   ;==>_WINAPI_FLUSHVIEWOFFILE
Func _WINAPI_GETBINARYTYPE($sfilepath)
    Local $acall = DllCall("kernel32.dll", "int", "GetBinaryTypeW", "wstr", $sfilepath, "dword*", 0x0)
    If @error Then Return SetError(@error, @extended, 0x0)
    If Not $acall[0x0] Then $acall[0x2] = 0x0
    Return SetExtended($acall[0x2], $acall[0x0])
EndFunc   ;==>_WINAPI_GETBINARYTYPE
Func _WINAPI_GETCDTYPE($sdrive)
    Local $hfile = _WINAPI_CREATEFILEEX("\\.\" & $sdrive, $open_existing, $generic_readwrite, $file_share_readwrite)
    If @error Then Return SetError(@error + 0x14, @extended, 0x0)
    Local $tagscsi_pass_through = "struct;ushort Length;byte ScsiStatus;byte PathId;byte TargetId;byte Lun;byte CdbLength;byte SenseInfoLength;byte DataIn;ulong DataTransferLength;ulong TimeOutValue;ulong_ptr DataBufferOffset;ulong SenseInfoOffset;byte Cdb[16];endstruct"
    Local $tspt = DllStructCreate($tagscsi_pass_through & ";byte Hdr[8]")
    Local $tcdb = DllStructCreate("byte;byte;byte[2];byte[3];byte[2];byte;byte[2];byte[4]", DllStructGetPtr($tspt, "Cdb"))
    Local $thdr = DllStructCreate("byte[4];byte;byte;byte[2]", DllStructGetPtr($tspt, "Hdr"))
    Local $isize = DllStructGetPtr($tspt, "Hdr") - DllStructGetPtr($tspt)
    DllStructSetData($tspt, "Length", $isize)
    DllStructSetData($tspt, "ScsiStatus", 0x0)
    DllStructSetData($tspt, "PathId", 0x0)
    DllStructSetData($tspt, "TargetId", 0x0)
    DllStructSetData($tspt, "Lun", 0x0)
    DllStructSetData($tspt, "CdbLength", 0xc)
    DllStructSetData($tspt, "SenseInfoLength", 0x0)
    DllStructSetData($tspt, "DataIn", 0x1)
    DllStructSetData($tspt, "DataTransferLength", 0x8)
    DllStructSetData($tspt, "TimeOutValue", 0x15180)
    DllStructSetData($tspt, "DataBufferOffset", $isize)
    DllStructSetData($tspt, "SenseInfoOffset", 0x0)
    DllStructSetData($tcdb, 0x1, 0x46)
    DllStructSetData($tcdb, 0x2, 0x0)
    DllStructSetData($tcdb, 0x3, 0x0, 0x1)
    DllStructSetData($tcdb, 0x3, 0x0, 0x2)
    DllStructSetData($tcdb, 0x5, 0x0, 0x1)
    DllStructSetData($tcdb, 0x5, 0x8, 0x2)
    DllStructSetData($tcdb, 0x6, 0x0)
    DllStructSetData($tcdb, 0x7, 0x0, 0x1)
    DllStructSetData($tcdb, 0x7, 0x0, 0x2)
    Local $acall = DllCall("kernel32.dll", "bool", "DeviceIoControl", "handle", $hfile, "dword", 0x4d004, "struct*", $tspt, "dword", $isize, "struct*", $tspt, "dword", DllStructGetSize($tspt), "dword*", 0x0, "ptr", 0x0)
    If __CHECKERRORCLOSEHANDLE($acall, $hfile) Then Return SetError(@error, @extended, 0x0)
    Return BitOR(BitShift(DllStructGetData($thdr, 0x4, 0x1), +0xfffffff8), DllStructGetData($thdr, 0x4, 0x2))
EndFunc   ;==>_WINAPI_GETCDTYPE
Func _WINAPI_GETCOMPRESSEDFILESIZE($sfilepath)
    Local $acall = DllCall("kernel32.dll", "dword", "GetCompressedFileSizeW", "wstr", $sfilepath, "dword*", 0x0)
    If @error Then Return SetError(@error, @extended, 0x0)
    If $acall[0x0] = +0xffffffff Then
        Local $ilasterror = _WinAPI_GetLastError()
        If $acall[0x2] = 0x0 Then Return SetError(0xa, $ilasterror, 0x0)
        If $ilasterror Then Return SetError(0xb, $ilasterror, 0x0)
    EndIf
    Return __WINAPI_MAKEQWORD($acall[0x0], $acall[0x2])
EndFunc   ;==>_WINAPI_GETCOMPRESSEDFILESIZE
Func _WINAPI_GETCOMPRESSION($sfilepath)
    Local $hfile = _WINAPI_CREATEFILEEX($sfilepath, $open_existing, $generic_read, $file_share_readwrite, $file_flag_backup_semantics)
    If @error Then Return SetError(@error + 0x14, @extended, 0x0)
    Local $acall = DllCall("kernel32.dll", "bool", "DeviceIoControl", "handle", $hfile, "dword", 0x9003c, "ptr", 0x0, "dword", 0x0, "ushort*", 0x0, "dword", 0x2, "dword*", 0x0, "ptr", 0x0)
    If __CHECKERRORCLOSEHANDLE($acall, $hfile) Then Return SetError(@error, @extended, +0xffffffff)
    Return $acall[0x5]
EndFunc   ;==>_WINAPI_GETCOMPRESSION
Func _WINAPI_GETCURRENTDIRECTORY()
    Local $acall = DllCall("kernel32.dll", "dword", "GetCurrentDirectoryW", "dword", 0x1000, "wstr", "")
    If @error Then Return SetError(@error, @extended, "")
    Return SetExtended($acall[0x0], $acall[0x2])
EndFunc   ;==>_WINAPI_GETCURRENTDIRECTORY
Func _WINAPI_GETDISKFREESPACEEX($sdrive)
    Local $acall = DllCall("kernel32.dll", "bool", "GetDiskFreeSpaceEx", "str", $sdrive, "int64*", 0x0, "int64*", 0x0, "int64*", 0x0)
    If @error Or Not $acall[0x0] Then Return SetError(@error + 0xa, @extended, 0x0)
    Local $aret[0x3]
    For $i = 0x0 To 0x2
        $aret[$i] = $acall[$i + 0x2]
    Next
    Return $aret
EndFunc   ;==>_WINAPI_GETDISKFREESPACEEX
Func _WINAPI_GETDRIVEBUSTYPE($sdrive)
    Local $hfile = _WINAPI_CREATEFILEEX("\\.\" & $sdrive, $open_existing, 0x0, $file_share_readwrite)
    If @error Then Return SetError(@error + 0x14, @extended, +0xffffffff)
    Local $tagstorage_property_query = "ulong PropertyId;ulong QueryType;byte AdditionalParameters[1]"
    Local $tspq = DllStructCreate($tagstorage_property_query)
    Local $tsdd = DllStructCreate("ulong Version;ulong Size;byte DeviceType;byte DeviceTypeModifier;byte RemovableMedia;byte CommandQueueing;ulong VendorIdOffset;ulong ProductIdOffset;ulong ProductRevisionOffset;ulong SerialNumberOffset;ulong BusType;ulong RawPropertiesLength;byte RawDeviceProperties[1]")
    DllStructSetData($tspq, "PropertyId", 0x0)
    DllStructSetData($tspq, "QueryType", 0x0)
    Local $acall = DllCall("kernel32.dll", "bool", "DeviceIoControl", "handle", $hfile, "dword", 0x2d1400, "struct*", $tspq, "dword", DllStructGetSize($tspq), "struct*", $tsdd, "dword", DllStructGetSize($tsdd), "dword*", 0x0, "ptr", 0x0)
    If __CHECKERRORCLOSEHANDLE($acall, $hfile) Then Return SetError(@error, @extended, +0xffffffff)
    Return DllStructGetData($tsdd, "BusType")
EndFunc   ;==>_WINAPI_GETDRIVEBUSTYPE
Func _WINAPI_GETDRIVEGEOMETRYEX($idrive)
    Local $hfile = _WINAPI_CREATEFILEEX("\\.\PhysicalDrive" & $idrive, $open_existing, 0x0, $file_share_readwrite)
    If @error Then Return SetError(@error + 0x14, @extended, 0x0)
    Local $tdgex = DllStructCreate("uint64;dword;dword;dword;dword;uint64")
    Local $acall = DllCall("kernel32.dll", "bool", "DeviceIoControl", "handle", $hfile, "dword", 0x700a0, "ptr", 0x0, "dword", 0x0, "struct*", $tdgex, "dword", DllStructGetSize($tdgex), "dword*", 0x0, "ptr", 0x0)
    If __CHECKERRORCLOSEHANDLE($acall, $hfile) Then Return SetError(@error, @extended, 0x0)
    Local $aret[0x6]
    For $i = 0x0 To 0x5
        $aret[$i] = DllStructGetData($tdgex, $i + 0x1)
    Next
    Return $aret
EndFunc   ;==>_WINAPI_GETDRIVEGEOMETRYEX
Func _WINAPI_GETDRIVENUMBER($sdrive)
    Local $hfile = _WINAPI_CREATEFILEEX("\\.\" & $sdrive, $open_existing, 0x0, $file_share_readwrite)
    If @error Then Return SetError(@error + 0x14, @extended, 0x0)
    Local $tsdn = DllStructCreate("dword;dword;dword")
    Local $acall = DllCall("kernel32.dll", "bool", "DeviceIoControl", "handle", $hfile, "dword", 0x2d1080, "ptr", 0x0, "dword", 0x0, "struct*", $tsdn, "dword", DllStructGetSize($tsdn), "dword*", 0x0, "ptr", 0x0)
    If __CHECKERRORCLOSEHANDLE($acall, $hfile) Then Return SetError(@error, @extended, 0x0)
    Local $aret[0x3]
    For $i = 0x0 To 0x2
        $aret[$i] = DllStructGetData($tsdn, $i + 0x1)
    Next
    Return $aret
EndFunc   ;==>_WINAPI_GETDRIVENUMBER
Func _WINAPI_GETDRIVETYPE($sdrive = "")
    If Not StringStripWS($sdrive, $str_stripleading + $str_striptrailing) Then $sdrive = NULL
    Local $acall = DllCall("kernel32.dll", "uint", "GetDriveType", "str", $sdrive)
    If @error Then Return SetError(@error, @extended, 0x0)
    Return $acall[0x0]
EndFunc   ;==>_WINAPI_GETDRIVETYPE
Func _WINAPI_GETFILEATTRIBUTES($sfilepath)
    Local $acall = DllCall("kernel32.dll", "dword", "GetFileAttributesW", "wstr", $sfilepath)
    If @error Or ($acall[0x0] = 0xffffffff) Then Return SetError(@error, @extended, 0x0)
    Return $acall[0x0]
EndFunc   ;==>_WINAPI_GETFILEATTRIBUTES
Func _WINAPI_GETFILEID($hfile)
    Local $tiosb = DllStructCreate("ptr;ulong_ptr")
    Local $acall = DllCall("ntdll.dll", "long", "ZwQueryInformationFile", "handle", $hfile, "struct*", $tiosb, "int64*", 0x0, "ulong", 0x8, "uint", 0x6)
    If @error Then Return SetError(@error, @extended, 0x0)
    If $acall[0x0] Then Return SetError(0xa, $acall[0x0], 0x0)
    Return $acall[0x3]
EndFunc   ;==>_WINAPI_GETFILEID
Func _WINAPI_GETFILEINFORMATIONBYHANDLE($hfile)
    Local $tbhfi = DllStructCreate("dword;dword[2];dword[2];dword[2];dword;dword;dword;dword;dword;dword")
    Local $acall = DllCall("kernel32.dll", "bool", "GetFileInformationByHandle", "handle", $hfile, "struct*", $tbhfi)
    If @error Or Not $acall[0x0] Then Return SetError(@error + 0xa, @extended, 0x0)
    Local $aret[0x8]
    $aret[0x0] = DllStructGetData($tbhfi, 0x1)
    For $i = 0x1 To 0x3
        If DllStructGetData($tbhfi, $i + 0x1) Then
            $aret[$i] = DllStructCreate($tagfiletime)
            _WINAPI_MOVEMEMORY($aret[$i], DllStructGetPtr($tbhfi, $i + 0x1), 0x8)
        Else
            $aret[$i] = 0x0
        EndIf
    Next
    $aret[0x4] = DllStructGetData($tbhfi, 0x5)
    $aret[0x5] = __WINAPI_MAKEQWORD(DllStructGetData($tbhfi, 0x7), DllStructGetData($tbhfi, 0x6))
    $aret[0x6] = DllStructGetData($tbhfi, 0x8)
    $aret[0x7] = __WINAPI_MAKEQWORD(DllStructGetData($tbhfi, 0x9), DllStructGetData($tbhfi, 0xa))
    Return $aret
EndFunc   ;==>_WINAPI_GETFILEINFORMATIONBYHANDLE
Func _WINAPI_GETFILEINFORMATIONBYHANDLEEX($hfile)
    Local $tfi = DllStructCreate($tagfileinfo)
    Local $tiosb = DllStructCreate("ptr;ulong_ptr")
    Local $acall = DllCall("ntdll.dll", "long", "ZwQueryInformationFile", "handle", $hfile, "struct*", $tiosb, "struct*", $tfi, "ulong", DllStructGetSize($tfi), "uint", 0x4)
    If @error Then Return SetError(@error, @extended, 0x0)
    If $acall[0x0] Then Return SetError(0xa, $acall[0x0], 0x0)
    Return $tfi
EndFunc   ;==>_WINAPI_GETFILEINFORMATIONBYHANDLEEX
Func _WINAPI_GETFILEPOINTEREX($hfile)
    Local $tiosb = DllStructCreate("ptr;ulong_ptr")
    Local $acall = DllCall("ntdll.dll", "long", "ZwQueryInformationFile", "handle", $hfile, "struct*", $tiosb, "int64*", 0x0, "ulong", 0x8, "uint", 0xe)
    If @error Then Return SetError(@error, @extended, "")
    If $acall[0x0] Then Return SetError(0xa, $acall[0x0], "")
    Return $acall[0x3]
EndFunc   ;==>_WINAPI_GETFILEPOINTEREX
Func _WinAPI_GetFileSizeEx($hfile)
    Local $acall = DllCall("kernel32.dll", "bool", "GetFileSizeEx", "handle", $hfile, "int64*", 0x0)
    If @error Or Not $acall[0x0] Then Return SetError(@error, @extended, +0xffffffff)
    Return $acall[0x2]
EndFunc   ;==>_WINAPI_GETFILESIZEEX
Func _WINAPI_GETFILESIZEONDISK($sfilepath)
    Local $isize = FileGetSize($sfilepath)
    If @error Then Return SetError(@error + 0xa, @extended, 0x0)
    Local $acall = DllCall("kernel32.dll", "bool", "GetDiskFreeSpaceW", "wstr", _WINAPI_PATHSTRIPTOROOT(_WINAPI_GETFULLPATHNAME($sfilepath)), "dword*", 0x0, "dword*", 0x0, "dword*", 0x0, "dword*", 0x0)
    If @error Or Not $acall[0x0] Then Return SetError(@error, @extended, 0x0)
    Return Ceiling($isize / ($acall[0x2] * $acall[0x3])) * ($acall[0x2] * $acall[0x3])
EndFunc   ;==>_WINAPI_GETFILESIZEONDISK
Func _WINAPI_GETFILETITLE($sfilepath)
    Local $acall = DllCall("comdlg32.dll", "short", "GetFileTitleW", "wstr", $sfilepath, "wstr", "", "word", 0x1000)
    If @error Or $acall[0x0] Then Return SetError(@error + 0xa, @extended, "")
    Return $acall[0x2]
EndFunc   ;==>_WINAPI_GETFILETITLE
Func _WINAPI_GETFILETYPE($hfile)
    Local $acall = DllCall("kernel32.dll", "dword", "GetFileType", "handle", $hfile)
    If @error Then Return SetError(@error, @extended, +0xffffffff)
    Local $ilasterror = _WinAPI_GetLastError()
    If Not $acall[0x0] And $ilasterror Then Return SetError(0xa, $ilasterror, +0xffffffff)
    Return $acall[0x0]
EndFunc   ;==>_WINAPI_GETFILETYPE
Func _WINAPI_GETFINALPATHNAMEBYHANDLE($hfile)
    Local $tfni = DllStructCreate("ulong;wchar[4096]")
    Local $tiosb = DllStructCreate("ptr;ulong_ptr")
    Local $acall = DllCall("ntdll.dll", "long", "ZwQueryInformationFile", "handle", $hfile, "struct*", $tiosb, "struct*", $tfni, "ulong", DllStructGetSize($tfni), "uint", 0x9)
    If @error Then Return SetError(@error, @extended, "")
    If $acall[0x0] Then Return SetError(0xa, $acall[0x0], "")
    Local $ilength = DllStructGetData($tfni, 0x1)
    If Not $ilength Then Return SetError(0xc, 0x0, "")
    Return DllStructGetData(DllStructCreate("wchar[" & ($ilength / 0x2) & "]", DllStructGetPtr($tfni, 0x2)), 0x1)
EndFunc   ;==>_WINAPI_GETFINALPATHNAMEBYHANDLE
Func _WINAPI_GETFINALPATHNAMEBYHANDLEEX($hfile, $iflags = 0x0)
    Local $acall = DllCall("kernel32.dll", "dword", "GetFinalPathNameByHandleW", "handle", $hfile, "wstr", "", "dword", 0x1000, "dword", $iflags)
    If @error Or Not $acall[0x0] Then Return SetError(@error + 0xa, @extended, "")
    Return $acall[0x2]
EndFunc   ;==>_WINAPI_GETFINALPATHNAMEBYHANDLEEX
Func _WINAPI_GETFULLPATHNAME($sfilepath)
    Local $acall = DllCall("kernel32.dll", "dword", "GetFullPathNameW", "wstr", $sfilepath, "dword", 0x1000, "wstr", "", "ptr", 0x0)
    If @error Or Not $acall[0x0] Then Return SetError(@error, @extended, "")
    Return $acall[0x3]
EndFunc   ;==>_WINAPI_GETFULLPATHNAME
Func _WINAPI_GETLOGICALDRIVES()
    Local $acall = DllCall("kernel32.dll", "dword", "GetLogicalDrives")
    If @error Then Return SetError(@error, @extended, 0x0)
    Return $acall[0x0]
EndFunc   ;==>_WINAPI_GETLOGICALDRIVES
Func _WINAPI_GETOBJECTID($sfilepath)
    Local $hfile = _WINAPI_CREATEFILEEX($sfilepath, $open_existing, 0x0, $file_share_readwrite, $file_flag_backup_semantics)
    If @error Then Return SetError(@error + 0x14, @extended, 0x0)
    Local $tfoid = DllStructCreate("byte[16];byte[48]")
    Local $acall = DllCall("kernel32.dll", "bool", "DeviceIoControl", "handle", $hfile, "dword", 0x9009c, "ptr", 0x0, "dword", 0x0, "struct*", $tfoid, "dword", DllStructGetSize($tfoid), "dword*", 0x0, "ptr", 0x0)
    If __CHECKERRORCLOSEHANDLE($acall, $hfile) Then Return SetError(@error, @extended, 0x0)
    Local $tguid = DllStructCreate($tagguid)
    _WINAPI_MOVEMEMORY($tguid, $tfoid, 0x10)
    Return $tguid
EndFunc   ;==>_WINAPI_GETOBJECTID
Func _WinAPI_GetOverlappedResult($hfile, $toverlapped, ByRef $ibytes, $bwait = False)
    Local $acall = DllCall("kernel32.dll", "bool", "GetOverlappedResult", "handle", $hfile, "struct*", $toverlapped, "dword*", 0x0, "bool", $bwait)
    If @error Then Return SetError(@error, @extended, False)
    $ibytes = $acall[0x3]
    Return $acall[0x0]
EndFunc   ;==>_WINAPI_GETOVERLAPPEDRESULT
Func _WINAPI_GETPETYPE($sfilepath)
    Local $tdata = DllStructCreate("ushort[2]")
    Local $tuint = DllStructCreate("uint", DllStructGetPtr($tdata))
    Local $hfile = _WINAPI_CREATEFILEEX($sfilepath, $open_existing, $generic_read, $file_share_readwrite)
    If @error Then Return SetError(@error + 0x14, @extended, 0x0)
    Local $ierror = 0x0, $ival
    Do
        Local $acall = DllCall("kernel32.dll", "bool", "ReadFile", "handle", $hfile, "struct*", $tdata, "dword", 0x2, "dword*", 0x0, "ptr", 0x0)
        If @error Or (Not $acall[0x0]) Or ($acall[0x4] <> 0x2) Then
            $ierror = @error + 0x1e
            ExitLoop
        EndIf
        $ival = DllStructGetData($tdata, 0x1, 0x1)
        If $ival <> 0x5a4d Then
            $ierror = 0x3
            ExitLoop
        EndIf
        If Not _WINAPI_SETFILEPOINTEREX($hfile, 0x3c) Then
            $ierror = @error + 0x28
            ExitLoop
        EndIf
        $acall = DllCall("kernel32.dll", "bool", "ReadFile", "handle", $hfile, "struct*", $tdata, "dword", 0x4, "dword*", 0x0, "ptr", 0x0)
        If @error Or (Not $acall[0x0]) Or ($acall[0x4] <> 0x4) Then
            $ierror = @error + 0x32
            ExitLoop
        EndIf
        If Not _WINAPI_SETFILEPOINTEREX($hfile, DllStructGetData($tuint, 0x1)) Then
            $ierror = @error + 0x3c
            ExitLoop
        EndIf
        $acall = DllCall("kernel32.dll", "bool", "ReadFile", "handle", $hfile, "struct*", $tdata, "dword", 0x4, "dword*", 0x0, "ptr", 0x0)
        If @error Or (Not $acall[0x0]) Or ($acall[0x4] <> 0x4) Then
            $ierror = @error + 0x46
            ExitLoop
        EndIf
        $ival = DllStructGetData($tuint, 0x1)
        If $ival <> 0x4550 Then
            $ierror = 0x4
            ExitLoop
        EndIf
        $acall = DllCall("kernel32.dll", "bool", "ReadFile", "handle", $hfile, "struct*", $tdata, "dword", 0x2, "dword*", 0x0, "ptr", 0x0)
        If @error Or (Not $acall[0x0]) Or ($acall[0x4] <> 0x2) Then
            $ierror = @error + 0x50
            ExitLoop
        EndIf
        $ival = DllStructGetData($tdata, 0x1, 0x1)
    Until 0x1
    DllCall("kernel32.dll", "bool", "CloseHandle", "handle", $hfile)
    If $ierror Then Return SetError($ierror, 0x0, 0x0)
    Return $ival
EndFunc   ;==>_WINAPI_GETPETYPE
Func _WINAPI_GETPROFILESDIRECTORY()
    Local $acall = DllCall("userenv.dll", "bool", "GetProfilesDirectoryW", "wstr", "", "dword*", 0x1000)
    If @error Or Not $acall[0x0] Then Return SetError(@error + 0xa, @extended, "")
    Return $acall[0x1]
EndFunc   ;==>_WINAPI_GETPROFILESDIRECTORY
Func _WINAPI_GETTEMPFILENAME($sfilepath, $sprefix = "")
    Local $acall = DllCall("kernel32.dll", "uint", "GetTempFileNameW", "wstr", $sfilepath, "wstr", $sprefix, "uint", 0x0, "wstr", "")
    If @error Or Not $acall[0x0] Then Return SetError(@error + 0xa, @extended, "")
    Return $acall[0x4]
EndFunc   ;==>_WINAPI_GETTEMPFILENAME
Func _WINAPI_GETVOLUMEINFORMATION($sroot = "")
    If Not StringStripWS($sroot, $str_stripleading + $str_striptrailing) Then $sroot = NULL
    Local $acall = DllCall("kernel32.dll", "bool", "GetVolumeInformationW", "wstr", $sroot, "wstr", "", "dword", 0x1000, "dword*", 0x0, "dword*", 0x0, "dword*", 0x0, "wstr", "", "dword", 0x1000)
    If @error Or Not $acall[0x0] Then Return SetError(@error + 0xa, @extended, 0x0)
    Local $aret[0x5]
    For $i = 0x0 To 0x4
        Switch $i
            Case 0x0
                $aret[$i] = $acall[0x2]
            Case Else
                $aret[$i] = $acall[$i + 0x3]
        EndSwitch
    Next
    Return $aret
EndFunc   ;==>_WINAPI_GETVOLUMEINFORMATION
Func _WINAPI_GETVOLUMEINFORMATIONBYHANDLE($hfile)
    Local $acall = DllCall("kernel32.dll", "bool", "GetVolumeInformationByHandleW", "handle", $hfile, "wstr", "", "dword", 0x1000, "dword*", 0x0, "dword*", 0x0, "dword*", 0x0, "wstr", "", "dword", 0x1000)
    If @error Or Not $acall[0x0] Then Return SetError(@error + 0xa, @extended, 0x0)
    Local $aret[0x5]
    For $i = 0x0 To 0x4
        Switch $i
            Case 0x0
                $aret[$i] = $acall[0x2]
            Case Else
                $aret[$i] = $acall[$i + 0x3]
        EndSwitch
    Next
    Return $aret
EndFunc   ;==>_WINAPI_GETVOLUMEINFORMATIONBYHANDLE
Func _WINAPI_GETVOLUMENAMEFORVOLUMEMOUNTPOINT($smountedpath)
    Local $acall = DllCall("kernel32.dll", "bool", "GetVolumeNameForVolumeMountPointW", "wstr", $smountedpath, "wstr", "", "dword", 0x50)
    If @error Or Not $acall[0x0] Then Return SetError(@error + 0xa, @extended, "")
    Return $acall[0x2]
EndFunc   ;==>_WINAPI_GETVOLUMENAMEFORVOLUMEMOUNTPOINT
Func _WINAPI_IOCTL($idevicetype, $ifunction, $imethod, $iaccess)
    Return BitOR(BitShift($idevicetype, +0xfffffff0), BitShift($iaccess, +0xfffffff2), BitShift($ifunction, +0xfffffffe), $imethod)
EndFunc   ;==>_WINAPI_IOCTL
Func _WINAPI_ISDOOROPEN($sdrive)
    Local $hfile = _WINAPI_CREATEFILEEX("\\.\" & $sdrive, $open_existing, $generic_readwrite, $file_share_readwrite)
    If @error Then Return SetError(@error + 0x14, @extended, False)
    Local $tspt = DllStructCreate("ushort Length;byte ScsiStatus;byte PathId;byte TargetId;byte Lun;byte CdbLength;byte SenseInfoLength;byte DataIn;byte Alignment[3];ulong DataTransferLength;ulong TimeOutValue;ulong_ptr DataBufferOffset;ulong SenseInfoOffset;byte Cdb[16]" & (@AutoItX64 ? ";byte[4]" : "") & ";byte Hdr[8]")
    Local $tcdb = DllStructCreate("byte;byte;byte[6];byte[2];byte;byte;byte[4]", DllStructGetPtr($tspt, "Cdb"))
    Local $thdr = DllStructCreate("byte;byte;byte[3];byte;byte[2]", DllStructGetPtr($tspt, "Hdr"))
    Local $isize = DllStructGetPtr($tspt, "Hdr") - DllStructGetPtr($tspt)
    DllStructSetData($tspt, "Length", $isize)
    DllStructSetData($tspt, "ScsiStatus", 0x0)
    DllStructSetData($tspt, "PathId", 0x0)
    DllStructSetData($tspt, "TargetId", 0x0)
    DllStructSetData($tspt, "Lun", 0x0)
    DllStructSetData($tspt, "CdbLength", 0xc)
    DllStructSetData($tspt, "SenseInfoLength", 0x0)
    DllStructSetData($tspt, "DataIn", 0x1)
    DllStructSetData($tspt, "DataTransferLength", 0x8)
    DllStructSetData($tspt, "TimeOutValue", 0x15180)
    DllStructSetData($tspt, "DataBufferOffset", $isize)
    DllStructSetData($tspt, "SenseInfoOffset", 0x0)
    DllStructSetData($tcdb, 0x1, 0xbd)
    DllStructSetData($tcdb, 0x2, 0x0)
    DllStructSetData($tcdb, 0x4, 0x0, 0x1)
    DllStructSetData($tcdb, 0x4, 0x8, 0x2)
    DllStructSetData($tcdb, 0x5, 0x0)
    DllStructSetData($tcdb, 0x6, 0x0)
    Local $acall = DllCall("kernel32.dll", "bool", "DeviceIoControl", "handle", $hfile, "dword", 0x4d004, "struct*", $tspt, "dword", $isize, "struct*", $tspt, "dword", DllStructGetSize($tspt), "dword*", 0x0, "ptr", 0x0)
    If __CHECKERRORCLOSEHANDLE($acall, $hfile) Then Return SetError(@error, @extended, False)
    Return (BitAND(DllStructGetData($thdr, 0x2), 0x10) = 0x10)
EndFunc   ;==>_WINAPI_ISDOOROPEN
Func _WINAPI_ISPATHSHARED($sfilepath)
    If Not __DLL("ntshrui.dll") Then Return SetError(0x67, 0x0, 0x0)
    Local $acall = DllCall("ntshrui.dll", "bool", "IsPathSharedW", "wstr", _WINAPI_PATHREMOVEBACKSLASH($sfilepath), "int", 0x1)
    If @error Then Return SetError(@error, @extended, 0x0)
    Return $acall[0x0]
EndFunc   ;==>_WINAPI_ISPATHSHARED
Func _WINAPI_ISWRITABLE($sdrive)
    DriveGetFileSystem($sdrive)
    If @error Then Return SetError(0x28 + @error, _WinAPI_GetLastError(), 0x0)
    Local $hfile = _WINAPI_CREATEFILEEX("\\.\" & $sdrive, $open_existing, 0x0, $file_share_readwrite)
    If @error Then Return SetError(@error + 0x14, @extended, 0x0)
    Local $acall = DllCall("kernel32.dll", "bool", "DeviceIoControl", "handle", $hfile, "dword", 0x70024, "ptr", 0x0, "dword", 0x0, "ptr", 0x0, "dword", 0x0, "dword*", 0x0, "ptr", 0x0)
    Local Const $error_write_protect = 0x13
    If __CHECKERRORCLOSEHANDLE($acall, $hfile, 0x1) <> 0xa And @extended = $error_write_protect Then Return SetError(@error, @extended, 0x0)
    Return $acall[0x0]
EndFunc   ;==>_WINAPI_ISWRITABLE
Func _WINAPI_LOADMEDIA($sdrive)
    Local $hfile = _WINAPI_CREATEFILEEX("\\.\" & $sdrive, $open_existing, $generic_read, $file_share_readwrite)
    If @error Then Return SetError(@error + 0x14, @extended, False)
    Local $acall = DllCall("kernel32.dll", "bool", "DeviceIoControl", "handle", $hfile, "dword", 0x2d480c, "ptr", 0x0, "dword", 0x0, "ptr", 0x0, "dword", 0x0, "dword*", 0x0, "ptr", 0x0)
    If __CHECKERRORCLOSEHANDLE($acall, $hfile) Then Return SetError(@error, @extended, False)
    Return $acall[0x0]
EndFunc   ;==>_WINAPI_LOADMEDIA
Func _WINAPI_LOCKDEVICE($sdrive, $block)
    Local $hfile = _WINAPI_CREATEFILEEX("\\.\" & $sdrive, $open_existing, $generic_readwrite, $file_share_readwrite)
    If @error Then Return SetError(@error + 0x14, @extended, False)
    Local $acall = DllCall("kernel32.dll", "bool", "DeviceIoControl", "handle", $hfile, "dword", 0x2d4804, "boolean*", $block, "dword", 0x1, "ptr", 0x0, "dword", 0x0, "dword*", 0x0, "ptr", 0x0)
    If __CHECKERRORCLOSEHANDLE($acall, $hfile) Then Return SetError(@error, @extended, False)
    Return $acall[0x0]
EndFunc   ;==>_WINAPI_LOCKDEVICE
Func _WINAPI_LOCKFILE($hfile, $ioffset, $ilength)
    Local $acall = DllCall("kernel32.dll", "bool", "LockFile", "handle", $hfile, "dword", _WINAPI_LODWORD($ioffset), "dword", _WINAPI_HIDWORD($ioffset), "dword", _WINAPI_LODWORD($ilength), "dword", _WINAPI_HIDWORD($ilength))
    If @error Then Return SetError(@error, @extended, False)
    Return $acall[0x0]
EndFunc   ;==>_WINAPI_LOCKFILE
Func _WINAPI_MAPVIEWOFFILE($hmapping, $ioffset = 0x0, $ibytes = 0x0, $iaccess = 0x6)
    Local $acall = DllCall("kernel32.dll", "ptr", "MapViewOfFile", "handle", $hmapping, "dword", $iaccess, "dword", _WINAPI_HIDWORD($ioffset), "dword", _WINAPI_LODWORD($ioffset), "ulong_ptr", $ibytes)
    If @error Then Return SetError(@error, @extended, 0x0)
    Return $acall[0x0]
EndFunc   ;==>_WINAPI_MAPVIEWOFFILE
Func _WINAPI_MOVEFILEEX($sexistingfile, $snewfile, $iflags = 0x0, $pprogressproc = 0x0, $pdata = 0x0)
    If Not StringStripWS($snewfile, $str_stripleading + $str_striptrailing) Then $snewfile = NULL
    If BitAND($iflags, $move_file_delay_until_reboot) Then
        If $snewfile = 0x0 Then $snewfile = NULL
    EndIf
    Local $acall = DllCall("kernel32.dll", "bool", "MoveFileWithProgressW", "wstr", $sexistingfile, "wstr", $snewfile, "ptr", $pprogressproc, "ptr", $pdata, "dword", $iflags)
    If @error Then Return SetError(@error, @extended, 0x0)
    Return $acall[0x0]
EndFunc   ;==>_WINAPI_MOVEFILEEX
Func _WINAPI_OPENFILEBYID($hfile, $vid, $iaccess = 0x0, $ishare = 0x0, $iflags = 0x0)
    Local $tfidd = DllStructCreate("dword;uint;int64;int64")
    Local $hobj, $acall, $itype, $ierror = 0x0
    Select
        Case IsString($vid)
            $acall = DllCall("ole32.dll", "long", "CLSIDFromString", "wstr", $vid, "ptr", DllStructGetPtr($tfidd, 0x3))
            If @error Or $acall[0x0] Then
                Return SetError(@error + 0x1e, 0x0, 0x0)
            EndIf
            $itype = 0x1
        Case IsDllStruct($vid)
            If Not _WINAPI_MOVEMEMORY(DllStructGetPtr($tfidd, 0x3), DllStructGetPtr($vid), 0x10) Then
                Return SetError(@error + 0x28, 0x0, 0x0)
            EndIf
            $itype = 0x1
        Case Else
            DllStructSetData($tfidd, 0x3, $vid)
            $itype = 0x0
    EndSelect
    DllStructSetData($tfidd, 0x1, DllStructGetSize($tfidd))
    DllStructSetData($tfidd, 0x2, $itype)
    If IsString($hfile) Then
        $hobj = _WINAPI_CREATEFILEEX($hfile, $open_existing, 0x0, $file_share_readwrite, $file_flag_backup_semantics)
        If @error Then Return SetError(@error + 0x14, @extended, 0x0)
    Else
        $hobj = $hfile
    EndIf
    $acall = DllCall("kernel32.dll", "handle", "OpenFileById", "handle", $hobj, "struct*", $tfidd, "dword", $iaccess, "dword", $ishare, "ptr", 0x0, "dword", $iflags)
    If @error Or ($acall[0x0] = Ptr(+0xffffffff)) Then $ierror = @error + 0xa
    If IsString($hfile) Then
        DllCall("kernel32.dll", "bool", "CloseHandle", "handle", $hobj)
    EndIf
    If $ierror Then Return SetError($ierror, 0x0, 0x0)
    Return $acall[0x0]
EndFunc   ;==>_WINAPI_OPENFILEBYID
Func _WINAPI_OPENFILEMAPPING($sname, $iaccess = 0x6, $binherit = False)
    Local $acall = DllCall("kernel32.dll", "handle", "OpenFileMappingW", "dword", $iaccess, "bool", $binherit, "wstr", $sname)
    If @error Then Return SetError(@error, @extended, 0x0)
    Return $acall[0x0]
EndFunc   ;==>_WINAPI_OPENFILEMAPPING
Func _WINAPI_PATHISDIRECTORYEMPTY($sfilepath)
    Local $acall = DllCall("shlwapi.dll", "bool", "PathIsDirectoryEmptyW", "wstr", $sfilepath)
    If @error Then Return SetError(@error, @extended, False)
    Return $acall[0x0]
EndFunc   ;==>_WINAPI_PATHISDIRECTORYEMPTY
Func _WINAPI_QUERYDOSDEVICE($sdevice)
    If Not StringStripWS($sdevice, $str_stripleading + $str_striptrailing) Then $sdevice = NULL
    Local $tdata = DllStructCreate("wchar[16384]")
    Local $acall = DllCall("kernel32.dll", "dword", "QueryDosDeviceW", "wstr", $sdevice, "struct*", $tdata, "dword", 0x4000)
    If @error Or Not $acall[0x0] Then Return SetError(@error + 0xa, @extended, "")
    Local $aret = _WINAPI_STRUCTTOARRAY($tdata)
    If IsString($sdevice) Then
        $aret = $aret[0x1]
    EndIf
    Return $aret
EndFunc   ;==>_WINAPI_QUERYDOSDEVICE
Func _WINAPI_READDIRECTORYCHANGES($hdirectory, $ifilter, $pbuffer, $ilength, $bsubtree = 0x0)
    Local $acall = DllCall("kernel32.dll", "bool", "ReadDirectoryChangesW", "handle", $hdirectory, "struct*", $pbuffer, "dword", $ilength - Mod($ilength, 0x4), "bool", $bsubtree, "dword", $ifilter, "dword*", 0x0, "ptr", 0x0, "ptr", 0x0)
    If @error Or Not $acall[0x0] Or (Not $acall[0x6]) Then Return SetError(@error + 0xa, @extended, 0x0)
    $pbuffer = $acall[0x2]
    Local $adata[0x65][0x2] = [[0x0]]
    Local $tfni, $ibuffer = 0x0, $ioffset = 0x0
    Do
        $ibuffer += $ioffset
        $tfni = DllStructCreate("dword NextEntryOffset;dword Action;dword FileNameLength;wchar FileName[" & (DllStructGetData(DllStructCreate("dword FileNameLength", $pbuffer + $ibuffer + 0x8), 0x1) / 0x2) & "]", $pbuffer + $ibuffer)
        __INC($adata)
        $adata[$adata[0x0][0x0]][0x0] = DllStructGetData($tfni, "FileName")
        $adata[$adata[0x0][0x0]][0x1] = DllStructGetData($tfni, "Action")
        $ioffset = DllStructGetData($tfni, "NextEntryOffset")
    Until Not $ioffset
    __INC($adata, +0xffffffff)
    Return $adata
EndFunc   ;==>_WINAPI_READDIRECTORYCHANGES
Func _WINAPI_REMOVEDIRECTORY($sdirpath)
    Local $acall = DllCall("kernel32.dll", "bool", "RemoveDirectoryW", "wstr", $sdirpath)
    If @error Then Return SetError(@error, @extended, False)
    Return $acall[0x0]
EndFunc   ;==>_WINAPI_REMOVEDIRECTORY
Func _WINAPI_REOPENFILE($hfile, $iaccess, $ishare, $iflags = 0x0)
    Local $acall = DllCall("kernel32.dll", "handle", "ReOpenFile", "handle", $hfile, "dword", $iaccess, "dword", $ishare, "dword", $iflags)
    If @error Or ($acall[0x0] = Ptr(+0xffffffff)) Then Return SetError(@error, @extended, 0x0)
    Return $acall[0x0]
EndFunc   ;==>_WINAPI_REOPENFILE
Func _WINAPI_REPLACEFILE($sreplacedfile, $sreplacementfile, $sbackupfile = "", $iflags = 0x0)
    If Not StringStripWS($sbackupfile, $str_stripleading + $str_striptrailing) Then $sbackupfile = NULL
    Local $acall = DllCall("kernel32.dll", "bool", "ReplaceFileW", "wstr", $sreplacedfile, "wstr", $sreplacementfile, "wstr", $sbackupfile, "dword", $iflags, "ptr", 0x0, "ptr", 0x0)
    If @error Then Return SetError(@error, @extended, 0x0)
    Return $acall[0x0]
EndFunc   ;==>_WINAPI_REPLACEFILE
Func _WINAPI_SEARCHPATH($sfilepath, $ssearchpath = "")
    If Not StringStripWS($ssearchpath, $str_stripleading + $str_striptrailing) Then $ssearchpath = NULL
    Local $acall = DllCall("kernel32.dll", "dword", "SearchPathW", "wstr", $ssearchpath, "wstr", $sfilepath, "ptr", 0x0, "dword", 0x1000, "wstr", "", "ptr", 0x0)
    If @error Or Not $acall[0x0] Then Return SetError(@error + 0xa, @extended, "")
    Return $acall[0x5]
EndFunc   ;==>_WINAPI_SEARCHPATH
Func _WINAPI_SETCOMPRESSION($sfilepath, $icompression)
    Local $hfile = _WINAPI_CREATEFILEEX($sfilepath, $open_existing, $generic_readwrite, $file_share_readwrite, $file_flag_backup_semantics)
    If @error Then Return SetError(@error + 0x14, @extended, 0x0)
    Local $acall = DllCall("kernel32.dll", "bool", "DeviceIoControl", "handle", $hfile, "dword", 0x9c040, "ushort*", $icompression, "dword", 0x2, "ptr", 0x0, "dword", 0x0, "dword*", 0x0, "ptr", 0x0)
    If __CHECKERRORCLOSEHANDLE($acall, $hfile) Then Return SetError(@error, @extended, 0x0)
    Return 0x1
EndFunc   ;==>_WINAPI_SETCOMPRESSION
Func _WINAPI_SETCURRENTDIRECTORY($sdir)
    Local $acall = DllCall("kernel32.dll", "int", "SetCurrentDirectoryW", "wstr", $sdir)
    If @error Then Return SetError(@error, @extended, 0x0)
    Return $acall[0x0]
EndFunc   ;==>_WINAPI_SETCURRENTDIRECTORY
Func _WinAPI_SetEndOfFile($hfile)
    Local $acall = DllCall("kernel32.dll", "bool", "SetEndOfFile", "handle", $hfile)
    If @error Then Return SetError(@error, @extended, False)
    Return $acall[0x0]
EndFunc   ;==>_WINAPI_SETENDOFFILE
Func _WINAPI_SETFILEATTRIBUTES($sfilepath, $iattributes)
    Local $acall = DllCall("kernel32.dll", "int", "SetFileAttributesW", "wstr", $sfilepath, "dword", $iattributes)
    If @error Then Return SetError(@error, @extended, False)
    Return $acall[0x0]
EndFunc   ;==>_WINAPI_SETFILEATTRIBUTES
Func _WINAPI_SETFILEINFORMATIONBYHANDLEEX($hfile, $tfileinfo)
    Local $acall = DllCall("ntdll.dll", "long", "ZwSetInformationFile", "handle", $hfile, "struct*", $tfileinfo, "struct*", $tfileinfo, "ulong", DllStructGetSize($tfileinfo), "uint", 0x4)
    If @error Then Return SetError(@error, @extended, 0x0)
    If $acall[0x0] Then Return SetError(0xa, $acall[0x0], 0x0)
    Return 0x1
EndFunc   ;==>_WINAPI_SETFILEINFORMATIONBYHANDLEEX
Func _WinAPI_SetFilePointer($hfile, $ipos, $imethod = 0x0)
    Local $acall = DllCall("kernel32.dll", "INT", "SetFilePointer", "handle", $hfile, "long", $ipos, "ptr", 0x0, "long", $imethod)
    If @error Then Return SetError(@error, @extended, +0xffffffff)
    Return $acall[0x0]
EndFunc   ;==>_WINAPI_SETFILEPOINTER
Func _WINAPI_SETFILEPOINTEREX($hfile, $ipos, $imethod = 0x0)
    Local $acall = DllCall("kernel32.dll", "bool", "SetFilePointerEx", "handle", $hfile, "int64", $ipos, "int64*", 0x0, "dword", $imethod)
    If @error Then Return SetError(@error, @extended, False)
    Return $acall[0x0]
EndFunc   ;==>_WINAPI_SETFILEPOINTEREX
Func _WINAPI_SETFILESHORTNAME($hfile, $sshortname)
    Local $acall = DllCall("kernel32.dll", "bool", "SetFileShortNameW", "handle", $hfile, "wstr", $sshortname)
    If @error Then Return SetError(@error, @extended, False)
    Return $acall[0x0]
EndFunc   ;==>_WINAPI_SETFILESHORTNAME
Func _WINAPI_SETFILEVALIDDATA($hfile, $ilength)
    Local $acall = DllCall("kernel32.dll", "bool", "SetFileValidData", "handle", $hfile, "int64", $ilength)
    If @error Then Return SetError(@error, @extended, 0x0)
    Return $acall[0x0]
EndFunc   ;==>_WINAPI_SETFILEVALIDDATA
Func _WINAPI_SETSEARCHPATHMODE($iflags)
    Local $acall = DllCall("kernel32.dll", "bool", "SetSearchPathMode", "dword", $iflags)
    If @error Then Return SetError(@error, @extended, False)
    Return $acall[0x0]
EndFunc   ;==>_WINAPI_SETSEARCHPATHMODE
Func _WINAPI_SETVOLUMEMOUNTPOINT($sfilepath, $sguid)
    Local $acall = DllCall("kernel32.dll", "bool", "SetVolumeMountPointW", "wstr", $sfilepath, "wstr", $sguid)
    If @error Then Return SetError(@error, @extended, False)
    Return $acall[0x0]
EndFunc   ;==>_WINAPI_SETVOLUMEMOUNTPOINT
Func _WINAPI_SFCISFILEPROTECTED($sfilepath)
    If Not __DLL("sfc.dll") Then Return SetError(0x67, 0x0, False)
    Local $acall = DllCall("sfc.dll", "bool", "SfcIsFileProtected", "handle", 0x0, "wstr", $sfilepath)
    If @error Then Return SetError(@error, @extended, False)
    Return $acall[0x0]
EndFunc   ;==>_WINAPI_SFCISFILEPROTECTED
Func _WINAPI_UNLOCKFILE($hfile, $ioffset, $ilength)
    Local $acall = DllCall("kernel32.dll", "bool", "UnlockFile", "handle", $hfile, "dword", _WINAPI_LODWORD($ioffset), "dword", _WINAPI_HIDWORD($ioffset), "dword", _WINAPI_LODWORD($ilength), "dword", _WINAPI_HIDWORD($ilength))
    If @error Then Return SetError(@error, @extended, 0x0)
    Return $acall[0x0]
EndFunc   ;==>_WINAPI_UNLOCKFILE
Func _WINAPI_UNMAPVIEWOFFILE($paddress)
    Local $acall = DllCall("kernel32.dll", "bool", "UnmapViewOfFile", "ptr", $paddress)
    If @error Then Return SetError(@error, @extended, False)
    Return $acall[0x0]
EndFunc   ;==>_WINAPI_UNMAPVIEWOFFILE
Func _WINAPI_WOW64ENABLEWOW64FSREDIRECTION($benable)
    Local $acall = DllCall("kernel32.dll", "boolean", "Wow64EnableWow64FsRedirection", "boolean", $benable)
    If @error Then Return SetError(@error, @extended, 0x0)
    Return $acall[0x0]
EndFunc   ;==>_WINAPI_WOW64ENABLEWOW64FSREDIRECTION
#endregion Public Functions
#region Internal Functions
Func __WINAPI_MAKEQWORD($ilodword, $ihidword)
    Local $tint64 = DllStructCreate("uint64")
    Local $tdwords = DllStructCreate("dword;dword", DllStructGetPtr($tint64))
    DllStructSetData($tdwords, 0x1, $ilodword)
    DllStructSetData($tdwords, 0x2, $ihidword)
    Return DllStructGetData($tint64, 0x1)
EndFunc   ;==>__WINAPI_MAKEQWORD
#endregion Internal Functions
Global Const $fr_private = 0x10
Global Const $fr_not_enum = 0x20
Global Const $compression_bitmap_png = 0x0
Global Const $compression_bitmap_jpeg = 0x1
Global Const $bs_dibpattern = 0x5
Global Const $bs_dibpattern8x8 = 0x8
Global Const $bs_dibpatternpt = 0x6
Global Const $bs_hatched = 0x2
Global Const $bs_hollow = 0x1
Global Const $bs_null = 0x1
Global Const $bs_pattern = 0x3
Global Const $bs_pattern8x8 = 0x7
Global Const $bs_solid = 0x0
Global Const $hs_bdiagonal = 0x3
Global Const $hs_cross = 0x4
Global Const $hs_diagcross = 0x5
Global Const $hs_fdiagonal = 0x2
Global Const $hs_horizontal = 0x0
Global Const $hs_vertical = 0x1
Global Const $dib_pal_colors = 0x1
Global Const $dib_rgb_colors = 0x0
Global Const $ca_negative = 0x1
Global Const $ca_log_filter = 0x2
Global Const $illuminant_device_default = 0x0
Global Const $illuminant_a = 0x1
Global Const $illuminant_b = 0x2
Global Const $illuminant_c = 0x3
Global Const $illuminant_d50 = 0x4
Global Const $illuminant_d55 = 0x5
Global Const $illuminant_d65 = 0x6
Global Const $illuminant_d75 = 0x7
Global Const $illuminant_f2 = 0x8
Global Const $illuminant_tungsten = $illuminant_a
Global Const $illuminant_daylight = $illuminant_c
Global Const $illuminant_fluorescent = $illuminant_f2
Global Const $illuminant_ntsc = $illuminant_c
Global Const $bi_rgb = 0x0
Global Const $bi_rle8 = 0x1
Global Const $bi_rle4 = 0x2
Global Const $bi_bitfields = 0x3
Global Const $bi_jpeg = 0x4
Global Const $bi_png = 0x5
Global Const $alternate = 0x1
Global Const $winding = 0x2
Global Const $dwmwa_ncrendering_enabled = 0x1
Global Const $dwmwa_ncrendering_policy = 0x2
Global Const $dwmwa_transitions_forcedisabled = 0x3
Global Const $dwmwa_allow_ncpaint = 0x4
Global Const $dwmwa_caption_button_bounds = 0x5
Global Const $dwmwa_nonclient_rtl_layout = 0x6
Global Const $dwmwa_force_iconic_representation = 0x7
Global Const $dwmwa_flip3d_policy = 0x8
Global Const $dwmwa_extended_frame_bounds = 0x9
Global Const $dwmwa_has_iconic_bitmap = 0xa
Global Const $dwmwa_disallow_peek = 0xb
Global Const $dwmwa_excluded_from_peek = 0xc
Global Const $dwmncrp_usewindowstyle = 0x0
Global Const $dwmncrp_disabled = 0x1
Global Const $dwmncrp_enabled = 0x2
Global Const $dwmflip3d_default = 0x0
Global Const $dwmflip3d_excludebelow = 0x1
Global Const $dwmflip3d_excludeabove = 0x2
Global Const $dm_bitsperpel = 0x40000
Global Const $dm_collate = 0x8000
Global Const $dm_color = 0x800
Global Const $dm_copies = 0x100
Global Const $dm_defaultsource = 0x200
Global Const $dm_displayfixedoutput = 0x20000000
Global Const $dm_displayflags = 0x200000
Global Const $dm_displayfrequency = 0x400000
Global Const $dm_displayorientation = 0x80
Global Const $dm_dithertype = 0x4000000
Global Const $dm_duplex = 0x1000
Global Const $dm_formname = 0x10000
Global Const $dm_icmintent = 0x1000000
Global Const $dm_icmmethod = 0x800000
Global Const $dm_logpixels = 0x20000
Global Const $dm_mediatype = 0x2000000
Global Const $dm_nup = 0x40
Global Const $dm_orientation = 0x1
Global Const $dm_panningheight = 0x10000000
Global Const $dm_panningwidth = 0x8000000
Global Const $dm_paperlength = 0x4
Global Const $dm_papersize = 0x2
Global Const $dm_paperwidth = 0x8
Global Const $dm_pelsheight = 0x100000
Global Const $dm_pelswidth = 0x80000
Global Const $dm_position = 0x20
Global Const $dm_printquality = 0x400
Global Const $dm_scale = 0x10
Global Const $dm_ttoption = 0x4000
Global Const $dm_yresolution = 0x2000
Global Const $dmpaper_letter = 0x1
Global Const $dmpaper_lettersmall = 0x2
Global Const $dmpaper_tabloid = 0x3
Global Const $dmpaper_ledger = 0x4
Global Const $dmpaper_legal = 0x5
Global Const $dmpaper_statement = 0x6
Global Const $dmpaper_executive = 0x7
Global Const $dmpaper_a3 = 0x8
Global Const $dmpaper_a4 = 0x9
Global Const $dmpaper_a4small = 0xa
Global Const $dmpaper_a5 = 0xb
Global Const $dmpaper_b4 = 0xc
Global Const $dmpaper_b5 = 0xd
Global Const $dmpaper_folio = 0xe
Global Const $dmpaper_quarto = 0xf
Global Const $dmpaper_10x14 = 0x10
Global Const $dmpaper_11x17 = 0x11
Global Const $dmpaper_note = 0x12
Global Const $dmpaper_env_9 = 0x13
Global Const $dmpaper_env_10 = 0x14
Global Const $dmpaper_env_11 = 0x15
Global Const $dmpaper_env_12 = 0x16
Global Const $dmpaper_env_14 = 0x17
Global Const $dmpaper_csheet = 0x18
Global Const $dmpaper_dsheet = 0x19
Global Const $dmpaper_esheet = 0x1a
Global Const $dmpaper_env_dl = 0x1b
Global Const $dmpaper_env_c5 = 0x1c
Global Const $dmpaper_env_c3 = 0x1d
Global Const $dmpaper_env_c4 = 0x1e
Global Const $dmpaper_env_c6 = 0x1f
Global Const $dmpaper_env_c65 = 0x20
Global Const $dmpaper_env_b4 = 0x21
Global Const $dmpaper_env_b5 = 0x22
Global Const $dmpaper_env_b6 = 0x23
Global Const $dmpaper_env_italy = 0x24
Global Const $dmpaper_env_monarch = 0x25
Global Const $dmpaper_env_personal = 0x26
Global Const $dmpaper_fanfold_us = 0x27
Global Const $dmpaper_fanfold_std_german = 0x28
Global Const $dmpaper_fanfold_lgl_german = 0x29
Global Const $dmpaper_iso_b4 = 0x2a
Global Const $dmpaper_japanese_postcard = 0x2b
Global Const $dmpaper_9x11 = 0x2c
Global Const $dmpaper_10x11 = 0x2d
Global Const $dmpaper_15x11 = 0x2e
Global Const $dmpaper_env_invite = 0x2f
Global Const $dmpaper_reserved_48 = 0x30
Global Const $dmpaper_reserved_49 = 0x31
Global Const $dmpaper_letter_extra = 0x32
Global Const $dmpaper_legal_extra = 0x33
Global Const $dmpaper_tabloid_extra = 0x34
Global Const $dmpaper_a4_extra = 0x35
Global Const $dmpaper_letter_transverse = 0x36
Global Const $dmpaper_a4_transverse = 0x37
Global Const $dmpaper_letter_extra_transverse = 0x38
Global Const $dmpaper_a_plus = 0x39
Global Const $dmpaper_b_plus = 0x3a
Global Const $dmpaper_letter_plus = 0x3b
Global Const $dmpaper_a4_plus = 0x3c
Global Const $dmpaper_a5_transverse = 0x3d
Global Const $dmpaper_b5_transverse = 0x3e
Global Const $dmpaper_a3_extra = 0x3f
Global Const $dmpaper_a5_extra = 0x40
Global Const $dmpaper_b5_extra = 0x41
Global Const $dmpaper_a2 = 0x42
Global Const $dmpaper_a3_transverse = 0x43
Global Const $dmpaper_a3_extra_transverse = 0x44
Global Const $dmpaper_dbl_japanese_postcard = 0x45
Global Const $dmpaper_a6 = 0x46
Global Const $dmpaper_jenv_kaku2 = 0x47
Global Const $dmpaper_jenv_kaku3 = 0x48
Global Const $dmpaper_jenv_chou3 = 0x49
Global Const $dmpaper_jenv_chou4 = 0x4a
Global Const $dmpaper_letter_rotated = 0x4b
Global Const $dmpaper_a3_rotated = 0x4c
Global Const $dmpaper_a4_rotated = 0x4d
Global Const $dmpaper_a5_rotated = 0x4e
Global Const $dmpaper_b4_jis_rotated = 0x4f
Global Const $dmpaper_b5_jis_rotated = 0x50
Global Const $dmpaper_japanese_postcard_rotated = 0x51
Global Const $dmpaper_dbl_japanese_postcard_rotated = 0x52
Global Const $dmpaper_a6_rotated = 0x53
Global Const $dmpaper_jenv_kaku2_rotated = 0x54
Global Const $dmpaper_jenv_kaku3_rotated = 0x55
Global Const $dmpaper_jenv_chou3_rotated = 0x56
Global Const $dmpaper_jenv_chou4_rotated = 0x57
Global Const $dmpaper_b6_jis = 0x58
Global Const $dmpaper_b6_jis_rotated = 0x59
Global Const $dmpaper_12x11 = 0x5a
Global Const $dmpaper_jenv_you4 = 0x5b
Global Const $dmpaper_jenv_you4_rotated = 0x5c
Global Const $dmpaper_p16k = 0x5d
Global Const $dmpaper_p32k = 0x5e
Global Const $dmpaper_p32kbig = 0x5f
Global Const $dmpaper_penv_1 = 0x60
Global Const $dmpaper_penv_2 = 0x61
Global Const $dmpaper_penv_3 = 0x62
Global Const $dmpaper_penv_4 = 0x63
Global Const $dmpaper_penv_5 = 0x64
Global Const $dmpaper_penv_6 = 0x65
Global Const $dmpaper_penv_7 = 0x66
Global Const $dmpaper_penv_8 = 0x67
Global Const $dmpaper_penv_9 = 0x68
Global Const $dmpaper_penv_10 = 0x69
Global Const $dmpaper_p16k_rotated = 0x6a
Global Const $dmpaper_p32k_rotated = 0x6b
Global Const $dmpaper_p32kbig_rotated = 0x6c
Global Const $dmpaper_penv_1_rotated = 0x6d
Global Const $dmpaper_penv_2_rotated = 0x6e
Global Const $dmpaper_penv_3_rotated = 0x6f
Global Const $dmpaper_penv_4_rotated = 0x70
Global Const $dmpaper_penv_5_rotated = 0x71
Global Const $dmpaper_penv_6_rotated = 0x72
Global Const $dmpaper_penv_7_rotated = 0x73
Global Const $dmpaper_penv_8_rotated = 0x74
Global Const $dmpaper_penv_9_rotated = 0x75
Global Const $dmpaper_penv_10_rotated = 0x76
Global Const $dmpaper_user = 0x100
Global Const $dmbin_upper = 0x1
Global Const $dmbin_lower = 0x2
Global Const $dmbin_middle = 0x3
Global Const $dmbin_manual = 0x4
Global Const $dmbin_envelope = 0x5
Global Const $dmbin_envmanual = 0x6
Global Const $dmbin_auto = 0x7
Global Const $dmbin_tractor = 0x8
Global Const $dmbin_smallfmt = 0x9
Global Const $dmbin_largefmt = 0xa
Global Const $dmbin_largecapacity = 0xb
Global Const $dmbin_cassette = 0xe
Global Const $dmbin_formsource = 0xf
Global Const $dmbin_user = 0x100
Global Const $dmres_draft = +0xffffffff
Global Const $dmres_low = +0xfffffffe
Global Const $dmres_medium = +0xfffffffd
Global Const $dmres_high = +0xfffffffc
Global Const $dmdo_default = 0x0
Global Const $dmdo_90 = 0x1
Global Const $dmdo_180 = 0x2
Global Const $dmdo_270 = 0x3
Global Const $dmdfo_default = 0x0
Global Const $dmdfo_stretch = 0x1
Global Const $dmdfo_center = 0x2
Global Const $dmcolor_monochrome = 0x1
Global Const $dmcolor_color = 0x2
Global Const $dmdup_simplex = 0x1
Global Const $dmdup_vertical = 0x2
Global Const $dmdup_horizontal = 0x3
Global Const $dmtt_bitmap = 0x1
Global Const $dmtt_download = 0x2
Global Const $dmtt_subdev = 0x3
Global Const $dmtt_download_outline = 0x4
Global Const $dmcollate_false = 0x0
Global Const $dmcollate_true = 0x1
Global Const $dm_grayscale = 0x1
Global Const $dm_interlaced = 0x2
Global Const $dmnup_system = 0x1
Global Const $dmnup_oneup = 0x2
Global Const $dmicmmethod_none = 0x1
Global Const $dmicmmethod_system = 0x2
Global Const $dmicmmethod_driver = 0x3
Global Const $dmicmmethod_device = 0x4
Global Const $dmicmmethod_user = 0x100
Global Const $dmicm_saturate = 0x1
Global Const $dmicm_contrast = 0x2
Global Const $dmicm_colorimetric = 0x3
Global Const $dmicm_abs_colorimetric = 0x4
Global Const $dmicm_user = 0x100
Global Const $dmmedia_standard = 0x1
Global Const $dmmedia_transparency = 0x2
Global Const $dmmedia_glossy = 0x3
Global Const $dmmedia_user = 0x100
Global Const $dmdither_none = 0x1
Global Const $dmdither_coarse = 0x2
Global Const $dmdither_fine = 0x3
Global Const $dmdither_lineart = 0x4
Global Const $dmdither_errordiffusion = 0x5
Global Const $dmdither_reserved6 = 0x6
Global Const $dmdither_reserved7 = 0x7
Global Const $dmdither_reserved8 = 0x8
Global Const $dmdither_reserved9 = 0x9
Global Const $dmdither_grayscale = 0xa
Global Const $dmdither_user = 0x100
Global Const $enum_current_settings = +0xffffffff
Global Const $enum_registry_settings = +0xfffffffe
Global Const $device_fonttype = 0x2
Global Const $raster_fonttype = 0x1
Global Const $truetype_fonttype = 0x4
Global Const $ntm_bold = 0x20
Global Const $ntm_dsig = 0x200000
Global Const $ntm_italic = 0x1
Global Const $ntm_multiplemaster = 0x80000
Global Const $ntm_nonnegative_ac = 0x10000
Global Const $ntm_ps_opentype = 0x20000
Global Const $ntm_regular = 0x40
Global Const $ntm_tt_opentype = 0x40000
Global Const $ntm_type1 = 0x100000
Global Const $floodfillborder = 0x0
Global Const $floodfillsurface = 0x1
Global Const $ad_counterclockwise = 0x1
Global Const $ad_clockwise = 0x2
Global Const $dcb_accumulate = 0x2
Global Const $dcb_disable = 0x8
Global Const $dcb_enable = 0x4
Global Const $dcb_reset = 0x1
Global Const $dcb_set = BitOR($dcb_reset, $dcb_accumulate)
Global Const $dcx_window = 0x1
Global Const $dcx_cache = 0x2
Global Const $dcx_parentclip = 0x20
Global Const $dcx_clipsiblings = 0x10
Global Const $dcx_clipchildren = 0x8
Global Const $dcx_noresetattrs = 0x4
Global Const $dcx_lockwindowupdate = 0x400
Global Const $dcx_excludergn = 0x40
Global Const $dcx_intersectrgn = 0x80
Global Const $dcx_intersectupdate = 0x200
Global Const $dcx_validate = 0x200000
Global Const $ggo_bezier = 0x3
Global Const $ggo_bitmap = 0x1
Global Const $ggo_glyph_index = 0x80
Global Const $ggo_gray2_bitmap = 0x4
Global Const $ggo_gray4_bitmap = 0x5
Global Const $ggo_gray8_bitmap = 0x6
Global Const $ggo_metrics = 0x0
Global Const $ggo_native = 0x2
Global Const $ggo_unhinted = 0x100
Global Const $gm_compatible = 0x1
Global Const $gm_advanced = 0x2
Global Const $mm_anisotropic = 0x8
Global Const $mm_hienglish = 0x5
Global Const $mm_himetric = 0x3
Global Const $mm_isotropic = 0x7
Global Const $mm_loenglish = 0x4
Global Const $mm_lometric = 0x2
Global Const $mm_text = 0x1
Global Const $mm_twips = 0x6
Global Const $r2_black = 0x1
Global Const $r2_copypen = 0xd
Global Const $r2_last = 0x10
Global Const $r2_masknotpen = 0x3
Global Const $r2_maskpen = 0x9
Global Const $r2_maskpennot = 0x5
Global Const $r2_mergenotpen = 0xc
Global Const $r2_mergepen = 0xf
Global Const $r2_mergepennot = 0xe
Global Const $r2_nop = 0xb
Global Const $r2_not = 0x6
Global Const $r2_notcopypen = 0x4
Global Const $r2_notmaskpen = 0x8
Global Const $r2_notmergepen = 0x2
Global Const $r2_notxorpen = 0xa
Global Const $r2_white = 0x10
Global Const $r2_xorpen = 0x7
Global Const $blackonwhite = 0x1
Global Const $coloroncolor = 0x3
Global Const $halftone = 0x4
Global Const $whiteonblack = 0x2
Global Const $stretch_andscans = $blackonwhite
Global Const $stretch_deletescans = $coloroncolor
Global Const $stretch_halftone = $halftone
Global Const $stretch_orscans = $whiteonblack
Global Const $ta_baseline = 0x18
Global Const $ta_bottom = 0x8
Global Const $ta_top = 0x0
Global Const $ta_center = 0x6
Global Const $ta_left = 0x0
Global Const $ta_right = 0x2
Global Const $ta_noupdatecp = 0x0
Global Const $ta_rtlreading = 0x100
Global Const $ta_updatecp = 0x1
Global Const $vta_baseline = $ta_baseline
Global Const $vta_bottom = $ta_right
Global Const $vta_top = $ta_left
Global Const $vta_center = $ta_center
Global Const $vta_left = $ta_bottom
Global Const $vta_right = $ta_top
Global Const $udf_bgr = 0x1
Global Const $udf_rgb = 0x0
Global Const $mwt_identity = 0x1
Global Const $mwt_leftmultiply = 0x2
Global Const $mwt_rightmultiply = 0x3
Global Const $mwt_set = 0x4
Global Const $monitor_defaulttonearest = 0x2
Global Const $monitor_defaulttonull = 0x0
Global Const $monitor_defaulttoprimary = 0x1
Global Const $pt_bezierto = 0x4
Global Const $pt_lineto = 0x2
Global Const $pt_moveto = 0x6
Global Const $pt_closefigure = 0x1
#region Global Variables and Constants
Global Const $duplicate_close_source = 0x1
Global Const $duplicate_same_access = 0x2
Global Const $obj_bitmap = 0x7
Global Const $obj_brush = 0x2
Global Const $obj_colorspace = 0xe
Global Const $obj_dc = 0x3
Global Const $obj_enhmetadc = 0xc
Global Const $obj_enhmetafile = 0xd
Global Const $obj_extpen = 0xb
Global Const $obj_font = 0x6
Global Const $obj_memdc = 0xa
Global Const $obj_metadc = 0x4
Global Const $obj_metafile = 0x9
Global Const $obj_pal = 0x5
Global Const $obj_pen = 0x1
Global Const $obj_region = 0x8
Global Const $null_brush = 0x5
Global Const $null_pen = 0x8
Global Const $black_brush = 0x4
Global Const $dkgray_brush = 0x3
Global Const $dc_brush = 0x12
Global Const $gray_brush = 0x2
Global Const $hollow_brush = $null_brush
Global Const $ltgray_brush = 0x1
Global Const $white_brush = 0x0
Global Const $black_pen = 0x7
Global Const $dc_pen = 0x13
Global Const $white_pen = 0x6
Global Const $ansi_fixed_font = 0xb
Global Const $ansi_var_font = 0xc
Global Const $device_default_font = 0xe
Global Const $default_gui_font = 0x11
Global Const $oem_fixed_font = 0xa
Global Const $system_font = 0xd
Global Const $system_fixed_font = 0x10
Global Const $default_palette = 0xf
#endregion Global Variables and Constants
#region Functions list
#endregion Functions list
#region Public Functions
Func _WinAPI_CloseHandle($hobject)
    Local $acall = DllCall("kernel32.dll", "bool", "CloseHandle", "handle", $hobject)
    If @error Then Return SetError(@error, @extended, False)
    Return $acall[0x0]
EndFunc   ;==>_WINAPI_CLOSEHANDLE
Func _WinAPI_DeleteObject($hobject)
    Local $acall = DllCall("gdi32.dll", "bool", "DeleteObject", "handle", $hobject)
    If @error Then Return SetError(@error, @extended, False)
    Return $acall[0x0]
EndFunc   ;==>_WINAPI_DELETEOBJECT
Func _WinAPI_DuplicateHandle($hsourceprocesshandle, $hsourcehandle, $htargetprocesshandle, $idesiredaccess, $iinherithandle, $ioptions)
    Local $acall = DllCall("kernel32.dll", "bool", "DuplicateHandle", "handle", $hsourceprocesshandle, "handle", $hsourcehandle, "handle", $htargetprocesshandle, "handle*", 0x0, "dword", $idesiredaccess, "bool", $iinherithandle, "dword", $ioptions)
    If @error Or Not $acall[0x0] Then Return SetError(@error, @extended, 0x0)
    Return $acall[0x4]
EndFunc   ;==>_WINAPI_DUPLICATEHANDLE
Func _WINAPI_GETCURRENTOBJECT($hdc, $itype)
    Local $acall = DllCall("gdi32.dll", "handle", "GetCurrentObject", "handle", $hdc, "uint", $itype)
    If @error Or Not $acall[0x0] Then Return SetError(@error, @extended, 0x0)
    Return $acall[0x0]
EndFunc   ;==>_WINAPI_GETCURRENTOBJECT
Func _WinAPI_GetCurrentProcess()
    Local $acall = DllCall("kernel32.dll", "handle", "GetCurrentProcess")
    If @error Then Return SetError(@error, @extended, 0x0)
    Return $acall[0x0]
EndFunc   ;==>_WINAPI_GETCURRENTPROCESS
Func _WinAPI_GetObject($hobject, $isize, $pobject)
    Local $acall = DllCall("gdi32.dll", "int", "GetObjectW", "handle", $hobject, "int", $isize, "struct*", $pobject)
    If @error Then Return SetError(@error, @extended, 0x0)
    Return $acall[0x0]
EndFunc   ;==>_WINAPI_GETOBJECT
Func _WINAPI_GETOBJECTINFOBYHANDLE($hobject)
    Local $tagpublic_object_basic_information = "ulong Attributes;ulong GrantedAcess;ulong HandleCount;ulong PointerCount;ulong Reserved[10]"
    Local $tpobi = DllStructCreate($tagpublic_object_basic_information)
    Local $acall = DllCall("ntdll.dll", "long", "ZwQueryObject", "handle", $hobject, "uint", 0x0, "struct*", $tpobi, "ulong", DllStructGetSize($tpobi), "ptr", 0x0)
    If @error Then Return SetError(@error, @extended, 0x0)
    If $acall[0x0] Then Return SetError(0xa, $acall[0x0], 0x0)
    Local $aret[0x4]
    For $i = 0x0 To 0x3
        $aret[$i] = DllStructGetData($tpobi, $i + 0x1)
    Next
    Return $aret
EndFunc   ;==>_WINAPI_GETOBJECTINFOBYHANDLE
Func _WINAPI_GETOBJECTNAMEBYHANDLE($hobject)
    Local $tagunicode_string = "struct;ushort Length;ushort MaximumLength;ptr Buffer;endstruct"
    Local $tagpublic_object_type_information = "struct;" & $tagunicode_string & ";ulong Reserved[22];endstruct"
    Local $tpoti = DllStructCreate($tagpublic_object_type_information & ";byte[32]")
    Local $acall = DllCall("ntdll.dll", "long", "ZwQueryObject", "handle", $hobject, "uint", 0x2, "struct*", $tpoti, "ulong", DllStructGetSize($tpoti), "ulong*", 0x0)
    If @error Then Return SetError(@error, @extended, "")
    If $acall[0x0] Then Return SetError(0xa, $acall[0x0], "")
    Local $pdata = DllStructGetData($tpoti, 0x3)
    If Not $pdata Then Return SetError(0xb, 0x0, "")
    Return _WINAPI_GETSTRING($pdata)
EndFunc   ;==>_WINAPI_GETOBJECTNAMEBYHANDLE
Func _WINAPI_GETOBJECTTYPE($hobject)
    Local $acall = DllCall("gdi32.dll", "dword", "GetObjectType", "handle", $hobject)
    If @error Then Return SetError(@error, @extended, 0x0)
    Return $acall[0x0]
EndFunc   ;==>_WINAPI_GETOBJECTTYPE
Func _WinAPI_GetStdHandle($istdhandle)
    If $istdhandle < 0x0 Or $istdhandle > 0x2 Then Return SetError(0x2, 0x0, +0xffffffff)
    Local Const $ahandle[0x3] = [+0xfffffff6, +0xfffffff5, +0xfffffff4]
    Local $acall = DllCall("kernel32.dll", "handle", "GetStdHandle", "dword", $ahandle[$istdhandle])
    If @error Then Return SetError(@error, @extended, +0xffffffff)
    Return $acall[0x0]
EndFunc   ;==>_WINAPI_GETSTDHANDLE
Func _WinAPI_GetStockObject($iobject)
    Local $acall = DllCall("gdi32.dll", "handle", "GetStockObject", "int", $iobject)
    If @error Then Return SetError(@error, @extended, 0x0)
    Return $acall[0x0]
EndFunc   ;==>_WINAPI_GETSTOCKOBJECT
Func _WinAPI_SelectObject($hdc, $hgdiobj)
    Local $acall = DllCall("gdi32.dll", "handle", "SelectObject", "handle", $hdc, "handle", $hgdiobj)
    If @error Then Return SetError(@error, @extended, False)
    Return $acall[0x0]
EndFunc   ;==>_WINAPI_SELECTOBJECT
Func _WinAPI_SetHandleInformation($hobject, $imask, $iflags)
    Local $acall = DllCall("kernel32.dll", "bool", "SetHandleInformation", "handle", $hobject, "dword", $imask, "dword", $iflags)
    If @error Then Return SetError(@error, @extended, False)
    Return $acall[0x0]
EndFunc   ;==>_WINAPI_SETHANDLEINFORMATION
#endregion Public Functions
#region Global Variables and Constants
Global Const $tagbitmap = "struct;long bmType;long bmWidth;long bmHeight;long bmWidthBytes;ushort bmPlanes;ushort bmBitsPixel;ptr bmBits;endstruct"
Global Const $tagbitmapv5header = "struct;dword bV5Size;long bV5Width;long bV5Height;ushort bV5Planes;ushort bV5BitCount;dword bV5Compression;dword bV5SizeImage;long bV5XPelsPerMeter;long bV5YPelsPerMeter;dword bV5ClrUsed;dword bV5ClrImportant;dword bV5RedMask;dword bV5GreenMask;dword bV5BlueMask;dword bV5AlphaMask;dword bV5CSType;int bV5Endpoints[9];dword bV5GammaRed;dword bV5GammaGreen;dword bV5GammaBlue;dword bV5Intent;dword bV5ProfileData;dword bV5ProfileSize;dword bV5Reserved;endstruct"
Global Const $tagdibsection = $tagbitmap & ";" & $tagbitmapinfoheader & ";dword dsBitfields[3];ptr dshSection;dword dsOffset"
Global Const $tmpf_fixed_pitch = 0x1
Global Const $tmpf_vector = 0x2
Global Const $tmpf_truetype = 0x4
Global Const $tmpf_device = 0x8
Global Const $__winapiconstant_fw_normal = 0x190
Global Const $__winapiconstant_default_charset = 0x1
Global Const $__winapiconstant_out_default_precis = 0x0
Global Const $__winapiconstant_clip_default_precis = 0x0
Global Const $__winapiconstant_default_quality = 0x0
#endregion Global Variables and Constants
#region Functions list
#endregion Functions list
#region Public Functions
Func _WinAPI_BitBlt($hdestdc, $ixdest, $iydest, $iwidth, $iheight, $hsrcdc, $ixsrc, $iysrc, $irop)
    Local $acall = DllCall("gdi32.dll", "bool", "BitBlt", "handle", $hdestdc, "int", $ixdest, "int", $iydest, "int", $iwidth, "int", $iheight, "handle", $hsrcdc, "int", $ixsrc, "int", $iysrc, "dword", $irop)
    If @error Then Return SetError(@error, @extended, False)
    Return $acall[0x0]
EndFunc   ;==>_WINAPI_BITBLT
Func _WinAPI_CombineRgn($hrgndest, $hrgnsrc1, $hrgnsrc2, $icombinemode)
    Local $acall = DllCall("gdi32.dll", "int", "CombineRgn", "handle", $hrgndest, "handle", $hrgnsrc1, "handle", $hrgnsrc2, "int", $icombinemode)
    If @error Then Return SetError(@error, @extended, 0x0)
    Return $acall[0x0]
EndFunc   ;==>_WINAPI_COMBINERGN
Func _WINAPI_COPYBITMAP($hbitmap)
    $hbitmap = _WINAPI_COPYIMAGE($hbitmap, 0x0, 0x0, 0x0, 0x2000)
    Return SetError(@error, @extended, $hbitmap)
EndFunc   ;==>_WINAPI_COPYBITMAP
Func _WINAPI_COPYIMAGE($himage, $itype = 0x0, $ixdesiredpixels = 0x0, $iydesiredpixels = 0x0, $iflags = 0x0)
    Local $acall = DllCall("user32.dll", "handle", "CopyImage", "handle", $himage, "uint", $itype, "int", $ixdesiredpixels, "int", $iydesiredpixels, "uint", $iflags)
    If @error Then Return SetError(@error, @extended, 0x0)
    Return $acall[0x0]
EndFunc   ;==>_WINAPI_COPYIMAGE
Func _WINAPI_CREATEANDBITMAP($hbitmap)
    Local $ierror = 0x0, $hdib = 0x0
    $hbitmap = _WINAPI_COPYBITMAP($hbitmap)
    If Not $hbitmap Then Return SetError(@error + 0x14, @extended, 0x0)
    Do
        Local $atdib[0x2]
        $atdib[0x0] = DllStructCreate($tagdibsection)
        If (Not _WinAPI_GetObject($hbitmap, DllStructGetSize($atdib[0x0]), $atdib[0x0])) Or (DllStructGetData($atdib[0x0], "bmBitsPixel") <> 0x20) Or (DllStructGetData($atdib[0x0], "biCompression")) Then
            $ierror = 0xa
            ExitLoop
        EndIf
        $atdib[0x1] = DllStructCreate($tagbitmap)
        $hdib = _WINAPI_CREATEDIB(DllStructGetData($atdib[0x0], "bmWidth"), DllStructGetData($atdib[0x0], "bmHeight"), 0x1)
        If Not _WinAPI_GetObject($hdib, DllStructGetSize($atdib[0x1]), $atdib[0x1]) Then
            $ierror = 0xb
            ExitLoop
        EndIf
        Local $acall = DllCall("user32.dll", "lresult", "CallWindowProc", "ptr", __ANDPROC(), "ptr", 0x0, "uint", 0x0, "wparam", DllStructGetPtr($atdib[0x0]), "lparam", DllStructGetPtr($atdib[0x1]))
        If @error Then
            $ierror = @error
            ExitLoop
        EndIf
        If Not $acall[0x0] Then
            $ierror = 0xc
            ExitLoop
        EndIf
        $ierror = 0x0
    Until 0x1
    _WinAPI_DeleteObject($hbitmap)
    If $ierror Then
        If $hdib Then
            _WinAPI_DeleteObject($hdib)
        EndIf
        $hdib = 0x0
    EndIf
    Return SetError($ierror, 0x0, $hdib)
EndFunc   ;==>_WINAPI_CREATEANDBITMAP
Func _WinAPI_CreateBitmap($iwidth, $iheight, $iplanes = 0x1, $ibitsperpel = 0x1, $pbits = 0x0)
    Local $acall = DllCall("gdi32.dll", "handle", "CreateBitmap", "int", $iwidth, "int", $iheight, "uint", $iplanes, "uint", $ibitsperpel, "struct*", $pbits)
    If @error Then Return SetError(@error, @extended, 0x0)
    Return $acall[0x0]
EndFunc   ;==>_WINAPI_CREATEBITMAP
Func _WinAPI_CreateCompatibleBitmap($hdc, $iwidth, $iheight)
    Local $acall = DllCall("gdi32.dll", "handle", "CreateCompatibleBitmap", "handle", $hdc, "int", $iwidth, "int", $iheight)
    If @error Then Return SetError(@error, @extended, 0x0)
    Return $acall[0x0]
EndFunc   ;==>_WINAPI_CREATECOMPATIBLEBITMAP
Func _WINAPI_CREATEDIB($iwidth, $iheight, $ibitsperpel = 0x20, $tcolortable = 0x0, $icolorcount = 0x0)
    Local $argbq[0x2], $icolors, $tagrgbq
    Switch $ibitsperpel
        Case 0x1
            $icolors = 0x2
        Case 0x4
            $icolors = 0x10
        Case 0x8
            $icolors = 0x100
        Case Else
            $icolors = 0x0
    EndSwitch
    If $icolors Then
        If Not IsDllStruct($tcolortable) Then
            Switch $ibitsperpel
                Case 0x1
                    $argbq[0x0] = 0x0
                    $argbq[0x1] = 0xffffff
                    $tcolortable = _WINAPI_CREATEDIBCOLORTABLE($argbq)
                Case Else
            EndSwitch
        Else
            If $icolors > $icolorcount Then
                $icolors = $icolorcount
            EndIf
            If (Not $icolors) Or ((0x4 * $icolors) > DllStructGetSize($tcolortable)) Then
                Return SetError(0x14, 0x0, 0x0)
            EndIf
        EndIf
        $tagrgbq = ";dword aRGBQuad[" & $icolors & "]"
    Else
        $tagrgbq = ""
    EndIf
    Local $tbitmapinfo = DllStructCreate($tagbitmapinfoheader & $tagrgbq)
    DllStructSetData($tbitmapinfo, "biSize", 0x28)
    DllStructSetData($tbitmapinfo, "biWidth", $iwidth)
    DllStructSetData($tbitmapinfo, "biHeight", $iheight)
    DllStructSetData($tbitmapinfo, "biPlanes", 0x1)
    DllStructSetData($tbitmapinfo, "biBitCount", $ibitsperpel)
    DllStructSetData($tbitmapinfo, "biCompression", 0x0)
    DllStructSetData($tbitmapinfo, "biSizeImage", 0x0)
    DllStructSetData($tbitmapinfo, "biXPelsPerMeter", 0x0)
    DllStructSetData($tbitmapinfo, "biYPelsPerMeter", 0x0)
    DllStructSetData($tbitmapinfo, "biClrUsed", $icolors)
    DllStructSetData($tbitmapinfo, "biClrImportant", 0x0)
    If $icolors Then
        If IsDllStruct($tcolortable) Then
            _WINAPI_MOVEMEMORY(DllStructGetPtr($tbitmapinfo, "aRGBQuad"), $tcolortable, 0x4 * $icolors)
        Else
            _WINAPI_ZEROMEMORY(DllStructGetPtr($tbitmapinfo, "aRGBQuad"), 0x4 * $icolors)
        EndIf
    EndIf
    Local $hbitmap = _WINAPI_CREATEDIBSECTION(0x0, $tbitmapinfo, 0x0, $__g_vext)
    If Not $hbitmap Then Return SetError(@error, @extended, 0x0)
    Return $hbitmap
EndFunc   ;==>_WINAPI_CREATEDIB
Func _WINAPI_CREATEDIBSECTION($hdc, $tbitmapinfo, $iusage, ByRef $pbits, $hsection = 0x0, $ioffset = 0x0)
    $pbits = 0x0
    Local $acall = DllCall("gdi32.dll", "handle", "CreateDIBSection", "handle", $hdc, "struct*", $tbitmapinfo, "uint", $iusage, "ptr*", 0x0, "handle", $hsection, "dword", $ioffset)
    If @error Or Not $acall[0x0] Then Return SetError(@error, @extended, 0x0)
    $pbits = $acall[0x4]
    Return $acall[0x0]
EndFunc   ;==>_WINAPI_CREATEDIBSECTION
Func _WINAPI_CREATEDIBCOLORTABLE(Const ByRef $acolortable, $istart = 0x0, $iend = +0xffffffff)
    If __CHECKERRORARRAYBOUNDS($acolortable, $istart, $iend) Then Return SetError(@error + 0xa, @extended, 0x0)
    Local $tcolortable = DllStructCreate("dword[" & ($iend - $istart + 0x1) & "]")
    Local $icount = 0x1
    For $i = $istart To $iend
        DllStructSetData($tcolortable, 0x1, _WINAPI_SWITCHCOLOR(__RGB($acolortable[$i])), $icount)
        $icount += 0x1
    Next
    Return $tcolortable
EndFunc   ;==>_WINAPI_CREATEDIBCOLORTABLE
Func _WinAPI_CreateFont($iheight, $iwidth, $iescape = 0x0, $iorientn = 0x0, $iweight = $__winapiconstant_fw_normal, $bitalic = False, $bunderline = False, $bstrikeout = False, $icharset = $__winapiconstant_default_charset, $ioutputprec = $__winapiconstant_out_default_precis, $iclipprec = $__winapiconstant_clip_default_precis, $iquality = $__winapiconstant_default_quality, $ipitch = 0x0, $sface = "Arial")
    Local $acall = DllCall("gdi32.dll", "handle", "CreateFontW", "int", $iheight, "int", $iwidth, "int", $iescape, "int", $iorientn, "int", $iweight, "dword", $bitalic, "dword", $bunderline, "dword", $bstrikeout, "dword", $icharset, "dword", $ioutputprec, "dword", $iclipprec, "dword", $iquality, "dword", $ipitch, "wstr", $sface)
    If @error Then Return SetError(@error, @extended, 0x0)
    Return $acall[0x0]
EndFunc   ;==>_WINAPI_CREATEFONT
Func _WinAPI_CreateFontIndirect($tlogfont)
    Local $acall = DllCall("gdi32.dll", "handle", "CreateFontIndirectW", "struct*", $tlogfont)
    If @error Then Return SetError(@error, @extended, 0x0)
    Return $acall[0x0]
EndFunc   ;==>_WINAPI_CREATEFONTINDIRECT
Func _WinAPI_CreateRectRgn($ileftrect, $itoprect, $irightrect, $ibottomrect)
    Local $acall = DllCall("gdi32.dll", "handle", "CreateRectRgn", "int", $ileftrect, "int", $itoprect, "int", $irightrect, "int", $ibottomrect)
    If @error Then Return SetError(@error, @extended, 0x0)
    Return $acall[0x0]
EndFunc   ;==>_WINAPI_CREATERECTRGN
Func _WinAPI_CreateRoundRectRgn($ileftrect, $itoprect, $irightrect, $ibottomrect, $iwidthellipse, $iheightellipse)
    Local $acall = DllCall("gdi32.dll", "handle", "CreateRoundRectRgn", "int", $ileftrect, "int", $itoprect, "int", $irightrect, "int", $ibottomrect, "int", $iwidthellipse, "int", $iheightellipse)
    If @error Then Return SetError(@error, @extended, 0x0)
    Return $acall[0x0]
EndFunc   ;==>_WINAPI_CREATEROUNDRECTRGN
Func _WinAPI_CreateSolidBrush($icolor)
    Local $acall = DllCall("gdi32.dll", "handle", "CreateSolidBrush", "INT", $icolor)
    If @error Then Return SetError(@error, @extended, 0x0)
    Return $acall[0x0]
EndFunc   ;==>_WINAPI_CREATESOLIDBRUSH
Func _WINAPI_GETBITMAPDIMENSION($hbitmap)
    Local $tobj = DllStructCreate($tagbitmap)
    Local $acall = DllCall("gdi32.dll", "int", "GetObject", "handle", $hbitmap, "int", DllStructGetSize($tobj), "struct*", $tobj)
    If @error Or Not $acall[0x0] Then Return SetError(@error + 0xa, @extended, 0x0)
    Return _WINAPI_CREATESIZE(DllStructGetData($tobj, "bmWidth"), DllStructGetData($tobj, "bmHeight"))
EndFunc   ;==>_WINAPI_GETBITMAPDIMENSION
Func _WinAPI_GetSysColorBrush($iindex)
    Local $acall = DllCall("user32.dll", "handle", "GetSysColorBrush", "int", $iindex)
    If @error Then Return SetError(@error, @extended, 0x0)
    Return $acall[0x0]
EndFunc   ;==>_WINAPI_GETSYSCOLORBRUSH
Func _WinAPI_GetTextExtentPoint32($hdc, $stext)
    Local $tsize = DllStructCreate($tagsize)
    Local $isize = StringLen($stext)
    Local $acall = DllCall("gdi32.dll", "bool", "GetTextExtentPoint32W", "handle", $hdc, "wstr", $stext, "int", $isize, "struct*", $tsize)
    If @error Or Not $acall[0x0] Then Return SetError(@error + 0xa, @extended, 0x0)
    Return $tsize
EndFunc   ;==>_WINAPI_GETTEXTEXTENTPOINT32
Func _WinAPI_GetTextMetrics($hdc)
    Local $ttextmetric = DllStructCreate($tagtextmetric)
    Local $acall = DllCall("gdi32.dll", "bool", "GetTextMetricsW", "handle", $hdc, "struct*", $ttextmetric)
    If @error Or Not $acall[0x0] Then Return SetError(@error + 0xa, @extended, 0x0)
    Return $ttextmetric
EndFunc   ;==>_WINAPI_GETTEXTMETRICS
Func _WinAPI_GetWindowRgn($hwnd, $hrgn)
    Local $acall = DllCall("user32.dll", "int", "GetWindowRgn", "hwnd", $hwnd, "handle", $hrgn)
    If @error Then Return SetError(@error, @extended, 0x0)
    Return $acall[0x0]
EndFunc   ;==>_WINAPI_GETWINDOWRGN
Func _WINAPI_ISALPHABITMAP($hbitmap)
    $hbitmap = _WINAPI_COPYBITMAP($hbitmap)
    If Not $hbitmap Then Return SetError(@error + 0x14, @extended, 0x0)
    Local $acall, $ierror = 0x0
    Do
        Local $tdib = DllStructCreate($tagdibsection)
        If (Not _WinAPI_GetObject($hbitmap, DllStructGetSize($tdib), $tdib)) Or (DllStructGetData($tdib, "bmBitsPixel") <> 0x20) Or (DllStructGetData($tdib, "biCompression")) Then
            $ierror = 0x1
            ExitLoop
        EndIf
        $acall = DllCall("user32.dll", "int", "CallWindowProc", "ptr", __ALPHAPROC(), "ptr", 0x0, "uint", 0x0, "struct*", $tdib, "ptr", 0x0)
        If @error Or ($acall[0x0] = +0xffffffff) Then
            $ierror = @error + 0xa
            ExitLoop
        EndIf
    Until 0x1
    _WinAPI_DeleteObject($hbitmap)
    If $ierror Then Return SetError($ierror, 0x0, 0x0)
    Return $acall[0x0]
EndFunc   ;==>_WINAPI_ISALPHABITMAP
Func _WinAPI_PtInRect(ByRef $trect, ByRef $tpoint)
    Local $acall = DllCall("user32.dll", "bool", "PtInRect", "struct*", $trect, "struct", $tpoint)
    If @error Then Return SetError(@error, @extended, False)
    Return $acall[0x0]
EndFunc   ;==>_WINAPI_PTINRECT
Func _WinAPI_RedrawWindow($hwnd, $trect = 0x0, $hregion = 0x0, $iflags = 0x5)
    Local $acall = DllCall("user32.dll", "bool", "RedrawWindow", "hwnd", $hwnd, "struct*", $trect, "handle", $hregion, "uint", $iflags)
    If @error Then Return SetError(@error, @extended, False)
    Return $acall[0x0]
EndFunc   ;==>_WINAPI_REDRAWWINDOW
Func _WinAPI_SetWindowRgn($hwnd, $hrgn, $bredraw = True)
    Local $acall = DllCall("user32.dll", "int", "SetWindowRgn", "hwnd", $hwnd, "handle", $hrgn, "bool", $bredraw)
    If @error Then Return SetError(@error, @extended, False)
    Return $acall[0x0]
EndFunc   ;==>_WINAPI_SETWINDOWRGN
#endregion Public Functions
#region Embedded DLL Functions
Func __ALPHAPROC()
    Static $pproc = 0x0
    If Not $pproc Then
        If @AutoItX64 Then
            $pproc = __INIT(Binary("0x48894C240848895424104C894424184C894C24205541574831C050504883EC28" & "48837C24600074054831C0EB0748C7C0010000004821C0751F488B6C24604883" & "7D180074054831C0EB0748C7C0010000004821C07502EB0948C7C001000000EB" & "034831C04821C0740C48C7C0FFFFFFFF4863C0EB6F48C744242800000000488B" & "6C24604C637D04488B6C2460486345084C0FAFF849C1E7024983C7FC4C3B7C24" & "287C36488B6C24604C8B7D184C037C24284983C7034C897C2430488B6C243080" & "7D0000740C48C7C0010000004863C0EB1348834424280471A54831C04863C0EB" & "034831C04883C438415F5DC3"))
        Else
            $pproc = __INIT(Binary("0x555331C05050837C241C00740431C0EB05B80100000021C075198B6C241C837D" & "1400740431C0EB05B80100000021C07502EB07B801000000EB0231C021C07407" & "B8FFFFFFFFEB4FC70424000000008B6C241C8B5D048B6C241C0FAF5D08C1E302" & "83C3FC3B1C247C288B6C241C8B5D14031C2483C303895C24048B6C2404807D00" & "007407B801000000EB0C8304240471BE31C0EB0231C083C4085B5DC21000"))
        EndIf
    EndIf
    Return $pproc
EndFunc   ;==>__ALPHAPROC
Func __ANDPROC()
    Static $pproc = 0x0
    If Not $pproc Then
        If @AutoItX64 Then
            $pproc = __INIT(Binary("0x48894C240848895424104C894424184C894C2420554157415648C7C009000000" & "4883EC0848C704240000000048FFC875EF4883EC284883BC24A0000000007405" & "4831C0EB0748C7C0010000004821C00F85840000004883BC24A8000000007405" & "4831C0EB0748C7C0010000004821C07555488BAC24A000000048837D18007405" & "4831C0EB0748C7C0010000004821C07522488BAC24A800000048837D18007405" & "4831C0EB0748C7C0010000004821C07502EB0948C7C001000000EB034831C048" & "21C07502EB0948C7C001000000EB034831C04821C07502EB0948C7C001000000" & "EB034831C04821C0740B4831C04863C0E9D701000048C74424280000000048C7" & "44243000000000488BAC24A00000004C637D0849FFCF4C3B7C24300F8C9C0100" & "0048C74424380000000048C74424400000000048C744244800000000488BAC24" & "A00000004C637D0449FFCF4C3B7C24480F8CDB000000488BAC24A00000004C8B" & "7D184C037C24284983C7034C897C2450488B6C2450807D000074264C8B7C2440" & "4C8B74243849F7DE4983C61F4C89F148C7C00100000048D3E04909C74C897C24" & "4048FF4424384C8B7C24384983FF1F7E6F4C8B7C244049F7D74C897C244048C7" & "442458180000004831C0483B4424587F3D488BAC24A80000004C8B7D184C037C" & "24604C897C24504C8B7C2440488B4C245849D3FF4C89F850488B6C2458588845" & "0048FF4424604883442458F871B948C74424380000000048C744244000000000" & "48834424280448FF4424480F810BFFFFFF48837C24380074794C8B7C244049F7" & "D74C8B74243849F7DE4983C6204C89F148C7C0FFFFFFFF48D3E04921C74C897C" & "244048C7442458180000004831C0483B4424587F3D488BAC24A80000004C8B7D" & "184C037C24604C897C24504C8B7C2440488B4C245849D3FF4C89F850488B6C24" & "585888450048FF4424604883442458F871B948FF4424300F814AFEFFFF48C7C0" & "010000004863C0EB034831C04883C470415E415F5DC3"))
        Else
            $pproc = __INIT(Binary("0x555357BA0800000083EC04C70424000000004A75F3837C243800740431C0EB05" & "B80100000021C07562837C243C00740431C0EB05B80100000021C0753F8B6C24" & "38837D1400740431C0EB05B80100000021C075198B6C243C837D1400740431C0" & "EB05B80100000021C07502EB07B801000000EB0231C021C07502EB07B8010000" & "00EB0231C021C07502EB07B801000000EB0231C021C0740731C0E969010000C7" & "042400000000C7442404000000008B6C24388B5D084B3B5C24040F8C3F010000" & "C744240800000000C744240C00000000C7442410000000008B6C24388B5D044B" & "3B5C24100F8CA90000008B6C24388B5D14031C2483C303895C24148B6C241480" & "7D0000741C8B5C240C8B7C2408F7DF83C71F89F9B801000000D3E009C3895C24" & "0CFF4424088B5C240883FB1F7E578B5C240CF7D3895C240CC744241818000000" & "31C03B4424187F2D8B6C243C8B5D14035C241C895C24148B5C240C8B4C2418D3" & "FB538B6C241858884500FF44241C83442418F871CBC744240800000000C74424" & "0C0000000083042404FF4424100F8145FFFFFF837C240800745B8B5C240CF7D3" & "8B7C2408F7DF83C72089F9B8FFFFFFFFD3E021C3895C240CC744241818000000" & "31C03B4424187F2D8B6C243C8B5D14035C241C895C24148B5C240C8B4C2418D3" & "FB538B6C241858884500FF44241C83442418F871CBFF4424040F81AFFEFFFFB8" & "01000000EB0231C083C4205F5B5DC21000"))
        EndIf
    EndIf
    Return $pproc
EndFunc   ;==>__ANDPROC
Func __XORPROC()
    Static $pproc = 0x0
    If Not $pproc Then
        If @AutoItX64 Then
            $pproc = __INIT(Binary("0x48894C240848895424104C894424184C894C24205541574831C050504883EC28" & "48837C24600074054831C0EB0748C7C0010000004821C0751B48837C24680074" & "054831C0EB0748C7C0010000004821C07502EB0948C7C001000000EB034831C0" & "4821C074084831C04863C0EB7748C7442428000000004C637C24584983C7FC4C" & "3B7C24287C4F4C8B7C24604C037C24284C897C2430488B6C2430807D00007405" & "4831C0EB0748C7C0010000004821C0741C4C8B7C24684C037C24284983C7034C" & "897C2430488B6C2430C64500FF48834424280471A148C7C0010000004863C0EB" & "034831C04883C438415F5DC3"))
        Else
            $pproc = __INIT(Binary("0x555331C05050837C241C00740431C0EB05B80100000021C07516837C24200074" & "0431C0EB05B80100000021C07502EB07B801000000EB0231C021C0740431C0EB" & "5AC70424000000008B5C241883C3FC3B1C247C3E8B5C241C031C24895C24048B" & "6C2404807D0000740431C0EB05B80100000021C074168B5C2420031C2483C303" & "895C24048B6C2404C64500FF8304240471B6B801000000EB0231C083C4085B5D" & "C21000"))
        EndIf
    EndIf
    Return $pproc
EndFunc   ;==>__XORPROC
#endregion Embedded DLL Functions
#region Internal Functions
Func __INIT($ddata)
    Local $ilength = BinaryLen($ddata)
    Local $acall = DllCall("kernel32.dll", "ptr", "VirtualAlloc", "ptr", 0x0, "ulong_ptr", $ilength, "dword", 0x1000, "dword", 0x40)
    If @error Or Not $acall[0x0] Then __FATALEXIT(0x1, "Error allocating memory.")
    Local $tdata = DllStructCreate("byte[" & $ilength & "]", $acall[0x0])
    DllStructSetData($tdata, 0x1, $ddata)
    Return $acall[0x0]
EndFunc   ;==>__INIT
#endregion Internal Functions
#region Global Variables and Constants
Global Const $di_mask = 0x1
Global Const $di_image = 0x2
Global Const $di_normal = 0x3
Global Const $di_compat = 0x4
Global Const $di_defaultsize = 0x8
Global Const $di_nomirror = 0x10
Global Const $display_device_attached_to_desktop = 0x1
Global Const $display_device_multi_driver = 0x2
Global Const $display_device_primary_device = 0x4
Global Const $display_device_mirroring_driver = 0x8
Global Const $display_device_vga_compatible = 0x10
Global Const $display_device_removable = 0x20
Global Const $display_device_disconnect = 0x2000000
Global Const $display_device_remote = 0x4000000
Global Const $display_device_modespruned = 0x8000000
#endregion Global Variables and Constants
#region Functions list
#endregion Functions list
#region Public Functions
Func _WinAPI_CreateCompatibleDC($hdc)
    Local $acall = DllCall("gdi32.dll", "handle", "CreateCompatibleDC", "handle", $hdc)
    If @error Then Return SetError(@error, @extended, 0x0)
    Return $acall[0x0]
EndFunc   ;==>_WINAPI_CREATECOMPATIBLEDC
Func _WinAPI_DeleteDC($hdc)
    Local $acall = DllCall("gdi32.dll", "bool", "DeleteDC", "handle", $hdc)
    If @error Then Return SetError(@error, @extended, False)
    Return $acall[0x0]
EndFunc   ;==>_WINAPI_DELETEDC
Func _WinAPI_DrawEdge($hdc, $trect, $iedgetype, $iflags)
    Local $acall = DllCall("user32.dll", "bool", "DrawEdge", "handle", $hdc, "struct*", $trect, "uint", $iedgetype, "uint", $iflags)
    If @error Then Return SetError(@error, @extended, False)
    Return $acall[0x0]
EndFunc   ;==>_WINAPI_DRAWEDGE
Func _WinAPI_DrawFrameControl($hdc, $trect, $itype, $istate)
    Local $acall = DllCall("user32.dll", "bool", "DrawFrameControl", "handle", $hdc, "struct*", $trect, "uint", $itype, "uint", $istate)
    If @error Then Return SetError(@error, @extended, False)
    Return $acall[0x0]
EndFunc   ;==>_WINAPI_DRAWFRAMECONTROL
Func _WinAPI_DrawIcon($hdc, $ix, $iy, $hicon)
    Local $acall = DllCall("user32.dll", "bool", "DrawIcon", "handle", $hdc, "int", $ix, "int", $iy, "handle", $hicon)
    If @error Then Return SetError(@error, @extended, False)
    Return $acall[0x0]
EndFunc   ;==>_WINAPI_DRAWICON
Func _WinAPI_DrawIconEx($hdc, $ix, $iy, $hicon, $iwidth = 0x0, $iheight = 0x0, $istep = 0x0, $hbrush = 0x0, $iflags = 0x3)
    Local $ioptions
    Switch $iflags
        Case 0x1
            $ioptions = $di_mask
        Case 0x2
            $ioptions = $di_image
        Case 0x3
            $ioptions = $di_normal
        Case 0x4
            $ioptions = $di_compat
        Case 0x5
            $ioptions = $di_defaultsize
        Case Else
            $ioptions = $di_nomirror
    EndSwitch
    Local $acall = DllCall("user32.dll", "bool", "DrawIconEx", "handle", $hdc, "int", $ix, "int", $iy, "handle", $hicon, "int", $iwidth, "int", $iheight, "uint", $istep, "handle", $hbrush, "uint", $ioptions)
    If @error Then Return SetError(@error, @extended, False)
    Return $acall[0x0]
EndFunc   ;==>_WINAPI_DRAWICONEX
Func _WinAPI_DrawText($hdc, $stext, ByRef $trect, $iflags)
    Local $acall = DllCall("user32.dll", "int", "DrawTextW", "handle", $hdc, "wstr", $stext, "int", +0xffffffff, "struct*", $trect, "uint", $iflags)
    If @error Then Return SetError(@error, @extended, 0x0)
    Return $acall[0x0]
EndFunc   ;==>_WINAPI_DRAWTEXT
Func _WinAPI_EnumDisplayDevices($sdevice, $idevnum)
    Local $tname = 0x0, $iflags = 0x0, $adevice[0x5]
    If $sdevice <> "" Then
        $tname = DllStructCreate("wchar Text[" & StringLen($sdevice) + 0x1 & "]")
        DllStructSetData($tname, "Text", $sdevice)
    EndIf
    Local Const $tagdisplay_device = "dword Size;wchar Name[32];wchar String[128];dword Flags;wchar ID[128];wchar Key[128]"
    Local $tdevice = DllStructCreate($tagdisplay_device)
    Local $idevice = DllStructGetSize($tdevice)
    DllStructSetData($tdevice, "Size", $idevice)
    Local $acall = DllCall("user32.dll", "bool", "EnumDisplayDevicesW", "struct*", $tname, "dword", $idevnum, "struct*", $tdevice, "dword", 0x1)
    If @error Or Not $acall[0x0] Then Return SetError(@error + 0xa, @extended, 0x0)
    Local $in = DllStructGetData($tdevice, "Flags")
    If BitAND($in, $display_device_attached_to_desktop) <> 0x0 Then $iflags = BitOR($iflags, 0x1)
    If BitAND($in, $display_device_primary_device) <> 0x0 Then $iflags = BitOR($iflags, 0x2)
    If BitAND($in, $display_device_mirroring_driver) <> 0x0 Then $iflags = BitOR($iflags, 0x4)
    If BitAND($in, $display_device_vga_compatible) <> 0x0 Then $iflags = BitOR($iflags, 0x8)
    If BitAND($in, $display_device_removable) <> 0x0 Then $iflags = BitOR($iflags, 0x10)
    If BitAND($in, $display_device_modespruned) <> 0x0 Then $iflags = BitOR($iflags, 0x20)
    $adevice[0x0] = True
    $adevice[0x1] = DllStructGetData($tdevice, "Name")
    $adevice[0x2] = DllStructGetData($tdevice, "String")
    $adevice[0x3] = $iflags
    $adevice[0x4] = DllStructGetData($tdevice, "ID")
    Return $adevice
EndFunc   ;==>_WINAPI_ENUMDISPLAYDEVICES
Func _WinAPI_FillRect($hdc, $trect, $hbrush)
    Local $acall
    If IsPtr($hbrush) Then
        $acall = DllCall("user32.dll", "int", "FillRect", "handle", $hdc, "struct*", $trect, "handle", $hbrush)
    Else
        $acall = DllCall("user32.dll", "int", "FillRect", "handle", $hdc, "struct*", $trect, "dword_ptr", $hbrush)
    EndIf
    If @error Then Return SetError(@error, @extended, False)
    Return $acall[0x0]
EndFunc   ;==>_WINAPI_FILLRECT
Func _WinAPI_FrameRect($hdc, $trect, $hbrush)
    Local $acall = DllCall("user32.dll", "int", "FrameRect", "handle", $hdc, "struct*", $trect, "handle", $hbrush)
    If @error Then Return SetError(@error, @extended, False)
    Return $acall[0x0]
EndFunc   ;==>_WINAPI_FRAMERECT
Func _WinAPI_GetBkMode($hdc)
    Local $acall = DllCall("gdi32.dll", "int", "GetBkMode", "handle", $hdc)
    If @error Then Return SetError(@error, @extended, 0x0)
    Return $acall[0x0]
EndFunc   ;==>_WINAPI_GETBKMODE
Func _WinAPI_GetDC($hwnd)
    Local $acall = DllCall("user32.dll", "handle", "GetDC", "hwnd", $hwnd)
    If @error Then Return SetError(@error, @extended, 0x0)
    Return $acall[0x0]
EndFunc   ;==>_WINAPI_GETDC
Func _WINAPI_GETDCEX($hwnd, $hrgn, $iflags)
    Local $acall = DllCall("user32.dll", "handle", "GetDCEx", "hwnd", $hwnd, "handle", $hrgn, "dword", $iflags)
    If @error Then Return SetError(@error, @extended, 0x0)
    Return $acall[0x0]
EndFunc   ;==>_WINAPI_GETDCEX
Func _WinAPI_GetDeviceCaps($hdc, $iindex)
    Local $acall = DllCall("gdi32.dll", "int", "GetDeviceCaps", "handle", $hdc, "int", $iindex)
    If @error Then Return SetError(@error, @extended, 0x0)
    Return $acall[0x0]
EndFunc   ;==>_WINAPI_GETDEVICECAPS
Func _WINAPI_GETTEXTCOLOR($hdc)
    Local $acall = DllCall("gdi32.dll", "dword", "GetTextColor", "handle", $hdc)
    If @error Or ($acall[0x0] = 0xffffffff) Then Return SetError(@error, @extended, +0xffffffff)
    Return __RGB($acall[0x0])
EndFunc   ;==>_WINAPI_GETTEXTCOLOR
Func _WinAPI_GetWindowDC($hwnd)
    Local $acall = DllCall("user32.dll", "handle", "GetWindowDC", "hwnd", $hwnd)
    If @error Then Return SetError(@error, @extended, 0x0)
    Return $acall[0x0]
EndFunc   ;==>_WINAPI_GETWINDOWDC
Func _WINAPI_PRINTWINDOW($hwnd, $hdc, $bclient = False)
    Local $acall = DllCall("user32.dll", "bool", "PrintWindow", "hwnd", $hwnd, "handle", $hdc, "uint", $bclient)
    If @error Then Return SetError(@error, @extended, False)
    Return $acall[0x0]
EndFunc   ;==>_WINAPI_PRINTWINDOW
Func _WinAPI_ReleaseDC($hwnd, $hdc)
    Local $acall = DllCall("user32.dll", "int", "ReleaseDC", "hwnd", $hwnd, "handle", $hdc)
    If @error Then Return SetError(@error, @extended, False)
    Return $acall[0x0]
EndFunc   ;==>_WINAPI_RELEASEDC
Func _WINAPI_RESTOREDC($hdc, $iid)
    Local $acall = DllCall("gdi32.dll", "bool", "RestoreDC", "handle", $hdc, "int", $iid)
    If @error Then Return SetError(@error, @extended, False)
    Return $acall[0x0]
EndFunc   ;==>_WINAPI_RESTOREDC
Func _WINAPI_SAVEDC($hdc)
    Local $acall = DllCall("gdi32.dll", "int", "SaveDC", "handle", $hdc)
    If @error Then Return SetError(@error, @extended, 0x0)
    Return $acall[0x0]
EndFunc   ;==>_WINAPI_SAVEDC
Func _WinAPI_SetBkColor($hdc, $icolor)
    Local $acall = DllCall("gdi32.dll", "INT", "SetBkColor", "handle", $hdc, "INT", $icolor)
    If @error Then Return SetError(@error, @extended, +0xffffffff)
    Return $acall[0x0]
EndFunc   ;==>_WINAPI_SETBKCOLOR
Func _WinAPI_SetBkMode($hdc, $ibkmode)
    Local $acall = DllCall("gdi32.dll", "int", "SetBkMode", "handle", $hdc, "int", $ibkmode)
    If @error Then Return SetError(@error, @extended, 0x0)
    Return $acall[0x0]
EndFunc   ;==>_WINAPI_SETBKMODE
Func _WinAPI_SetTextColor($hdc, $icolor)
    Local $acall = DllCall("gdi32.dll", "INT", "SetTextColor", "handle", $hdc, "INT", $icolor)
    If @error Then Return SetError(@error, @extended, +0xffffffff)
    Return $acall[0x0]
EndFunc   ;==>_WINAPI_SETTEXTCOLOR
Func _WinAPI_TwipsPerPixelX()
    Local $hdc, $itwipsperpixelx
    $hdc = _WinAPI_GetDC(0x0)
    Local Const $__winapiconstant_logpixelsx = 0x58
    $itwipsperpixelx = 0x5a0 / _WinAPI_GetDeviceCaps($hdc, $__winapiconstant_logpixelsx)
    _WinAPI_ReleaseDC(0x0, $hdc)
    Return $itwipsperpixelx
EndFunc   ;==>_WINAPI_TWIPSPERPIXELX
Func _WinAPI_TwipsPerPixelY()
    Local $hdc, $itwipsperpixely
    $hdc = _WinAPI_GetDC(0x0)
    Local Const $__winapiconstant_logpixelsy = 0x5a
    $itwipsperpixely = 0x5a0 / _WinAPI_GetDeviceCaps($hdc, $__winapiconstant_logpixelsy)
    _WinAPI_ReleaseDC(0x0, $hdc)
    Return $itwipsperpixely
EndFunc   ;==>_WINAPI_TWIPSPERPIXELY
#endregion Public Functions
#region Internal Functions
#endregion Internal Functions
#region Global Variables and Constants
Global Const $idc_unknown = 0x0
Global Const $idc_appstarting = 0x7f8a
Global Const $idc_arrow = 0x7f00
Global Const $idc_cross = 0x7f03
Global Const $idc_hand = 0x7f89
Global Const $idc_help = 0x7f8b
Global Const $idc_ibeam = 0x7f01
Global Const $idc_no = 0x7f88
Global Const $idc_sizeall = 0x7f86
Global Const $idc_sizenesw = 0x7f83
Global Const $idc_sizens = 0x7f85
Global Const $idc_sizenwse = 0x7f82
Global Const $idc_sizewe = 0x7f84
Global Const $idc_uparrow = 0x7f04
Global Const $idc_wait = 0x7f02
Global Const $idi_application = 0x7f00
Global Const $idi_asterisk = 0x7f04
Global Const $idi_exclamation = 0x7f03
Global Const $idi_hand = 0x7f01
Global Const $idi_question = 0x7f02
Global Const $idi_winlogo = 0x7f05
Global Const $idi_shield = 0x7f06
Global Const $idi_error = $idi_hand
Global Const $idi_information = $idi_asterisk
Global Const $idi_warning = $idi_exclamation
#endregion Global Variables and Constants
#region Functions list
#endregion Functions list
#region Public Functions
Global Const $tagiconinfo = "bool Icon;dword XHotSpot;dword YHotSpot;handle hMask;handle hColor"
Func _WINAPI_ADDICONTRANSPARENCY($hicon, $ipercent = 0x32, $bdelete = False)
    Local $tbitmap, $hdib = 0x0, $hresult = 0x0
    Local $ahbitmap[0x2]
    Local $ticoninfo = DllStructCreate($tagiconinfo)
    Local $acall = DllCall("user32.dll", "bool", "GetIconInfo", "handle", $hicon, "struct*", $ticoninfo)
    If @error Or Not $acall[0x0] Then Return SetError(@error + 0xa, @extended, 0x0)
    For $i = 0x0 To 0x1
        $ahbitmap[$i] = DllStructGetData($ticoninfo, $i + 0x4)
    Next
    Local $ierror = 0x0
    Do
        $hdib = _WINAPI_COPYBITMAP($ahbitmap[0x1])
        If Not $hdib Then
            $ierror = 0x14
            ExitLoop
        EndIf
        $tbitmap = DllStructCreate($tagbitmap)
        If (Not _WinAPI_GetObject($hdib, DllStructGetSize($tbitmap), $tbitmap)) Or (DllStructGetData($tbitmap, "bmBitsPixel") <> 0x20) Then
            $ierror = 0x15
            ExitLoop
        EndIf
        $acall = DllCall("user32.dll", "lresult", "CallWindowProc", "PTR", __TRANSPARENCYPROC(), "hwnd", 0x0, "uint", $ipercent, "wparam", DllStructGetPtr($tbitmap), "lparam", 0x0)
        If @error Or Not $acall[0x0] Then
            $ierror = @error + 0x1e
            ExitLoop
        EndIf
        If $acall[0x0] = +0xffffffff Then
            $hresult = _WINAPI_CREATEEMPTYICON(DllStructGetData($tbitmap, "bmWidth"), DllStructGetData($tbitmap, "bmHeight"))
        Else
            $hresult = _WINAPI_CREATEICONINDIRECT($hdib, $ahbitmap[0x0])
        EndIf
        If Not $hresult Then $ierror = 0x16
    Until 0x1
    If $hdib Then
        _WinAPI_DeleteObject($hdib)
    EndIf
    For $i = 0x0 To 0x1
        If $ahbitmap[$i] Then
            _WinAPI_DeleteObject($ahbitmap[$i])
        EndIf
    Next
    If $ierror Then Return SetError($ierror, 0x0, 0x0)
    If $bdelete Then
        _WinAPI_DestroyIcon($hicon)
    EndIf
    Return $hresult
EndFunc   ;==>_WINAPI_ADDICONTRANSPARENCY
Func _WinAPI_CopyIcon($hicon)
    Local $acall = DllCall("user32.dll", "handle", "CopyIcon", "handle", $hicon)
    If @error Then Return SetError(@error, @extended, 0x0)
    Return $acall[0x0]
EndFunc   ;==>_WINAPI_COPYICON
Func _WINAPI_CREATE32BITHICON($hicon, $bdelete = False)
    Local $ahbitmap[0x2], $hresult = 0x0
    Local $adib[0x2][0x2] = [[0x0, 0x0], [0x0, 0x0]]
    Local $ticoninfo = DllStructCreate($tagiconinfo)
    Local $acall = DllCall("user32.dll", "bool", "GetIconInfo", "handle", $hicon, "struct*", $ticoninfo)
    If @error Or Not $acall[0x0] Then Return SetError(@error + 0xa, @extended, 0x0)
    For $i = 0x0 To 0x1
        $ahbitmap[$i] = DllStructGetData($ticoninfo, $i + 0x4)
    Next
    If _WINAPI_ISALPHABITMAP($ahbitmap[0x1]) Then
        $adib[0x0][0x0] = _WINAPI_CREATEANDBITMAP($ahbitmap[0x1])
        If Not @error Then
            $hresult = _WINAPI_CREATEICONINDIRECT($ahbitmap[0x1], $adib[0x0][0x0])
        EndIf
    Else
        Local $tsize = _WINAPI_GETBITMAPDIMENSION($ahbitmap[0x1])
        Local $asize[0x2]
        For $i = 0x0 To 0x1
            $asize[$i] = DllStructGetData($tsize, $i + 0x1)
        Next
        Local $hsrcdc = _WinAPI_CreateCompatibleDC(0x0)
        Local $hdstdc = _WinAPI_CreateCompatibleDC(0x0)
        Local $hsrcsv, $hdstsv
        For $i = 0x0 To 0x1
            $adib[$i][0x0] = _WINAPI_CREATEDIB($asize[0x0], $asize[0x1])
            $adib[$i][0x1] = $__g_vext
            $hsrcsv = _WinAPI_SelectObject($hsrcdc, $ahbitmap[$i])
            $hdstsv = _WinAPI_SelectObject($hdstdc, $adib[$i][0x0])
            _WinAPI_BitBlt($hdstdc, 0x0, 0x0, $asize[0x0], $asize[0x1], $hsrcdc, 0x0, 0x0, 0xc000ca)
            _WinAPI_SelectObject($hsrcdc, $hsrcsv)
            _WinAPI_SelectObject($hdstdc, $hdstsv)
        Next
        _WinAPI_DeleteDC($hsrcdc)
        _WinAPI_DeleteDC($hdstdc)
        $acall = DllCall("user32.dll", "lresult", "CallWindowProc", "ptr", __XORPROC(), "ptr", 0x0, "uint", $asize[0x0] * $asize[0x1] * 0x4, "wparam", $adib[0x0][0x1], "lparam", $adib[0x1][0x1])
        If Not @error And $acall[0x0] Then
            $hresult = _WINAPI_CREATEICONINDIRECT($adib[0x1][0x0], $ahbitmap[0x0])
        EndIf
    EndIf
    For $i = 0x0 To 0x1
        _WinAPI_DeleteObject($ahbitmap[$i])
        If $adib[$i][0x0] Then
            _WinAPI_DeleteObject($adib[$i][0x0])
        EndIf
    Next
    If Not $hresult Then Return SetError(0xb, 0x0, 0x0)
    If $bdelete Then
        _WinAPI_DestroyIcon($hicon)
    EndIf
    Return $hresult
EndFunc   ;==>_WINAPI_CREATE32BITHICON
Func _WINAPI_CREATEEMPTYICON($iwidth, $iheight, $ibitsperpel = 0x20)
    Local $hxor = _WINAPI_CREATEDIB($iwidth, $iheight, $ibitsperpel)
    Local $hand = _WINAPI_CREATEDIB($iwidth, $iheight, 0x1)
    Local $hdc = _WinAPI_CreateCompatibleDC(0x0)
    Local $hsv = _WinAPI_SelectObject($hdc, $hand)
    Local $hbrush = _WinAPI_CreateSolidBrush(0xffffff)
    Local $trect = _WINAPI_CREATERECT(0x0, 0x0, $iwidth, $iheight)
    _WinAPI_FillRect($hdc, $trect, $hbrush)
    _WinAPI_DeleteObject($hbrush)
    _WinAPI_SelectObject($hdc, $hsv)
    _WinAPI_DeleteDC($hdc)
    Local $hicon = _WINAPI_CREATEICONINDIRECT($hxor, $hand)
    Local $ierror = @error
    If $hxor Then
        _WinAPI_DeleteObject($hxor)
    EndIf
    If $hand Then
        _WinAPI_DeleteObject($hand)
    EndIf
    If Not $hicon Then Return SetError($ierror + 0xa, 0x0, 0x0)
    Return $hicon
EndFunc   ;==>_WINAPI_CREATEEMPTYICON
Func _WINAPI_CREATEICON($hinstance, $iwidth, $iheight, $iplanes, $ibitspixel, $pandbits, $pxorbits)
    Local $acall = DllCall("user32.dll", "handle", "CreateIcon", "handle", $hinstance, "int", $iwidth, "int", $iheight, "byte", $iplanes, "byte", $ibitspixel, "struct*", $pandbits, "struct*", $pxorbits)
    If @error Then Return SetError(@error, @extended, 0x0)
    Return $acall[0x0]
EndFunc   ;==>_WINAPI_CREATEICON
Func _WINAPI_CREATEICONFROMRESOURCEEX($pdata, $isize, $bicon = True, $ixdesiredpixels = 0x0, $iydesiredpixels = 0x0, $iflags = 0x0)
    Local $acall = DllCall("user32.dll", "handle", "CreateIconFromResourceEx", "ptr", $pdata, "dword", $isize, "bool", $bicon, "dword", 0x30000, "int", $ixdesiredpixels, "int", $iydesiredpixels, "uint", $iflags)
    If @error Then Return SetError(@error, @extended, 0x0)
    Return $acall[0x0]
EndFunc   ;==>_WINAPI_CREATEICONFROMRESOURCEEX
Func _WINAPI_CREATEICONINDIRECT($hbitmap, $hmask, $ixhotspot = 0x0, $iyhotspot = 0x0, $bicon = True)
    Local $ticoninfo = DllStructCreate($tagiconinfo)
    DllStructSetData($ticoninfo, 0x1, $bicon)
    DllStructSetData($ticoninfo, 0x2, $ixhotspot)
    DllStructSetData($ticoninfo, 0x3, $iyhotspot)
    DllStructSetData($ticoninfo, 0x4, $hmask)
    DllStructSetData($ticoninfo, 0x5, $hbitmap)
    Local $acall = DllCall("user32.dll", "handle", "CreateIconIndirect", "struct*", $ticoninfo)
    If @error Then Return SetError(@error, @extended, 0x0)
    Return $acall[0x0]
EndFunc   ;==>_WINAPI_CREATEICONINDIRECT
Func _WinAPI_DestroyIcon($hicon)
    Local $acall = DllCall("user32.dll", "bool", "DestroyIcon", "handle", $hicon)
    If @error Then Return SetError(@error, @extended, False)
    Return $acall[0x0]
EndFunc   ;==>_WINAPI_DESTROYICON
Func _WINAPI_EXTRACTICON($sicon, $iindex, $bsmall = False)
    Local $plarge, $psmall, $tptr = DllStructCreate("ptr")
    If $bsmall Then
        $plarge = 0x0
        $psmall = DllStructGetPtr($tptr)
    Else
        $plarge = DllStructGetPtr($tptr)
        $psmall = 0x0
    EndIf
    DllCall("shell32.dll", "uint", "ExtractIconExW", "wstr", $sicon, "int", $iindex, "ptr", $plarge, "ptr", $psmall, "uint", 0x1)
    If @error Then Return SetError(@error, @extended, 0x0)
    Return DllStructGetData($tptr, 0x1)
EndFunc   ;==>_WINAPI_EXTRACTICON
Func _WinAPI_ExtractIconEx($sfilepath, $iindex, $palarge, $pasmall, $iicons)
    Local $acall = DllCall("shell32.dll", "uint", "ExtractIconExW", "wstr", $sfilepath, "int", $iindex, "struct*", $palarge, "struct*", $pasmall, "uint", $iicons)
    If @error Then Return SetError(@error, @extended, 0x0)
    Return $acall[0x0]
EndFunc   ;==>_WINAPI_EXTRACTICONEX
Func _WINAPI_FILEICONINIT($brestore = True)
    Local $acall = DllCall("shell32.dll", "int", 0x294, "int", $brestore)
    If @error Or Not $acall[0x0] Then Return SetError(@error + 0xa, @extended, 0x0)
    Return 0x1
EndFunc   ;==>_WINAPI_FILEICONINIT
Func _WINAPI_GETICONDIMENSION($hicon)
    Local $ticoninfo = DllStructCreate($tagiconinfo)
    Local $acall = DllCall("user32.dll", "bool", "GetIconInfo", "handle", $hicon, "struct*", $ticoninfo)
    If @error Or Not $acall[0x0] Then Return SetError(@error + 0xa, @extended, 0x0)
    Local $tsize = _WINAPI_GETBITMAPDIMENSION(DllStructGetData($ticoninfo, 0x5))
    For $i = 0x4 To 0x5
        _WinAPI_DeleteObject(DllStructGetData($ticoninfo, $i))
    Next
    If Not IsDllStruct($tsize) Then Return SetError(0x14, 0x0, 0x0)
    Return $tsize
EndFunc   ;==>_WINAPI_GETICONDIMENSION
Func _WinAPI_GetIconInfo($hicon)
    Local $tinfo = DllStructCreate($tagiconinfo)
    Local $acall = DllCall("user32.dll", "bool", "GetIconInfo", "handle", $hicon, "struct*", $tinfo)
    If @error Or Not $acall[0x0] Then Return SetError(@error + 0xa, @extended, 0x0)
    Local $aicon[0x6]
    $aicon[0x0] = True
    $aicon[0x1] = DllStructGetData($tinfo, "Icon") <> 0x0
    $aicon[0x2] = DllStructGetData($tinfo, "XHotSpot")
    $aicon[0x3] = DllStructGetData($tinfo, "YHotSpot")
    $aicon[0x4] = DllStructGetData($tinfo, "hMask")
    $aicon[0x5] = DllStructGetData($tinfo, "hColor")
    Return $aicon
EndFunc   ;==>_WINAPI_GETICONINFO
Func _WINAPI_GETICONINFOEX($hicon)
    Local $tiiex = DllStructCreate("dword;int;dword;dword;ptr;ptr;ushort;wchar[260];wchar[260]")
    DllStructSetData($tiiex, 0x1, DllStructGetSize($tiiex))
    Local $acall = DllCall("user32.dll", "bool", "GetIconInfoExW", "handle", $hicon, "struct*", $tiiex)
    If @error Or Not $acall[0x0] Then Return SetError(@error + 0xa, @extended, 0x0)
    Local $aret[0x8]
    For $i = 0x0 To 0x7
        $aret[$i] = DllStructGetData($tiiex, $i + 0x2)
    Next
    Return $aret
EndFunc   ;==>_WINAPI_GETICONINFOEX
Func _WINAPI_LOADICON($hinstance, $sname)
    Local $stypeofname = "int"
    If IsString($sname) Then
        $stypeofname = "wstr"
    EndIf
    Local $acall = DllCall("user32.dll", "handle", "LoadIconW", "handle", $hinstance, $stypeofname, $sname)
    If @error Then Return SetError(@error, @extended, 0x0)
    Return $acall[0x0]
EndFunc   ;==>_WINAPI_LOADICON
Func _WINAPI_LOADICONMETRIC($hinstance, $sname, $imetric)
    Local $stypeofname = "int"
    If IsString($sname) Then
        $stypeofname = "wstr"
    EndIf
    Local $acall = DllCall("comctl32.dll", "long", "LoadIconMetric", "handle", $hinstance, $stypeofname, $sname, "int", $imetric, "handle*", 0x0)
    If @error Then Return SetError(@error, @extended, 0x0)
    If $acall[0x0] Then Return SetError(0xa, $acall[0x0], 0x0)
    Return $acall[0x4]
EndFunc   ;==>_WINAPI_LOADICONMETRIC
Func _WINAPI_LOADICONWITHSCALEDOWN($hinstance, $sname, $iwidth, $iheight)
    Local $stypeofname = "int"
    If IsString($sname) Then
        $stypeofname = "wstr"
    EndIf
    Local $acall = DllCall("comctl32.dll", "long", "LoadIconWithScaleDown", "handle", $hinstance, $stypeofname, $sname, "int", $iwidth, "int", $iheight, "handle*", 0x0)
    If @error Then Return SetError(@error, @extended, 0x0)
    If $acall[0x0] Then Return SetError(0xa, $acall[0x0], 0x0)
    Return $acall[0x5]
EndFunc   ;==>_WINAPI_LOADICONWITHSCALEDOWN
Func _WinAPI_LoadShell32Icon($iiconid)
    Local $ticons = DllStructCreate("ptr Data")
    Local $iicons = _WinAPI_ExtractIconEx("shell32.dll", $iiconid, 0x0, $ticons, 0x1)
    If @error Then Return SetError(@error, @extended, 0x0)
    If $iicons <= 0x0 Then Return SetError(0xa, 0x0, 0x0)
    Return DllStructGetData($ticons, "Data")
EndFunc   ;==>_WINAPI_LOADSHELL32ICON
Func _WINAPI_LOOKUPICONIDFROMDIRECTORYEX($pdata, $bicon = True, $ixdesiredpixels = 0x0, $iydesiredpixels = 0x0, $iflags = 0x0)
    Local $acall = DllCall("user32.dll", "int", "LookupIconIdFromDirectoryEx", "ptr", $pdata, "bool", $bicon, "int", $ixdesiredpixels, "int", $iydesiredpixels, "uint", $iflags)
    If @error Then Return SetError(@error, @extended, 0x0)
    Return $acall[0x0]
EndFunc   ;==>_WINAPI_LOOKUPICONIDFROMDIRECTORYEX
Func _WINAPI_MIRRORICON($hicon, $bdelete = False)
    If Not $bdelete Then
        $hicon = _WinAPI_CopyIcon($hicon)
    EndIf
    Local $acall = DllCall("comctl32.dll", "int", 0x19e, "ptr", 0x0, "ptr*", $hicon)
    If @error Or Not $acall[0x0] Then
        Local $ierror = @error + 0xa
        If $hicon And Not $bdelete Then
            _WinAPI_DestroyIcon($hicon)
        EndIf
        Return SetError($ierror, 0x0, 0x0)
    EndIf
    Return $acall[0x2]
EndFunc   ;==>_WINAPI_MIRRORICON
#endregion Public Functions
#region Embedded DLL Functions
Func __TRANSPARENCYPROC()
    Static $pproc = 0x0
    If Not $pproc Then
        If @AutoItX64 Then
            $pproc = __INIT(Binary("0x48894C240848895424104C894424184C894C24205541574831C0505050505050" & "4883EC284883BC24800000000074054831C0EB0748C7C0010000004821C07522" & "488BAC248000000048837D180074054831C0EB0748C7C0010000004821C07502" & "EB0948C7C001000000EB034831C04821C0740B4831C04863C0E93C0100004C63" & "7C24784983FF647E0F48C7C0010000004863C0E9220100004C637C24784D21FF" & "7D08C74424780000000048C74424280100000048C74424300000000048C74424" & "3800000000488BAC24800000004C637D04488BAC2480000000486345084C0FAF" & "F849C1E7024983C7FC4C3B7C24380F8C88000000488BAC24800000004C8B7D18" & "4C037C24384983C7034C897C2440488B6C2440480FB64500505888442448807C" & "244800744B4C0FB67C244848634424784C0FAFF84C89F848C7C1640000004899" & "48F7F94989C74C89F850488B6C244858884500488B6C2440807D0000740948C7" & "4424280000000048C7442430010000004883442438040F8149FFFFFF48837C24" & "3000741148837C242800740948C7C001000000EB034831C04821C0740E48C7C0" & "FFFFFFFF4863C0EB11EB0C48C7C0010000004863C0EB034831C04883C458415F" & "5DC3"))
        Else
            $pproc = __INIT(Binary("0x555331C05050505050837C242800740431C0EB05B80100000021C075198B6C24" & "28837D1400740431C0EB05B80100000021C07502EB07B801000000EB0231C021" & "C0740731C0E9E50000008B5C242483FB647E0AB801000000E9D20000008B5C24" & "2421DB7D08C744242400000000C7042401000000C744240400000000C7442408" & "000000008B6C24288B5D048B6C24280FAF5D08C1E30283C3FC3B5C24087C648B" & "6C24288B5D14035C240883C303895C240C8B6C240C0FB6450088442410807C24" & "100074380FB65C24100FAF5C242489D8B96400000099F7F989C3538B6C241058" & "8845008B6C240C807D00007407C7042400000000C74424040100000083442408" & "047181837C240400740D833C24007407B801000000EB0231C021C07409B8FFFF" & "FFFFEB0BEB07B801000000EB0231C083C4145B5DC21000"))
        EndIf
    EndIf
    Return $pproc
EndFunc   ;==>__TRANSPARENCYPROC
#endregion Embedded DLL Functions
#region Global Variables and Constants
Global Const $tagbitmapv4header = "struct;dword bV4Size;long bV4Width;long bV4Height;ushort bV4Planes;ushort bV4BitCount;dword bV4Compression;dword bV4SizeImage;long bV4XPelsPerMeter;long bV4YPelsPerMeter;dword bV4ClrUsed;dword bV4ClrImportant;dword bV4RedMask;dword bV4GreenMask;dword bV4BlueMask;dword bV4AlphaMask;dword bV4CSType;int bV4Endpoints[9];dword bV4GammaRed;dword bV4GammaGreen;dword bV4GammaBlue;endstruct"
Global Const $tagcoloradjustment = "ushort Size;ushort Flags;ushort IlluminantIndex;ushort RedGamma;ushort GreenGamma;ushort BlueGamma;ushort ReferenceBlack;ushort ReferenceWhite;short Contrast;short Brightness;short Colorfulness;short RedGreenTint"
Global Const $tagdevmode = "wchar DeviceName[32];ushort SpecVersion;ushort DriverVersion;ushort Size;ushort DriverExtra;dword Fields;short Orientation;short PaperSize;short PaperLength;short PaperWidth;short Scale;short Copies;short DefaultSource;short PrintQuality;short Color;short Duplex;short YResolution;short TTOption;short Collate;wchar FormName[32];ushort Unused1;dword Unused2[3];dword Nup;dword Unused3;dword ICMMethod;dword ICMIntent;dword MediaType;dword DitherType;dword Reserved1;dword Reserved2;dword PanningWidth;dword PanningHeight"
Global Const $tagdevmode_display = "wchar DeviceName[32];ushort SpecVersion;ushort DriverVersion;ushort Size;ushort DriverExtra;dword Fields;" & $tagpoint & ";dword DisplayOrientation;dword DisplayFixedOutput;short Unused1[5];wchar Unused2[32];ushort LogPixels;dword BitsPerPel;dword PelsWidth;dword PelsHeight;dword DisplayFlags;dword DisplayFrequency"
Global Const $tagdwm_colorization_parameters = "dword Color;dword AfterGlow;uint ColorBalance;uint AfterGlowBalance;uint BlurBalance;uint GlassReflectionIntensity; uint OpaqueBlend"
Global Const $tagenhmetaheader = "struct;dword Type;dword Size;long rcBounds[4];long rcFrame[4];dword Signature;dword Version;dword Bytes;dword Records;ushort Handles;ushort Reserved;dword Description;dword OffDescription;dword PalEntries;long Device[2];long Millimeters[2];dword PixelFormat;dword OffPixelFormat;dword OpenGL;long Micrometers[2];endstruct"
Global Const $tagextlogpen = "dword PenStyle;dword Width;uint BrushStyle;dword Color;ulong_ptr Hatch;dword NumEntries"
Global Const $tagfontsignature = "dword fsUsb[4];dword fsCsb[2]"
Global Const $tagglyphmetrics = "uint BlackBoxX;uint BlackBoxY;" & $tagpoint & ";short CellIncX;short CellIncY"
Global Const $taglogbrush = "uint Style;dword Color;ulong_ptr Hatch"
Global Const $taglogpen = "uint Style;dword Width;dword Color"
Global Const $tagmat2 = "short eM11[2];short eM12[2];short eM21[2];short eM22[2]"
Global Const $tagnewtextmetric = $tagtextmetric & ";dword ntmFlags;uint ntmSizeEM;uint ntmCellHeight;uint ntmAvgWidth"
Global Const $tagnewtextmetricex = $tagnewtextmetric & ";" & $tagfontsignature
Global Const $tagpanose = "struct;byte bFamilyType;byte bSerifStyle;byte bWeight;byte bProportion;byte bContrast;byte bStrokeVariation;byte bArmStyle;byte bLetterform;byte bMidline;byte bXHeight;endstruct"
Global Const $tagoutlinetextmetric = "struct;uint otmSize;" & $tagtextmetric & ";byte otmFiller;" & $tagpanose & ";byte bugFiller[3];uint otmSelection;uint otmType;int otmCharSlopeRise;int otmCharSlopeRun;int otmItalicAngle;uint otmEMSquare;int otmAscent;int otmDescent;uint otmLineGap;uint otmCapEmHeight;uint otmXHeight;long otmFontBox[4];int otmMacAscent;int otmMacDescent;uint otmMacLineGap;uint otmMinimumPPEM;long otmSubscriptSize[2];long otmSubscriptOffset[2];long otmSuperscriptSize[2];long otmSuperscriptOffse[2];uint otmStrikeoutSize;int otmStrikeoutPosition;int otmUnderscoreSize;int otmUnderscorePosition;uint_ptr otmFamilyName;uint_ptr otmFaceName;uint_ptr otmStyleName;uint_ptr otmFullName;endstruct"
Global Const $tagpaintstruct = "hwnd hDC;int fErase;dword rPaint[4];int fRestore;int fIncUpdate;byte rgbReserved[32]"
Global Const $tagrgndataheader = "struct;dword Size;dword Type;dword Count;dword RgnSize;" & $tagrect & ";endstruct"
Global Const $tagxform = "float eM11;float eM12;float eM21;float eM22;float eDx;float eDy"
#endregion Global Variables and Constants
#region Functions list
#endregion Functions list
#region Public Functions
Func _WINAPI_ABORTPATH($hdc)
    Local $acall = DllCall("gdi32.dll", "bool", "AbortPath", "handle", $hdc)
    If @error Then Return SetError(@error, @extended, False)
    Return $acall[0x0]
EndFunc   ;==>_WINAPI_ABORTPATH
Func _WINAPI_ADDFONTMEMRESOURCEEX($pdata, $isize)
    Local $acall = DllCall("gdi32.dll", "handle", "AddFontMemResourceEx", "ptr", $pdata, "dword", $isize, "ptr", 0x0, "dword*", 0x0)
    If @error Then Return SetError(@error, @extended, 0x0)
    Return SetExtended($acall[0x4], $acall[0x0])
EndFunc   ;==>_WINAPI_ADDFONTMEMRESOURCEEX
Func _WINAPI_ADDFONTRESOURCEEX($sfont, $iflag = 0x0, $bnotify = False)
    Local $acall = DllCall("gdi32.dll", "int", "AddFontResourceExW", "wstr", $sfont, "dword", $iflag, "ptr", 0x0)
    If @error Or Not $acall[0x0] Then Return SetError(@error, @extended, 0x0)
    If $bnotify Then
        Local Const $wm_fontchange = 0x1d
        Local Const $hwnd_broadcast = 0xffff
        DllCall("user32.dll", "lresult", "SendMessage", "hwnd", $hwnd_broadcast, "uint", $wm_fontchange, "wparam", 0x0, "lparam", 0x0)
    EndIf
    Return $acall[0x0]
EndFunc   ;==>_WINAPI_ADDFONTRESOURCEEX
Func _WINAPI_ADDICONOVERLAY($hicon, $hoverlay)
    Local $acall, $hresult = 0x0, $ierror = 0x0
    Local $ahdev[0x2] = [0x0, 0x0]
    Local $tsize = _WINAPI_GETICONDIMENSION($hicon)
    Local $hil = DllCall("comctl32.dll", "handle", "ImageList_Create", "int", DllStructGetData($tsize, 0x1), "int", DllStructGetData($tsize, 0x2), "uint", 0x21, "int", 0x2, "int", 0x2)
    If @error Or Not $hil[0x0] Then Return SetError(@error + 0xa, @extended, 0x0)
    Do
        $ahdev[0x0] = _WINAPI_CREATE32BITHICON($hicon)
        If @error Then
            $ierror = @error + 0x64
            ExitLoop
        EndIf
        $acall = DllCall("comctl32.dll", "int", "ImageList_ReplaceIcon", "handle", $hil[0x0], "int", +0xffffffff, "handle", $ahdev[0x0])
        If @error Or ($acall[0x0] = +0xffffffff) Then
            $ierror = @error + 0xc8
            ExitLoop
        EndIf
        $ahdev[0x1] = _WINAPI_CREATE32BITHICON($hoverlay)
        If @error Then
            $ierror = @error + 0x12c
            ExitLoop
        EndIf
        $acall = DllCall("comctl32.dll", "int", "ImageList_ReplaceIcon", "handle", $hil[0x0], "int", +0xffffffff, "handle", $ahdev[0x1])
        If @error Or ($acall[0x0] = +0xffffffff) Then
            $ierror = @error + 0x190
            ExitLoop
        EndIf
        $acall = DllCall("comctl32.dll", "bool", "ImageList_SetOverlayImage", "handle", $hil[0x0], "int", 0x1, "int", 0x1)
        If @error Or Not $acall[0x0] Then
            $ierror = @error + 0x1f4
            ExitLoop
        EndIf
        $acall = DllCall("comctl32.dll", "handle", "ImageList_GetIcon", "handle", $hil[0x0], "int", 0x0, "uint", 0x100)
        If @error Or Not $acall[0x0] Then
            $ierror = @error + 0x258
            ExitLoop
        EndIf
        $hresult = $acall[0x0]
    Until 0x1
    DllCall("comctl32.dll", "bool", "ImageList_Destroy", "handle", $hil[0x0])
    For $i = 0x0 To 0x1
        If $ahdev[$i] Then
            _WinAPI_DestroyIcon($ahdev[$i])
        EndIf
    Next
    If Not $hresult Then Return SetError($ierror, 0x0, 0x0)
    Return $hresult
EndFunc   ;==>_WINAPI_ADDICONOVERLAY
Func _WINAPI_ADJUSTBITMAP($hbitmap, $iwidth, $iheight, $imode = 0x3, $tadjustment = 0x0)
    Local $tobj = DllStructCreate($tagbitmap)
    Local $acall = DllCall("gdi32.dll", "int", "GetObject", "handle", $hbitmap, "int", DllStructGetSize($tobj), "struct*", $tobj)
    If @error Or Not $acall[0x0] Then Return SetError(@error, @extended, 0x0)
    If $iwidth = +0xffffffff Then
        $iwidth = DllStructGetData($tobj, "bmWidth")
    EndIf
    If $iheight = +0xffffffff Then
        $iheight = DllStructGetData($tobj, "bmHeight")
    EndIf
    $acall = DllCall("user32.dll", "handle", "GetDC", "hwnd", 0x0)
    Local $hdc = $acall[0x0]
    $acall = DllCall("gdi32.dll", "handle", "CreateCompatibleDC", "handle", $hdc)
    Local $hdestdc = $acall[0x0]
    $acall = DllCall("gdi32.dll", "handle", "CreateCompatibleBitmap", "handle", $hdc, "int", $iwidth, "int", $iheight)
    Local $hbmp = $acall[0x0]
    $acall = DllCall("gdi32.dll", "handle", "SelectObject", "handle", $hdestdc, "handle", $hbmp)
    Local $hdestsv = $acall[0x0]
    $acall = DllCall("gdi32.dll", "handle", "CreateCompatibleDC", "handle", $hdc)
    Local $hsrcdc = $acall[0x0]
    $acall = DllCall("gdi32.dll", "handle", "SelectObject", "handle", $hsrcdc, "handle", $hbitmap)
    Local $hsrcsv = $acall[0x0]
    If _WINAPI_SETSTRETCHBLTMODE($hdestdc, $imode) Then
        Switch $imode
            Case 0x4
                If IsDllStruct($tadjustment) Then
                    If Not _WINAPI_SETCOLORADJUSTMENT($hdestdc, $tadjustment) Then
                    EndIf
                EndIf
            Case Else
        EndSwitch
    EndIf
    $acall = _WINAPI_STRETCHBLT($hdestdc, 0x0, 0x0, $iwidth, $iheight, $hsrcdc, 0x0, 0x0, DllStructGetData($tobj, "bmWidth"), DllStructGetData($tobj, "bmHeight"), 0xcc0020)
    DllCall("user32.dll", "int", "ReleaseDC", "hwnd", 0x0, "handle", $hdc)
    DllCall("gdi32.dll", "handle", "SelectObject", "handle", $hdestdc, "handle", $hdestsv)
    DllCall("gdi32.dll", "handle", "SelectObject", "handle", $hsrcdc, "handle", $hsrcsv)
    DllCall("gdi32.dll", "bool", "DeleteDC", "handle", $hdestdc)
    DllCall("gdi32.dll", "bool", "DeleteDC", "handle", $hsrcdc)
    If Not $acall Then Return SetError(0xa, 0x0, 0x0)
    Return $hbmp
EndFunc   ;==>_WINAPI_ADJUSTBITMAP
Func _WINAPI_ALPHABLEND($hdestdc, $ixdest, $iydest, $iwidthdest, $iheightdest, $hsrcdc, $ixsrc, $iysrc, $iwidthsrc, $iheightsrc, $ialpha, $balpha = False)
    Local $iblend = BitOR(BitShift( Not ($balpha = False), +0xffffffe8), BitShift(BitAND($ialpha, 0xff), +0xfffffff0))
    Local $acall = DllCall("gdi32.dll", "bool", "GdiAlphaBlend", "handle", $hdestdc, "int", $ixdest, "int", $iydest, "int", $iwidthdest, "int", $iheightdest, "handle", $hsrcdc, "int", $ixsrc, "int", $iysrc, "int", $iwidthsrc, "int", $iheightsrc, "dword", $iblend)
    If @error Then Return SetError(@error, @extended, False)
    Return $acall[0x0]
EndFunc   ;==>_WINAPI_ALPHABLEND
Func _WINAPI_ANGLEARC($hdc, $ix, $iy, $iradius, $nstartangle, $nsweepangle)
    Local $acall = DllCall("gdi32.dll", "bool", "AngleArc", "handle", $hdc, "int", $ix, "int", $iy, "dword", $iradius, "float", $nstartangle, "float", $nsweepangle)
    If @error Then Return SetError(@error, @extended, False)
    Return $acall[0x0]
EndFunc   ;==>_WINAPI_ANGLEARC
Func _WINAPI_ARC($hdc, $trect, $ixstartarc, $iystartarc, $ixendarc, $iyendarc)
    Local $acall = DllCall("gdi32.dll", "bool", "Arc", "handle", $hdc, "int", DllStructGetData($trect, 0x1), "int", DllStructGetData($trect, 0x2), "int", DllStructGetData($trect, 0x3), "int", DllStructGetData($trect, 0x4), "int", $ixstartarc, "int", $iystartarc, "int", $ixendarc, "int", $iyendarc)
    If @error Then Return SetError(@error, @extended, False)
    Return $acall[0x0]
EndFunc   ;==>_WINAPI_ARC
Func _WINAPI_ARCTO($hdc, $trect, $ixradial1, $iyradial1, $ixradial2, $iyradial2)
    Local $acall = DllCall("gdi32.dll", "bool", "ArcTo", "handle", $hdc, "int", DllStructGetData($trect, 0x1), "int", DllStructGetData($trect, 0x2), "int", DllStructGetData($trect, 0x3), "int", DllStructGetData($trect, 0x4), "int", $ixradial1, "int", $iyradial1, "int", $ixradial2, "int", $iyradial2)
    If @error Then Return SetError(@error, @extended, False)
    Return $acall[0x0]
EndFunc   ;==>_WINAPI_ARCTO
Func _WINAPI_BEGINPAINT($hwnd, ByRef $tpaintstruct)
    $tpaintstruct = DllStructCreate($tagpaintstruct)
    Local $acall = DllCall("user32.dll", "handle", "BeginPaint", "hwnd", $hwnd, "struct*", $tpaintstruct)
    If @error Then Return SetError(@error, @extended, 0x0)
    Return $acall[0x0]
EndFunc   ;==>_WINAPI_BEGINPAINT
Func _WINAPI_BEGINPATH($hdc)
    Local $acall = DllCall("gdi32.dll", "bool", "BeginPath", "handle", $hdc)
    If @error Then Return SetError(@error, @extended, False)
    Return $acall[0x0]
EndFunc   ;==>_WINAPI_BEGINPATH
Func _WINAPI_CLOSEENHMETAFILE($hdc)
    Local $acall = DllCall("gdi32.dll", "handle", "CloseEnhMetaFile", "handle", $hdc)
    If @error Then Return SetError(@error, @extended, 0x0)
    Return $acall[0x0]
EndFunc   ;==>_WINAPI_CLOSEENHMETAFILE
Func _WINAPI_CLOSEFIGURE($hdc)
    Local $acall = DllCall("gdi32.dll", "bool", "CloseFigure", "handle", $hdc)
    If @error Then Return SetError(@error, @extended, False)
    Return $acall[0x0]
EndFunc   ;==>_WINAPI_CLOSEFIGURE
Func _WINAPI_COLORADJUSTLUMA($irgb, $ipercent, $bscale = True)
    If $irgb = +0xffffffff Then Return SetError(0xa, 0x0, +0xffffffff)
    If $bscale Then
        $ipercent = Floor($ipercent * 0xa)
    EndIf
    Local $acall = DllCall("shlwapi.dll", "dword", "ColorAdjustLuma", "dword", __RGB($irgb), "int", $ipercent, "bool", $bscale)
    If @error Then Return SetError(@error, @extended, +0xffffffff)
    Return __RGB($acall[0x0])
EndFunc   ;==>_WINAPI_COLORADJUSTLUMA
Func _WINAPI_COLORHLSTORGB($ihue, $iluminance, $isaturation)
    If Not $isaturation Then $ihue = 0xa0
    Local $acall = DllCall("shlwapi.dll", "dword", "ColorHLSToRGB", "word", $ihue, "word", $iluminance, "word", $isaturation)
    If @error Then Return SetError(@error, @extended, +0xffffffff)
    Return __RGB($acall[0x0])
EndFunc   ;==>_WINAPI_COLORHLSTORGB
Func _WINAPI_COLORRGBTOHLS($irgb, ByRef $ihue, ByRef $iluminance, ByRef $isaturation)
    Local $acall = DllCall("shlwapi.dll", "none", "ColorRGBToHLS", "dword", __RGB($irgb), "word*", 0x0, "word*", 0x0, "word*", 0x0)
    If @error Then Return SetError(@error, @extended, 0x0)
    $ihue = $acall[0x2]
    $iluminance = $acall[0x3]
    $isaturation = $acall[0x4]
    Return 0x1
EndFunc   ;==>_WINAPI_COLORRGBTOHLS
Func _WINAPI_COMBINETRANSFORM($txform1, $txform2)
    Local $txform = DllStructCreate($tagxform)
    Local $acall = DllCall("gdi32.dll", "bool", "CombineTransform", "struct*", $txform, "struct*", $txform1, "struct*", $txform2)
    If @error Or Not $acall[0x0] Then Return SetError(@error + 0xa, @extended, 0x0)
    Return $txform
EndFunc   ;==>_WINAPI_COMBINETRANSFORM
Func _WINAPI_COMPRESSBITMAPBITS($hbitmap, ByRef $pbuffer, $icompression = 0x0, $iquality = 0x64)
    If Not __DLL("gdiplus.dll") Then Return SetError(0x67, 0x0, 0x0)
    Local $asize[0x2], $icount, $iformat, $ilength, $smime, $acall, $hdc, $hsv, $hmem, $tbits, $tdata, $pdata, $ierror = 0x1
    Local $hsource = 0x0, $himage = 0x0, $htoken = 0x0, $pstream = 0x0, $tparam = 0x0
    Local $tdib = DllStructCreate($tagdibsection)
    Do
        Switch $icompression
            Case 0x0
                $smime = "image/png"
            Case 0x1
                $smime = "image/jpeg"
            Case Else
                $ierror = 0xa
                ExitLoop
        EndSwitch
        While $hbitmap
            If Not _WinAPI_GetObject($hbitmap, DllStructGetSize($tdib), $tdib) Then
                $ierror = 0xb
                ExitLoop 0x2
            EndIf
            If (DllStructGetData($tdib, "bmBitsPixel") = 0x20) And (Not DllStructGetData($tdib, "biCompression")) Then
                $ierror = 0xc
                ExitLoop
            EndIf
            If $hsource Then
                $ierror = 0xd
                ExitLoop 0x2
            EndIf
            $hsource = _WINAPI_CREATEDIB(DllStructGetData($tdib, "bmWidth"), DllStructGetData($tdib, "bmHeight"))
            If Not $hsource Then
                $ierror = @error + 0x64
                ExitLoop 0x2
            EndIf
            $hdc = _WinAPI_CreateCompatibleDC(0x0)
            $hsv = _WinAPI_SelectObject($hdc, $hsource)
            If _WINAPI_DRAWBITMAP($hdc, 0x0, 0x0, $hbitmap) Then
                $hbitmap = $hsource
            Else
                $ierror = @error + 0xc8
                $hbitmap = 0x0
            EndIf
            _WinAPI_SelectObject($hdc, $hsv)
            _WinAPI_DeleteDC($hdc)
        WEnd
        If Not $hbitmap Then
            ExitLoop
        EndIf
        For $i = 0x0 To 0x1
            $asize[$i] = DllStructGetData($tdib, $i + 0x2)
        Next
        $tbits = DllStructCreate("byte[" & ($asize[0x0] * $asize[0x1] * 0x4) & "]")
        If Not _WINAPI_GETBITMAPBITS($hbitmap, DllStructGetSize($tbits), $tbits) Then
            $ierror = @error + 0x12c
            ExitLoop
        EndIf
        $tdata = DllStructCreate($taggdipstartupinput)
        DllStructSetData($tdata, "Version", 0x1)
        $acall = DllCall("gdiplus.dll", "int", "GdiplusStartup", "ulong_ptr*", 0x0, "struct*", $tdata, "ptr", 0x0)
        If @error Or $acall[0x0] Then
            $ierror = @error + 0x190
            ExitLoop
        EndIf
        If _WINAPI_ISALPHABITMAP($hbitmap) Then
            $iformat = 0x26200a
        Else
            $iformat = 0x22009
        EndIf
        $htoken = $acall[0x1]
        $acall = DllCall("gdiplus.dll", "int", "GdipCreateBitmapFromScan0", "int", $asize[0x0], "int", $asize[0x1], "uint", $asize[0x0] * 0x4, "int", $iformat, "struct*", $tbits, "ptr*", 0x0)
        If @error Or $acall[0x0] Then
            $ierror = @error + 0x1f4
            ExitLoop
        EndIf
        $himage = $acall[0x6]
        $acall = DllCall("gdiplus.dll", "int", "GdipGetImageEncodersSize", "uint*", 0x0, "uint*", 0x0)
        If @error Or $acall[0x0] Then
            $ierror = @error + 0x258
            ExitLoop
        EndIf
        $icount = $acall[0x1]
        $tdata = DllStructCreate("byte[" & $acall[0x2] & "]")
        If @error Then
            $ierror = @error + 0x2bc
            ExitLoop
        EndIf
        $pdata = DllStructGetPtr($tdata)
        $acall = DllCall("gdiplus.dll", "int", "GdipGetImageEncoders", "uint", $icount, "uint", $acall[0x2], "struct*", $tdata)
        If @error Or $acall[0x0] Then
            $ierror = @error + 0x320
            ExitLoop
        EndIf
        Local $tcodec, $pencoder = 0x0
        For $i = 0x1 To $icount
            $tcodec = DllStructCreate($taggdipimagecodecinfo, $pdata)
            If Not StringInStr(_WINAPI_GETSTRING(DllStructGetData($tcodec, "MimeType")), $smime) Then
                $pdata += DllStructGetSize($taggdipimagecodecinfo)
            Else
                $pencoder = $pdata
                $ierror = 0x0
                ExitLoop
            EndIf
        Next
        If Not $pencoder Then
            $ierror = 0xf
            ExitLoop
        EndIf
        Switch $icompression
            Case 0x0
            Case 0x1
                Local Const $tagencoderparameter = "byte[16] GUID;ulong NumberOfValues;dword Type;ptr pValue"
                $tparam = DllStructCreate("dword Count;" & $tagencoderparameter & ";ulong Quality")
                DllStructSetData($tparam, "Count", 0x1)
                DllStructSetData($tparam, "NumberOfValues", 0x1)
                DllStructSetData($tparam, "Type", 0x4)
                DllStructSetData($tparam, "pValue", DllStructGetPtr($tparam, "Quality"))
                DllStructSetData($tparam, "Quality", $iquality)
                $acall = DllCall("ole32.dll", "long", "CLSIDFromString", "wstr", "{1D5BE4B5-FA4A-452D-9CDD-5DB35105E7EB}", "ptr", DllStructGetPtr($tparam, 0x2))
                If @error Or $acall[0x0] Then
                    $tparam = 0x0
                EndIf
        EndSwitch
        $pstream = _WINAPI_CREATESTREAMONHGLOBAL()
        $acall = DllCall("gdiplus.dll", "int", "GdipSaveImageToStream", "handle", $himage, "ptr", $pstream, "ptr", $pencoder, "struct*", $tparam)
        If @error Or $acall[0x0] Then
            $ierror = @error + 0x384
            ExitLoop
        EndIf
        $hmem = _WINAPI_GETHGLOBALFROMSTREAM($pstream)
        $acall = DllCall("kernel32.dll", "ulong_ptr", "GlobalSize", "handle", $hmem)
        If @error Or Not $acall[0x0] Then
            $ierror = @error + 0x3e8
            ExitLoop
        EndIf
        $ilength = $acall[0x0]
        $acall = DllCall("kernel32.dll", "ptr", "GlobalLock", "handle", $hmem)
        If @error Or Not $acall[0x0] Then
            $ierror = @error + 0x44c
            ExitLoop
        EndIf
        $pbuffer = __HEAPREALLOC($pbuffer, $ilength, 0x1)
        If Not @error Then
            _WINAPI_MOVEMEMORY($pbuffer, $acall[0x0], $ilength)
        Else
            $ierror = @error + 0x514
        EndIf
    Until 0x1
    If $pstream Then
        _WINAPI_RELEASESTREAM($pstream)
    EndIf
    If $himage Then
        DllCall("gdiplus.dll", "int", "GdipDisposeImage", "handle", $himage)
    EndIf
    If $htoken Then
        DllCall("gdiplus.dll", "none", "GdiplusShutdown", "ulong_ptr", $htoken)
    EndIf
    If $hsource Then
        _WinAPI_DeleteObject($hsource)
    EndIf
    If $ierror Then Return SetError($ierror, 0x0, 0x0)
    Return $ilength
EndFunc   ;==>_WINAPI_COMPRESSBITMAPBITS
Func _WINAPI_COPYENHMETAFILE($hemf, $sfilepath = "")
    If Not StringStripWS($sfilepath, $str_stripleading + $str_striptrailing) Then $sfilepath = NULL
    Local $acall = DllCall("gdi32.dll", "handle", "CopyEnhMetaFileW", "handle", $hemf, "wstr", $sfilepath)
    If @error Then Return SetError(@error, @extended, 0x0)
    Return $acall[0x0]
EndFunc   ;==>_WINAPI_COPYENHMETAFILE
Func _WINAPI_COPYRECT($trect)
    Local $tdata = DllStructCreate($tagrect)
    Local $acall = DllCall("user32.dll", "bool", "CopyRect", "struct*", $tdata, "struct*", $trect)
    If @error Or Not $acall[0x0] Then SetError(@error + 0xa, @extended, 0x0)
    Return $tdata
EndFunc   ;==>_WINAPI_COPYRECT
Func _WINAPI_CREATE32BITHBITMAP($hicon, $bdib = False, $bdelete = False)
    Local $hbitmap = 0x0
    Local $adib[0x2] = [0x0, 0x0]
    Local $htemp = _WINAPI_CREATE32BITHICON($hicon)
    If @error Then Return SetError(@error, @extended, 0x0)
    Local $ierror = 0x0
    Do
        Local $ticoninfo = DllStructCreate($tagiconinfo)
        Local $acall = DllCall("user32.dll", "bool", "GetIconInfo", "handle", $htemp, "struct*", $ticoninfo)
        If @error Or Not $acall[0x0] Then
            $ierror = @error + 0xa
            ExitLoop
        EndIf
        For $i = 0x0 To 0x1
            $adib[$i] = DllStructGetData($ticoninfo, $i + 0x4)
        Next
        Local $tbitmap = DllStructCreate($tagbitmap)
        If Not _WinAPI_GetObject($adib[0x0], DllStructGetSize($tbitmap), $tbitmap) Then
            $ierror = @error + 0x14
            ExitLoop
        EndIf
        If $bdib Then
            $hbitmap = _WINAPI_CREATEDIB(DllStructGetData($tbitmap, "bmWidth"), DllStructGetData($tbitmap, "bmHeight"))
            Local $hdc = _WinAPI_CreateCompatibleDC(0x0)
            Local $hsv = _WinAPI_SelectObject($hdc, $hbitmap)
            _WinAPI_DrawIconEx($hdc, 0x0, 0x0, $htemp)
            _WinAPI_SelectObject($hdc, $hsv)
            _WinAPI_DeleteDC($hdc)
        Else
            $hbitmap = $adib[0x1]
            $adib[0x1] = 0x0
        EndIf
    Until 0x1
    For $i = 0x0 To 0x1
        If $adib[$i] Then
            _WinAPI_DeleteObject($adib[$i])
        EndIf
    Next
    _WinAPI_DestroyIcon($htemp)
    If $ierror Then Return SetError($ierror, 0x0, 0x0)
    If Not $hbitmap Then Return SetError(0xc, 0x0, 0x0)
    If $bdelete Then
        _WinAPI_DestroyIcon($hicon)
    EndIf
    Return $hbitmap
EndFunc   ;==>_WINAPI_CREATE32BITHBITMAP
Func _WINAPI_CREATEBITMAPINDIRECT(ByRef $tbitmap)
    Local $acall = DllCall("gdi32.dll", "handle", "CreateBitmapIndirect", "struct*", $tbitmap)
    If @error Then Return SetError(@error, @extended, 0x0)
    Return $acall[0x0]
EndFunc   ;==>_WINAPI_CREATEBITMAPINDIRECT
Func _WINAPI_CREATEBRUSHINDIRECT($istyle, $irgb, $ihatch = 0x0)
    Local $tlogbrush = DllStructCreate($taglogbrush)
    DllStructSetData($tlogbrush, 0x1, $istyle)
    DllStructSetData($tlogbrush, 0x2, __RGB($irgb))
    DllStructSetData($tlogbrush, 0x3, $ihatch)
    Local $acall = DllCall("gdi32.dll", "handle", "CreateBrushIndirect", "struct*", $tlogbrush)
    If @error Then Return SetError(@error, @extended, 0x0)
    Return $acall[0x0]
EndFunc   ;==>_WINAPI_CREATEBRUSHINDIRECT
Func _WINAPI_CREATECOLORADJUSTMENT($iflags = 0x0, $iilluminant = 0x0, $igammar = 0x2710, $igammag = 0x2710, $igammab = 0x2710, $iblack = 0x0, $iwhite = 0x2710, $icontrast = 0x0, $ibrightness = 0x0, $icolorfulness = 0x0, $itint = 0x0)
    Local $tca = DllStructCreate($tagcoloradjustment)
    DllStructSetData($tca, 0x1, DllStructGetSize($tca))
    DllStructSetData($tca, 0x2, $iflags)
    DllStructSetData($tca, 0x3, $iilluminant)
    DllStructSetData($tca, 0x4, $igammar)
    DllStructSetData($tca, 0x5, $igammag)
    DllStructSetData($tca, 0x6, $igammab)
    DllStructSetData($tca, 0x7, $iblack)
    DllStructSetData($tca, 0x8, $iwhite)
    DllStructSetData($tca, 0x9, $icontrast)
    DllStructSetData($tca, 0xa, $ibrightness)
    DllStructSetData($tca, 0xb, $icolorfulness)
    DllStructSetData($tca, 0xc, $itint)
    Return $tca
EndFunc   ;==>_WINAPI_CREATECOLORADJUSTMENT
Func _WINAPI_CREATECOMPATIBLEBITMAPEX($hdc, $iwidth, $iheight, $irgb)
    Local $hbrush = _WINAPI_CREATEBRUSHINDIRECT(0x0, $irgb)
    Local $acall = DllCall("gdi32.dll", "handle", "CreateCompatibleDC", "handle", $hdc)
    Local $hdestdc = $acall[0x0]
    $acall = DllCall("gdi32.dll", "handle", "CreateCompatibleBitmap", "handle", $hdc, "int", $iwidth, "int", $iheight)
    Local $hbmp = $acall[0x0]
    $acall = DllCall("gdi32.dll", "handle", "SelectObject", "handle", $hdestdc, "handle", $hbmp)
    Local $hdestsv = $acall[0x0]
    Local $trect = _WINAPI_CREATERECTEX(0x0, 0x0, $iwidth, $iheight)
    Local $ierror = 0x0
    $acall = DllCall("user32.dll", "int", "FillRect", "handle", $hdestdc, "struct*", $trect, "handle", $hbrush)
    If @error Or Not $acall[0x0] Then
        $ierror = @error + 0xa
        _WinAPI_DeleteObject($hbmp)
    EndIf
    _WinAPI_DeleteObject($hbrush)
    DllCall("gdi32.dll", "handle", "SelectObject", "handle", $hdestdc, "handle", $hdestsv)
    DllCall("gdi32.dll", "bool", "DeleteDC", "handle", $hdestdc)
    If $ierror Then Return SetError($ierror, 0x0, 0x0)
    Return $hbmp
EndFunc   ;==>_WINAPI_CREATECOMPATIBLEBITMAPEX
Func _WINAPI_CREATEDIBITMAP($hdc, ByRef $tbitmapinfo, $iusage, $pbits = 0x0)
    Local $iinit = 0x0
    If $pbits Then
        $iinit = 0x4
    EndIf
    Local $acall = DllCall("gdi32.dll", "handle", "CreateDIBitmap", "handle", $hdc, "struct*", $tbitmapinfo, "dword", $iinit, "struct*", $pbits, "struct*", $tbitmapinfo, "uint", $iusage)
    If @error Then Return SetError(@error, @extended, 0x0)
    Return $acall[0x0]
EndFunc   ;==>_WINAPI_CREATEDIBITMAP
Func _WINAPI_CREATEELLIPTICRGN($trect)
    Local $acall = DllCall("gdi32.dll", "handle", "CreateEllipticRgnIndirect", "struct*", $trect)
    If @error Then Return SetError(@error, @extended, False)
    Return $acall[0x0]
EndFunc   ;==>_WINAPI_CREATEELLIPTICRGN
Func _WINAPI_CREATEENHMETAFILE($hdc = 0x0, $trect = 0x0, $bpixels = False, $sfilepath = "", $sdescription = "")
    If Not StringStripWS($sfilepath, $str_stripleading + $str_striptrailing) Then $sfilepath = NULL
    Local $tdata = 0x0, $adata = StringSplit($sdescription, "|", $str_nocount)
    If UBound($adata) < 0x2 Then
        ReDim $adata[0x2]
        $adata[0x1] = ""
    EndIf
    For $i = 0x0 To 0x1
        $adata[$i] = StringStripWS($adata[$i], $str_stripleading + $str_striptrailing)
    Next
    If ($adata[0x0]) Or ($adata[0x1]) Then
        $tdata = _WINAPI_ARRAYTOSTRUCT($adata)
    EndIf
    Local $ixp, $iyp, $ixm, $iym, $href = 0x0
    If $bpixels And (IsDllStruct($trect)) Then
        If Not $hdc Then
            $href = _WinAPI_GetDC(0x0)
        EndIf
        $ixp = _WinAPI_GetDeviceCaps($href, 0x8)
        $iyp = _WinAPI_GetDeviceCaps($href, 0xa)
        $ixm = _WinAPI_GetDeviceCaps($href, 0x4)
        $iym = _WinAPI_GetDeviceCaps($href, 0x6)
        If $href Then
            _WinAPI_ReleaseDC(0x0, $href)
        EndIf
        For $i = 0x1 To 0x3 Step 0x2
            DllStructSetData($trect, $i, Round(DllStructGetData($trect, $i) * $ixm / $ixp * 0x64))
        Next
        For $i = 0x2 To 0x4 Step 0x2
            DllStructSetData($trect, $i, Round(DllStructGetData($trect, $i) * $iym / $iyp * 0x64))
        Next
    EndIf
    Local $acall = DllCall("gdi32.dll", "handle", "CreateEnhMetaFileW", "handle", $hdc, "wstr", $sfilepath, "struct*", $trect, "struct*", $tdata)
    If @error Then Return SetError(@error, @extended, 0x0)
    Return $acall[0x0]
EndFunc   ;==>_WINAPI_CREATEENHMETAFILE
Func _WINAPI_CREATEFONTEX($iheight, $iwidth = 0x0, $iescapement = 0x0, $iorientation = 0x0, $iweight = 0x190, $bitalic = False, $bunderline = False, $bstrikeout = False, $icharset = 0x1, $ioutprecision = 0x0, $iclipprecision = 0x0, $iquality = 0x0, $ipitchandfamily = 0x0, $sfacename = "", $istyle = 0x0)
    Local $acall = DllCall("gdi32.dll", "handle", "CreateFontW", "int", $iheight, "int", $iwidth, "int", $iescapement, "int", $iorientation, "int", $iweight, "dword", $bitalic, "dword", $bunderline, "dword", $bstrikeout, "dword", $icharset, "dword", $ioutprecision, "dword", $iclipprecision, "dword", $iquality, "dword", $ipitchandfamily, "wstr", _WINAPI_GETFONTNAME($sfacename, $istyle, $icharset))
    If @error Then Return SetError(@error, @extended, 0x0)
    Return $acall[0x0]
EndFunc   ;==>_WINAPI_CREATEFONTEX
Func _WINAPI_CREATENULLRGN()
    Local $acall = DllCall("gdi32.dll", "handle", "CreateRectRgn", "int", 0x0, "int", 0x0, "int", 0x0, "int", 0x0)
    If @error Then Return SetError(@error, @extended, 0x0)
    Return $acall[0x0]
EndFunc   ;==>_WINAPI_CREATENULLRGN
Func _WinAPI_CreatePen($ipenstyle, $iwidth, $icolor)
    Local $acall = DllCall("gdi32.dll", "handle", "CreatePen", "int", $ipenstyle, "int", $iwidth, "INT", $icolor)
    If @error Then Return SetError(@error, @extended, 0x0)
    Return $acall[0x0]
EndFunc   ;==>_WINAPI_CREATEPEN
Func _WINAPI_CREATEPOLYGONRGN(Const ByRef $apoint, $istart = 0x0, $iend = +0xffffffff, $imode = 0x1)
    If __CHECKERRORARRAYBOUNDS($apoint, $istart, $iend, 0x2, 0x2) Then Return SetError(@error + 0xa, @extended, 0x0)
    Local $tagstruct = ""
    For $i = $istart To $iend
        $tagstruct &= "int[2];"
    Next
    Local $tdata = DllStructCreate($tagstruct)
    Local $icount = 0x1
    For $i = $istart To $iend
        For $j = 0x0 To 0x1
            DllStructSetData($tdata, $icount, $apoint[$i][$j], $j + 0x1)
        Next
        $icount += 0x1
    Next
    Local $acall = DllCall("gdi32.dll", "handle", "CreatePolygonRgn", "struct*", $tdata, "int", $icount + 0xffffffff, "int", $imode)
    If @error Then Return SetError(@error, @extended, 0x0)
    Return $acall[0x0]
EndFunc   ;==>_WINAPI_CREATEPOLYGONRGN
Func _WINAPI_CREATERECTRGNINDIRECT($trect)
    Local $acall = DllCall("gdi32.dll", "handle", "CreateRectRgnIndirect", "struct*", $trect)
    If @error Then Return SetError(@error, @extended, 0x0)
    Return $acall[0x0]
EndFunc   ;==>_WINAPI_CREATERECTRGNINDIRECT
Func _WinAPI_CreateSolidBitmap($hwnd, $icolor, $iwidth, $iheight, $brgb = 0x1)
    Local $hdc = _WinAPI_GetDC($hwnd)
    Local $hdestdc = _WinAPI_CreateCompatibleDC($hdc)
    Local $hbitmap = _WinAPI_CreateCompatibleBitmap($hdc, $iwidth, $iheight)
    Local $hold = _WinAPI_SelectObject($hdestdc, $hbitmap)
    Local $trect = DllStructCreate($tagrect)
    DllStructSetData($trect, 0x1, 0x0)
    DllStructSetData($trect, 0x2, 0x0)
    DllStructSetData($trect, 0x3, $iwidth)
    DllStructSetData($trect, 0x4, $iheight)
    If $brgb Then
        $icolor = BitOR(BitAND($icolor, 0xff00), BitShift(BitAND($icolor, 0xff), +0xfffffff0), BitShift(BitAND($icolor, 0xff0000), 0x10))
    EndIf
    Local $hbrush = _WinAPI_CreateSolidBrush($icolor)
    If Not _WinAPI_FillRect($hdestdc, $trect, $hbrush) Then
        _WinAPI_DeleteObject($hbitmap)
        $hbitmap = 0x0
    EndIf
    _WinAPI_DeleteObject($hbrush)
    _WinAPI_ReleaseDC($hwnd, $hdc)
    _WinAPI_SelectObject($hdestdc, $hold)
    _WinAPI_DeleteDC($hdestdc)
    If Not $hbitmap Then Return SetError(0x1, 0x0, 0x0)
    Return $hbitmap
EndFunc   ;==>_WINAPI_CREATESOLIDBITMAP
Func _WINAPI_CREATETRANSFORM($nm11 = 0x1, $nm12 = 0x0, $nm21 = 0x0, $nm22 = 0x1, $ndx = 0x0, $ndy = 0x0)
    Local $txform = DllStructCreate($tagxform)
    DllStructSetData($txform, 0x1, $nm11)
    DllStructSetData($txform, 0x2, $nm12)
    DllStructSetData($txform, 0x3, $nm21)
    DllStructSetData($txform, 0x4, $nm22)
    DllStructSetData($txform, 0x5, $ndx)
    DllStructSetData($txform, 0x6, $ndy)
    Return $txform
EndFunc   ;==>_WINAPI_CREATETRANSFORM
Func _WINAPI_DELETEENHMETAFILE($hemf)
    Local $acall = DllCall("gdi32.dll", "bool", "DeleteEnhMetaFile", "handle", $hemf)
    If @error Then Return SetError(@error, @extended, False)
    Return $acall[0x0]
EndFunc   ;==>_WINAPI_DELETEENHMETAFILE
Func _WINAPI_DPTOLP($hdc, ByRef $tpoint, $icount = 0x1)
    Local $acall = DllCall("gdi32.dll", "bool", "DPtoLP", "handle", $hdc, "struct*", $tpoint, "int", $icount)
    If @error Then Return SetError(@error, @extended, False)
    Return $acall[0x0]
EndFunc   ;==>_WINAPI_DPTOLP
Func _WINAPI_DRAWANIMATEDRECTS($hwnd, $trectfrom, $trectto)
    Local $acall = DllCall("user32.dll", "bool", "DrawAnimatedRects", "hwnd", $hwnd, "int", 0x3, "struct*", $trectfrom, "struct*", $trectto)
    If @error Then Return SetError(@error, @extended, 0x0)
    Return $acall[0x0]
EndFunc   ;==>_WINAPI_DRAWANIMATEDRECTS
Func _WINAPI_DRAWBITMAP($hdc, $ix, $iy, $hbitmap, $irop = 0xcc0020)
    Local $tobj = DllStructCreate($tagbitmap)
    Local $acall = DllCall("gdi32.dll", "int", "GetObject", "handle", $hbitmap, "int", DllStructGetSize($tobj), "struct*", $tobj)
    If @error Or Not $acall[0x0] Then Return SetError(@error + 0x14, @extended, 0x0)
    $acall = DllCall("user32.dll", "handle", "GetDC", "hwnd", 0x0)
    Local $_hdc = $acall[0x0]
    $acall = DllCall("gdi32.dll", "handle", "CreateCompatibleDC", "handle", $_hdc)
    Local $hsrcdc = $acall[0x0]
    $acall = DllCall("gdi32.dll", "handle", "SelectObject", "handle", $hsrcdc, "handle", $hbitmap)
    Local $hsrcsv = $acall[0x0]
    Local $ierror = 0x0
    $acall = DllCall("gdi32.dll", "int", "BitBlt", "hwnd", $hdc, "int", $ix, "int", $iy, "int", DllStructGetData($tobj, "bmWidth"), "int", DllStructGetData($tobj, "bmHeight"), "hwnd", $hsrcdc, "int", 0x0, "int", 0x0, "int", $irop)
    If @error Or Not $acall[0x0] Then
        $ierror = @error + 0x1
    EndIf
    DllCall("user32.dll", "int", "ReleaseDC", "hwnd", 0x0, "handle", $_hdc)
    DllCall("gdi32.dll", "handle", "SelectObject", "handle", $hsrcdc, "handle", $hsrcsv)
    DllCall("gdi32.dll", "bool", "DeleteDC", "handle", $hsrcdc)
    If $ierror Then Return SetError(0xa, 0x0, 0x0)
    Return 0x1
EndFunc   ;==>_WINAPI_DRAWBITMAP
Func _WINAPI_DRAWFOCUSRECT($hdc, $trect)
    Local $acall = DllCall("user32.dll", "bool", "DrawFocusRect", "handle", $hdc, "struct*", $trect)
    If @error Then Return SetError(@error, @extended, 0x0)
    Return $acall[0x0]
EndFunc   ;==>_WINAPI_DRAWFOCUSRECT
Func _WinAPI_DrawLine($hdc, $ix1, $iy1, $ix2, $iy2)
    _WinAPI_MoveTo($hdc, $ix1, $iy1)
    If @error Then Return SetError(@error, @extended, False)
    _WinAPI_LineTo($hdc, $ix2, $iy2)
    If @error Then Return SetError(@error + 0xa, @extended, False)
    Return True
EndFunc   ;==>_WINAPI_DRAWLINE
Func _WINAPI_DRAWSHADOWTEXT($hdc, $stext, $irgbtext, $irgbshadow, $ixoffset = 0x0, $iyoffset = 0x0, $trect = 0x0, $iflags = 0x0)
    Local $acall
    If Not IsDllStruct($trect) Then
        $trect = DllStructCreate($tagrect)
        $acall = DllCall("user32.dll", "bool", "GetClientRect", "hwnd", _WINAPI_WINDOWFROMDC($hdc), "struct*", $trect)
        If @error Then Return SetError(@error + 0xa, @extended, 0x0)
        If Not $acall[0x0] Then Return SetError(0xa, 0x0, 0x0)
    EndIf
    $acall = DllCall("comctl32.dll", "int", "DrawShadowText", "handle", $hdc, "wstr", $stext, "uint", +0xffffffff, "struct*", $trect, "dword", $iflags, "int", __RGB($irgbtext), "int", __RGB($irgbshadow), "int", $ixoffset, "int", $iyoffset)
    If @error Then Return SetError(@error, @extended, 0x0)
    Return $acall[0x0]
EndFunc   ;==>_WINAPI_DRAWSHADOWTEXT
Func _WINAPI_DWMDEFWINDOWPROC($hwnd, $imsg, $wparam, $lparam)
    Local $acall = DllCall("dwmapi.dll", "bool", "DwmDefWindowProc", "hwnd", $hwnd, "uint", $imsg, "wparam", $wparam, "lparam", $lparam, "lresult*", 0x0)
    If @error Or Not $acall[0x0] Then Return SetError(@error + 0xa, @extended, 0x0)
    Return $acall[0x5]
EndFunc   ;==>_WINAPI_DWMDEFWINDOWPROC
Func _WINAPI_DWMENABLEBLURBEHINDWINDOW($hwnd, $benable = True, $btransition = False, $hrgn = 0x0)
    Local $tblurbehind = DllStructCreate("dword;bool;handle;bool")
    Local $iflags = 0x0
    If $hrgn Then
        $iflags += 0x2
        DllStructSetData($tblurbehind, 0x3, $hrgn)
    EndIf
    DllStructSetData($tblurbehind, 0x1, BitOR($iflags, 0x5))
    DllStructSetData($tblurbehind, 0x2, $benable)
    DllStructSetData($tblurbehind, 0x4, $btransition)
    Local $acall = DllCall("dwmapi.dll", "long", "DwmEnableBlurBehindWindow", "hwnd", $hwnd, "struct*", $tblurbehind)
    If @error Then Return SetError(@error, @extended, 0x0)
    If $acall[0x0] Then Return SetError(0xa, $acall[0x0], 0x0)
    Return 0x1
EndFunc   ;==>_WINAPI_DWMENABLEBLURBEHINDWINDOW
Func _WINAPI_DWMENABLECOMPOSITION($benable)
    If $benable Then $benable = 0x1
    Local $acall = DllCall("dwmapi.dll", "long", "DwmEnableComposition", "uint", $benable)
    If @error Then Return SetError(@error, @extended, 0x0)
    If $acall[0x0] Then Return SetError(0xa, $acall[0x0], 0x0)
    Return 0x1
EndFunc   ;==>_WINAPI_DWMENABLECOMPOSITION
Func _WINAPI_DWMEXTENDFRAMEINTOCLIENTAREA($hwnd, $tmargins = 0x0)
    If Not IsDllStruct($tmargins) Then
        $tmargins = _WINAPI_CREATEMARGINS(+0xffffffff, +0xffffffff, +0xffffffff, +0xffffffff)
    EndIf
    Local $acall = DllCall("dwmapi.dll", "long", "DwmExtendFrameIntoClientArea", "hwnd", $hwnd, "struct*", $tmargins)
    If @error Then Return SetError(@error, @extended, 0x0)
    If $acall[0x0] Then Return SetError(0xa, $acall[0x0], 0x0)
    Return 0x1
EndFunc   ;==>_WINAPI_DWMEXTENDFRAMEINTOCLIENTAREA
Func _WINAPI_DWMGETCOLORIZATIONCOLOR()
    Local $acall = DllCall("dwmapi.dll", "long", "DwmGetColorizationColor", "dword*", 0x0, "bool*", 0x0)
    If @error Then Return SetError(@error, @extended, 0x0)
    If $acall[0x0] Then Return SetError(0xa, $acall[0x0], 0x0)
    Return SetExtended($acall[0x2], $acall[0x1])
EndFunc   ;==>_WINAPI_DWMGETCOLORIZATIONCOLOR
Func _WINAPI_DWMGETCOLORIZATIONPARAMETERS()
    Local $tdwmcp = DllStructCreate($tagdwm_colorization_parameters)
    Local $acall = DllCall("dwmapi.dll", "uint", 0x7f, "struct*", $tdwmcp)
    If @error Then Return SetError(@error, @extended, 0x0)
    If $acall[0x0] Then Return SetError(0xa, $acall[0x0], 0x0)
    Return $tdwmcp
EndFunc   ;==>_WINAPI_DWMGETCOLORIZATIONPARAMETERS
Func _WINAPI_DWMGETWINDOWATTRIBUTE($hwnd, $iattribute)
    Local $tagstruct
    Switch $iattribute
        Case 0x5, 0x9
            $tagstruct = $tagrect
        Case 0x1
            $tagstruct = "uint"
        Case Else
            Return SetError(0xb, 0x0, 0x0)
    EndSwitch
    Local $tdata = DllStructCreate($tagstruct)
    Local $acall = DllCall("dwmapi.dll", "long", "DwmGetWindowAttribute", "hwnd", $hwnd, "dword", $iattribute, "struct*", $tdata, "dword", DllStructGetSize($tdata))
    If @error Then Return SetError(@error, @extended, 0x0)
    If $acall[0x0] Then Return SetError(0xa, $acall[0x0], 0x0)
    Switch $iattribute
        Case 0x1
            Return DllStructGetData($tdata, 0x1)
        Case Else
            Return $tdata
    EndSwitch
EndFunc   ;==>_WINAPI_DWMGETWINDOWATTRIBUTE
Func _WINAPI_DWMINVALIDATEICONICBITMAPS($hwnd)
    Local $acall = DllCall("dwmapi.dll", "long", "DwmInvalidateIconicBitmaps", "hwnd", $hwnd)
    If @error Then Return SetError(@error, @extended, 0x0)
    If $acall[0x0] Then Return SetError(0xa, $acall[0x0], 0x0)
    Return 0x1
EndFunc   ;==>_WINAPI_DWMINVALIDATEICONICBITMAPS
Func _WINAPI_DWMISCOMPOSITIONENABLED()
    Local $acall = DllCall("dwmapi.dll", "long", "DwmIsCompositionEnabled", "bool*", 0x0)
    If @error Then Return SetError(@error, @extended, 0x0)
    If $acall[0x0] Then Return SetError(0xa, $acall[0x0], 0x0)
    Return $acall[0x1]
EndFunc   ;==>_WINAPI_DWMISCOMPOSITIONENABLED
Func _WINAPI_DWMQUERYTHUMBNAILSOURCESIZE($hthumbnail)
    Local $tsize = DllStructCreate($tagsize)
    Local $acall = DllCall("dwmapi.dll", "long", "DwmQueryThumbnailSourceSize", "handle", $hthumbnail, "struct*", $tsize)
    If @error Then Return SetError(@error, @extended, 0x0)
    If $acall[0x0] Then Return SetError(0xa, $acall[0x0], 0x0)
    Return $tsize
EndFunc   ;==>_WINAPI_DWMQUERYTHUMBNAILSOURCESIZE
Func _WINAPI_DWMREGISTERTHUMBNAIL($hdestination, $hsource)
    Local $acall = DllCall("dwmapi.dll", "long", "DwmRegisterThumbnail", "hwnd", $hdestination, "hwnd", $hsource, "handle*", 0x0)
    If @error Then Return SetError(@error, @extended, 0x0)
    If $acall[0x0] Then Return SetError(0xa, $acall[0x0], 0x0)
    Return $acall[0x3]
EndFunc   ;==>_WINAPI_DWMREGISTERTHUMBNAIL
Func _WINAPI_DWMSETCOLORIZATIONPARAMETERS($tdwmcp)
    Local $acall = DllCall("dwmapi.dll", "uint", 0x83, "struct*", $tdwmcp, "uint", 0x0)
    If @error Then Return SetError(@error, @extended, 0x0)
    If $acall[0x0] Then Return SetError(0xa, $acall[0x0], 0x0)
    Return 0x1
EndFunc   ;==>_WINAPI_DWMSETCOLORIZATIONPARAMETERS
Func _WINAPI_DWMSETICONICLIVEPREVIEWBITMAP($hwnd, $hbitmap, $bframe = False, $tclient = 0x0)
    Local $iflags
    If $bframe Then
        $iflags = 0x1
    Else
        $iflags = 0x0
    EndIf
    Local $acall = DllCall("dwmapi.dll", "uint", "DwmSetIconicLivePreviewBitmap", "hwnd", $hwnd, "handle", $hbitmap, "struct*", $tclient, "dword", $iflags)
    If @error Then Return SetError(@error, @extended, 0x0)
    If $acall[0x0] Then Return SetError(0xa, $acall[0x0], 0x0)
    Return 0x1
EndFunc   ;==>_WINAPI_DWMSETICONICLIVEPREVIEWBITMAP
Func _WINAPI_DWMSETICONICTHUMBNAIL($hwnd, $hbitmap, $bframe = False)
    Local $iflags
    If $bframe Then
        $iflags = 0x1
    Else
        $iflags = 0x0
    EndIf
    Local $acall = DllCall("dwmapi.dll", "long", "DwmSetIconicThumbnail", "hwnd", $hwnd, "handle", $hbitmap, "dword", $iflags)
    If @error Then Return SetError(@error, @extended, 0x0)
    If $acall[0x0] Then Return SetError(0xa, $acall[0x0], 0x0)
    Return 0x1
EndFunc   ;==>_WINAPI_DWMSETICONICTHUMBNAIL
Func _WINAPI_DWMSETWINDOWATTRIBUTE($hwnd, $iattribute, $idata)
    Switch $iattribute
        Case 0x2, 0x3, 0x4, 0x6, 0x7, 0x8, 0xa, 0xb, 0xc
        Case Else
            Return SetError(0x1, 0x0, 0x0)
    EndSwitch
    Local $acall = DllCall("dwmapi.dll", "long", "DwmSetWindowAttribute", "hwnd", $hwnd, "dword", $iattribute, "dword*", $idata, "dword", 0x4)
    If @error Then Return SetError(@error, @extended, 0x0)
    If $acall[0x0] Then Return SetError(0xa, $acall[0x0], 0x0)
    Return 0x1
EndFunc   ;==>_WINAPI_DWMSETWINDOWATTRIBUTE
Func _WINAPI_DWMUNREGISTERTHUMBNAIL($hthumbnail)
    Local $acall = DllCall("dwmapi.dll", "long", "DwmUnregisterThumbnail", "handle", $hthumbnail)
    If @error Then Return SetError(@error, @extended, 0x0)
    If $acall[0x0] Then Return SetError(0xa, $acall[0x0], 0x0)
    Return 0x1
EndFunc   ;==>_WINAPI_DWMUNREGISTERTHUMBNAIL
Func _WINAPI_DWMUPDATETHUMBNAILPROPERTIES($hthumbnail, $bvisible = True, $bclientareaonly = False, $iopacity = 0xff, $trectdest = 0x0, $trectsrc = 0x0)
    Local Const $tagdwm_thumbnail_properties = "struct;dword dwFlags;int rcDestination[4];int rcSource[4];byte opacity;bool opacity;bool fSourceClientAreaOnly;endstruct"
    Local $tthumbnailproperties = DllStructCreate($tagdwm_thumbnail_properties)
    Local $tsize, $iflags = 0x0
    If Not IsDllStruct($trectdest) Then
        $tsize = _WINAPI_DWMQUERYTHUMBNAILSOURCESIZE($hthumbnail)
        If @error Then
            Return SetError(@error + 0xa, @extended, 0x0)
        EndIf
        $trectdest = _WINAPI_CREATERECTEX(0x0, 0x0, DllStructGetData($tsize, 0x1), DllStructGetData($tsize, 0x2))
    EndIf
    For $i = 0x1 To 0x4
        DllStructSetData($tthumbnailproperties, 0x2, DllStructGetData($trectdest, $i), $i)
    Next
    If IsDllStruct($trectsrc) Then
        $iflags += 0x2
        For $i = 0x1 To 0x4
            DllStructSetData($tthumbnailproperties, 0x3, DllStructGetData($trectsrc, $i), $i)
        Next
    EndIf
    DllStructSetData($tthumbnailproperties, 0x1, BitOR($iflags, 0x1d))
    DllStructSetData($tthumbnailproperties, 0x4, $iopacity)
    DllStructSetData($tthumbnailproperties, 0x5, $bvisible)
    DllStructSetData($tthumbnailproperties, 0x6, $bclientareaonly)
    Local $acall = DllCall("dwmapi.dll", "long", "DwmUpdateThumbnailProperties", "handle", $hthumbnail, "struct*", $tthumbnailproperties)
    If @error Then Return SetError(@error, @extended, 0x0)
    If $acall[0x0] Then Return SetError(0xa, $acall[0x0], 0x0)
    Return 0x1
EndFunc   ;==>_WINAPI_DWMUPDATETHUMBNAILPROPERTIES
Func _WINAPI_ELLIPSE($hdc, $trect)
    Local $acall = DllCall("gdi32.dll", "bool", "Ellipse", "handle", $hdc, "int", DllStructGetData($trect, 0x1), "int", DllStructGetData($trect, 0x2), "int", DllStructGetData($trect, 0x3), "int", DllStructGetData($trect, 0x4))
    If @error Then Return SetError(@error, @extended, False)
    Return $acall[0x0]
EndFunc   ;==>_WINAPI_ELLIPSE
Func _WINAPI_ENDPAINT($hwnd, ByRef $tpaintstruct)
    Local $acall = DllCall("user32.dll", "bool", "EndPaint", "hwnd", $hwnd, "struct*", $tpaintstruct)
    If @error Then Return SetError(@error, @extended, False)
    Return $acall[0x0]
EndFunc   ;==>_WINAPI_ENDPAINT
Func _WINAPI_ENDPATH($hdc)
    Local $acall = DllCall("gdi32.dll", "bool", "EndPath", "handle", $hdc)
    If @error Then Return SetError(@error, @extended, 0x0)
    Return $acall[0x0]
EndFunc   ;==>_WINAPI_ENDPATH
Func _WINAPI_ENUMDISPLAYMONITORS($hdc = 0x0, $trect = 0x0)
    Local $henumproc = DllCallbackRegister("__EnumDisplayMonitorsProc", "bool", "handle;handle;ptr;lparam")
    Dim $__g_venum[0x65][0x2] = [[0x0]]
    Local $acall = DllCall("user32.dll", "bool", "EnumDisplayMonitors", "handle", $hdc, "struct*", $trect, "ptr", DllCallbackGetPtr($henumproc), "lparam", 0x0)
    If @error Or Not $acall[0x0] Or Not $__g_venum[0x0][0x0] Then
        $__g_venum = @error + 0xa
    EndIf
    DllCallbackFree($henumproc)
    If $__g_venum Then Return SetError($__g_venum, 0x0, 0x0)
    __INC($__g_venum, +0xffffffff)
    Return $__g_venum
EndFunc   ;==>_WINAPI_ENUMDISPLAYMONITORS
Func _WINAPI_ENUMDISPLAYSETTINGS($sdevice, $imode)
    If Not StringStripWS($sdevice, $str_stripleading + $str_striptrailing) Then $sdevice = NULL
    Local $tdevmode = DllStructCreate($tagdevmode_display)
    DllStructSetData($tdevmode, "Size", DllStructGetSize($tdevmode))
    DllStructSetData($tdevmode, "DriverExtra", 0x0)
    Local $acall = DllCall("user32.dll", "bool", "EnumDisplaySettingsW", "wstr", $sdevice, "dword", $imode, "struct*", $tdevmode)
    If @error Or Not $acall[0x0] Then Return SetError(@error + 0xa, @extended, 0x0)
    Local $aret[0x5]
    $aret[0x0] = DllStructGetData($tdevmode, "PelsWidth")
    $aret[0x1] = DllStructGetData($tdevmode, "PelsHeight")
    $aret[0x2] = DllStructGetData($tdevmode, "BitsPerPel")
    $aret[0x3] = DllStructGetData($tdevmode, "DisplayFrequency")
    $aret[0x4] = DllStructGetData($tdevmode, "DisplayFlags")
    Return $aret
EndFunc   ;==>_WINAPI_ENUMDISPLAYSETTINGS
Func _WINAPI_ENUMFONTFAMILIES($hdc = 0x0, $sfacename = "", $icharset = 0x1, $ifonttype = 0x7, $spattern = "", $bexclude = False)
    Local $tlogfont = DllStructCreate($taglogfont)
    Local $tpattern = DllStructCreate("uint;uint;ptr;wchar[" & (StringLen($spattern) + 0x1) & "]")
    DllStructSetData($tpattern, 0x1, $ifonttype)
    If Not $spattern Then
        DllStructSetData($tpattern, 0x2, 0x0)
        DllStructSetData($tpattern, 0x3, 0x0)
    Else
        DllStructSetData($tpattern, 0x2, $bexclude)
        DllStructSetData($tpattern, 0x3, DllStructGetPtr($tpattern, 0x4))
        DllStructSetData($tpattern, 0x4, $spattern)
    EndIf
    DllStructSetData($tlogfont, 0x9, $icharset)
    DllStructSetData($tlogfont, 0xd, 0x0)
    DllStructSetData($tlogfont, 0xe, StringLeft($sfacename, 0x1f))
    Local $hcdc
    If Not $hdc Then
        $hcdc = _WinAPI_CreateCompatibleDC(0x0)
    Else
        $hcdc = $hdc
    EndIf
    Dim $__g_venum[0x65][0x8] = [[0x0]]
    Local $henumproc = DllCallbackRegister("__EnumFontFamiliesProc", "int", "ptr;ptr;dword;PTR")
    Local $acall = DllCall("gdi32.dll", "int", "EnumFontFamiliesExW", "handle", $hcdc, "struct*", $tlogfont, "ptr", DllCallbackGetPtr($henumproc), "struct*", $tpattern, "dword", 0x0)
    If @error Or Not $acall[0x0] Or Not $__g_venum[0x0][0x0] Then
        $__g_venum = @error + 0xa
    EndIf
    DllCallbackFree($henumproc)
    If Not $hdc Then
        _WinAPI_DeleteDC($hcdc)
    EndIf
    If $__g_venum Then Return SetError($__g_venum, 0x0, 0x0)
    __INC($__g_venum, +0xffffffff)
    Return $__g_venum
EndFunc   ;==>_WINAPI_ENUMFONTFAMILIES
Func _WINAPI_EQUALRECT($trect1, $trect2)
    Local $acall = DllCall("user32.dll", "bool", "EqualRect", "struct*", $trect1, "struct*", $trect2)
    If @error Then Return SetError(@error, @extended, False)
    Return $acall[0x0]
EndFunc   ;==>_WINAPI_EQUALRECT
Func _WINAPI_EQUALRGN($hrgn1, $hrgn2)
    Local $acall = DllCall("gdi32.dll", "bool", "EqualRgn", "handle", $hrgn1, "handle", $hrgn2)
    If @error Then Return SetError(@error, @extended, False)
    Return $acall[0x0]
EndFunc   ;==>_WINAPI_EQUALRGN
Func _WINAPI_EXCLUDECLIPRECT($hdc, $trect)
    Local $acall = DllCall("gdi32.dll", "int", "ExcludeClipRect", "handle", $hdc, "int", DllStructGetData($trect, 0x1), "int", DllStructGetData($trect, 0x2), "int", DllStructGetData($trect, 0x3), "int", DllStructGetData($trect, 0x4))
    If @error Then Return SetError(@error, @extended, 0x0)
    Return $acall[0x0]
EndFunc   ;==>_WINAPI_EXCLUDECLIPRECT
Func _WINAPI_EXTCREATEPEN($ipenstyle, $iwidth, $ibrushstyle, $irgb, $ihatch = 0x0, $auserstyle = 0x0, $istart = 0x0, $iend = +0xffffffff)
    Local $icount = 0x0, $tstyle = 0x0
    If BitAND($ipenstyle, 0xff) = 0x7 Then
        If __CHECKERRORARRAYBOUNDS($auserstyle, $istart, $iend) Then Return SetError(@error + 0xa, @extended, 0x0)
        $tstyle = DllStructCreate("dword[" & ($iend - $istart + 0x1) & "]")
        For $i = $istart To $iend
            DllStructSetData($tstyle, 0x1, $auserstyle[$i], $icount + 0x1)
            $icount += 0x1
        Next
    EndIf
    Local $tlogbrush = DllStructCreate($taglogbrush)
    DllStructSetData($tlogbrush, 0x1, $ibrushstyle)
    DllStructSetData($tlogbrush, 0x2, __RGB($irgb))
    DllStructSetData($tlogbrush, 0x3, $ihatch)
    Local $acall = DllCall("gdi32.dll", "handle", "ExtCreatePen", "dword", $ipenstyle, "dword", $iwidth, "struct*", $tlogbrush, "dword", $icount, "struct*", $tstyle)
    If @error Then Return SetError(@error, @extended, 0x0)
    Return $acall[0x0]
EndFunc   ;==>_WINAPI_EXTCREATEPEN
Func _WINAPI_EXTCREATEREGION($trgndata, $txform = 0x0)
    Local $acall = DllCall("gdi32.dll", "handle", "ExtCreateRegion", "struct*", $txform, "dword", DllStructGetSize($trgndata), "struct*", $trgndata)
    If @error Then Return SetError(@error, @extended, 0x0)
    Return $acall[0x0]
EndFunc   ;==>_WINAPI_EXTCREATEREGION
Func _WINAPI_EXTFLOODFILL($hdc, $ix, $iy, $irgb, $itype = 0x0)
    Local $acall = DllCall("gdi32.dll", "bool", "ExtFloodFill", "handle", $hdc, "int", $ix, "int", $iy, "dword", __RGB($irgb), "uint", $itype)
    If @error Then Return SetError(@error, @extended, False)
    Return $acall[0x0]
EndFunc   ;==>_WINAPI_EXTFLOODFILL
Func _WINAPI_EXTSELECTCLIPRGN($hdc, $hrgn, $imode = 0x5)
    Local $acall = DllCall("gdi32.dll", "int", "ExtSelectClipRgn", "handle", $hdc, "handle", $hrgn, "int", $imode)
    If @error Then Return SetError(@error, @extended, 0x0)
    Return $acall[0x0]
EndFunc   ;==>_WINAPI_EXTSELECTCLIPRGN
Func _WINAPI_FILLPATH($hdc)
    Local $acall = DllCall("gdi32.dll", "bool", "FillPath", "handle", $hdc)
    If @error Then Return SetError(@error, @extended, False)
    Return $acall[0x0]
EndFunc   ;==>_WINAPI_FILLPATH
Func _WINAPI_FILLRGN($hdc, $hrgn, $hbrush)
    Local $acall = DllCall("gdi32.dll", "bool", "FillRgn", "handle", $hdc, "handle", $hrgn, "handle", $hbrush)
    If @error Then Return SetError(@error, @extended, False)
    Return $acall[0x0]
EndFunc   ;==>_WINAPI_FILLRGN
Func _WINAPI_FLATTENPATH($hdc)
    Local $acall = DllCall("gdi32.dll", "bool", "FlattenPath", "handle", $hdc)
    If @error Then Return SetError(@error, @extended, False)
    Return $acall[0x0]
EndFunc   ;==>_WINAPI_FLATTENPATH
Func _WINAPI_FRAMERGN($hdc, $hrgn, $hbrush, $iwidth, $iheight)
    Local $acall = DllCall("gdi32.dll", "bool", "FrameRgn", "handle", $hdc, "handle", $hrgn, "handle", $hbrush, "int", $iwidth, "int", $iheight)
    If @error Then Return SetError(@error, @extended, False)
    Return $acall[0x0]
EndFunc   ;==>_WINAPI_FRAMERGN
Func _WINAPI_GDICOMMENT($hdc, $pbuffer, $isize)
    Local $acall = DllCall("gdi32.dll", "bool", "GdiComment", "handle", $hdc, "uint", $isize, "struct*", $pbuffer)
    If @error Then Return SetError(@error, @extended, False)
    Return $acall[0x0]
EndFunc   ;==>_WINAPI_GDICOMMENT
Func _WINAPI_GETARCDIRECTION($hdc)
    Local $acall = DllCall("gdi32.dll", "int", "GetArcDirection", "handle", $hdc)
    If @error Then Return SetError(@error, @extended, 0x0)
    If ($acall[0x0] < 0x1) Or ($acall[0x0] > 0x2) Then Return SetError(0xa, $acall[0x0], 0x0)
    Return $acall[0x0]
EndFunc   ;==>_WINAPI_GETARCDIRECTION
Func _WINAPI_GETBITMAPBITS($hbitmap, $isize, $pbits)
    Local $acall = DllCall("gdi32.dll", "long", "GetBitmapBits", "handle", $hbitmap, "long", $isize, "struct*", $pbits)
    If @error Then Return SetError(@error, @extended, 0x0)
    Return $acall[0x0]
EndFunc   ;==>_WINAPI_GETBITMAPBITS
Func _WINAPI_GETBITMAPDIMENSIONEX($hbitmap)
    Local $tsize = DllStructCreate($tagsize)
    Local $acall = DllCall("gdi32.dll", "bool", "GetBitmapDimensionEx", "handle", $hbitmap, "struct*", $tsize)
    If @error Or Not $acall[0x0] Then Return SetError(@error + 0xa, @extended, 0x0)
    Return $tsize
EndFunc   ;==>_WINAPI_GETBITMAPDIMENSIONEX
Func _WINAPI_GETBKCOLOR($hdc)
    Local $acall = DllCall("gdi32.dll", "dword", "GetBkColor", "handle", $hdc)
    If @error Or ($acall[0x0] = +0xffffffff) Then Return SetError(@error, @extended, +0xffffffff)
    Return __RGB($acall[0x0])
EndFunc   ;==>_WINAPI_GETBKCOLOR
Func _WINAPI_GETBOUNDSRECT($hdc, $iflags = 0x0)
    Local $trect = DllStructCreate($tagrect)
    Local $acall = DllCall("gdi32.dll", "uint", "GetBoundsRect", "handle", $hdc, "struct*", $trect, "uint", $iflags)
    If @error Or Not $acall[0x0] Then Return SetError(@error + 0xa, @extended, 0x0)
    Return SetExtended($acall[0x0], $trect)
EndFunc   ;==>_WINAPI_GETBOUNDSRECT
Func _WINAPI_GETBRUSHORG($hdc)
    Local $tpoint = DllStructCreate($tagpoint)
    Local $acall = DllCall("gdi32.dll", "bool", "GetBrushOrgEx", "handle", $hdc, "struct*", $tpoint)
    If @error Or Not $acall[0x0] Then Return SetError(@error + 0xa, @extended, 0x0)
    Return $tpoint
EndFunc   ;==>_WINAPI_GETBRUSHORG
Func _WINAPI_GETBVALUE($irgb)
    Return BitShift(BitAND(__RGB($irgb), 0xff0000), 0x10)
EndFunc   ;==>_WINAPI_GETBVALUE
Func _WINAPI_GETCLIPBOX($hdc, ByRef $trect)
    $trect = DllStructCreate($tagrect)
    Local $acall = DllCall("gdi32.dll", "int", "GetClipBox", "handle", $hdc, "struct*", $trect)
    If @error Or Not $acall[0x0] Then
        $trect = 0x0
        Return SetError(@error, @extended, 0x0)
    EndIf
    Return $acall[0x0]
EndFunc   ;==>_WINAPI_GETCLIPBOX
Func _WINAPI_GETCLIPRGN($hdc)
    Local $hrgn = _WinAPI_CreateRectRgn(0x0, 0x0, 0x0, 0x0)
    Local $ierror = 0x0
    Local $acall = DllCall("gdi32.dll", "int", "GetClipRgn", "handle", $hdc, "handle", $hrgn)
    If @error Or ($acall[0x0] = +0xffffffff) Then $ierror = @error + 0xa
    If $ierror Or Not $acall[0x0] Then
        _WinAPI_DeleteObject($hrgn)
        $hrgn = 0x0
    EndIf
    Return SetError($ierror, 0x0, $hrgn)
EndFunc   ;==>_WINAPI_GETCLIPRGN
Func _WINAPI_GETCOLORADJUSTMENT($hdc)
    Local $tadjustment = DllStructCreate($tagcoloradjustment)
    Local $acall = DllCall("gdi32.dll", "bool", "GetColorAdjustment", "handle", $hdc, "struct*", $tadjustment)
    If @error Or Not $acall[0x0] Then Return SetError(@error + 0xa, @extended, 0x0)
    Return $tadjustment
EndFunc   ;==>_WINAPI_GETCOLORADJUSTMENT
Func _WINAPI_GETCURRENTPOSITION($hdc)
    Local $tpoint = DllStructCreate($tagpoint)
    Local $acall = DllCall("gdi32.dll", "int", "GetCurrentPositionEx", "handle", $hdc, "struct*", $tpoint)
    If @error Or Not $acall[0x0] Then Return SetError(@error + 0xa, @extended, 0x0)
    Return $tpoint
EndFunc   ;==>_WINAPI_GETCURRENTPOSITION
Func _WINAPI_GETDEVICEGAMMARAMP($hdc, ByRef $aramp)
    $aramp = 0x0
    Local $tdata = DllStructCreate("word[256];word[256];word[256]")
    Local $acall = DllCall("gdi32.dll", "bool", "GetDeviceGammaRamp", "handle", $hdc, "struct*", $tdata)
    If @error Or Not $acall[0x0] Then Return SetError(@error, @extended, 0x0)
    Dim $aramp[0x100][0x3]
    For $i = 0x0 To 0x2
        For $j = 0x0 To 0xff
            $aramp[$j][$i] = DllStructGetData($tdata, $i + 0x1, $j + 0x1)
        Next
    Next
    Return 0x1
EndFunc   ;==>_WINAPI_GETDEVICEGAMMARAMP
Func _WINAPI_GETDIBCOLORTABLE($hbitmap)
    Local $hdc = _WinAPI_CreateCompatibleDC(0x0)
    Local $hsv = _WinAPI_SelectObject($hdc, $hbitmap)
    Local $tpeak = DllStructCreate("dword[256]")
    Local $ierror = 0x0
    Local $acall = DllCall("gdi32.dll", "uint", "GetDIBColorTable", "handle", $hdc, "uint", 0x0, "uint", 0x100, "struct*", $tpeak)
    If @error Or Not $acall[0x0] Then $ierror = @error + 0xa
    _WinAPI_SelectObject($hdc, $hsv)
    _WinAPI_DeleteDC($hdc)
    If $ierror Then Return SetError($ierror, 0x0, 0x0)
    Local $tdata = DllStructCreate("dword[" & $acall[0x0] & "]")
    If @error Then Return SetError(@error + 0x14, @extended, 0x0)
    _WINAPI_MOVEMEMORY($tdata, $acall[0x4], 0x4 * $acall[0x0])
    Return SetExtended($acall[0x0], $tdata)
EndFunc   ;==>_WINAPI_GETDIBCOLORTABLE
Func _WinAPI_GetDIBits($hdc, $hbitmap, $istartscan, $iscanlines, $pbits, $tbi, $iusage)
    Local $acall = DllCall("gdi32.dll", "int", "GetDIBits", "handle", $hdc, "handle", $hbitmap, "uint", $istartscan, "uint", $iscanlines, "struct*", $pbits, "struct*", $tbi, "uint", $iusage)
    If @error Then Return SetError(@error, @extended, False)
    Return $acall[0x0]
EndFunc   ;==>_WINAPI_GETDIBITS
Func _WINAPI_GETENHMETAFILE($sfilepath)
    Local $acall = DllCall("gdi32.dll", "handle", "GetEnhMetaFileW", "wstr", $sfilepath)
    If @error Then Return SetError(@error, @extended, 0x0)
    Return $acall[0x0]
EndFunc   ;==>_WINAPI_GETENHMETAFILE
Func _WINAPI_GETENHMETAFILEBITS($hemf, ByRef $pbuffer)
    Local $acall = DllCall("gdi32.dll", "uint", "GetEnhMetaFileBits", "handle", $hemf, "uint", 0x0, "ptr", 0x0)
    If @error Or Not $acall[0x0] Then Return SetError(@error + 0x32, @extended, 0x0)
    $pbuffer = __HEAPREALLOC($pbuffer, $acall[0x0], 0x1)
    If @error Then Return SetError(@error, @extended, 0x0)
    $acall = DllCall("gdi32.dll", "uint", "GetEnhMetaFileBits", "handle", $hemf, "uint", $acall[0x0], "ptr", $pbuffer)
    If Not $acall[0x0] Then Return SetError(0x3c, 0x0, 0x0)
    Return $acall[0x2]
EndFunc   ;==>_WINAPI_GETENHMETAFILEBITS
Func _WINAPI_GETENHMETAFILEDESCRIPTION($hemf)
    Local $tdata = DllStructCreate("wchar[4096]")
    Local $acall = DllCall("gdi32.dll", "uint", "GetEnhMetaFileDescriptionW", "handle", $hemf, "uint", 0x1000, "struct*", $tdata)
    If @error Or ($acall[0x0] = 0xffffffff) Then Return SetError(@error + 0x14, $acall[0x0], 0x0)
    If Not $acall[0x0] Then Return 0x0
    Local $adata = _WINAPI_STRUCTTOARRAY($tdata)
    If @error Then Return SetError(@error, @extended, 0x0)
    Local $aret[0x2]
    For $i = 0x0 To 0x1
        If $adata[0x0] > $i Then
            $aret[$i] = $adata[$i + 0x1]
        Else
            $aret[$i] = ""
        EndIf
    Next
    Return $aret
EndFunc   ;==>_WINAPI_GETENHMETAFILEDESCRIPTION
Func _WINAPI_GETENHMETAFILEDIMENSION($hemf)
    Local $tenhmetaheader = _WINAPI_GETENHMETAFILEHEADER($hemf)
    If @error Then Return SetError(@error, @extended, 0x0)
    Local $tsize = DllStructCreate($tagsize)
    DllStructSetData($tsize, 0x1, Round((DllStructGetData($tenhmetaheader, "rcFrame", 0x3) - DllStructGetData($tenhmetaheader, "rcFrame", 0x1)) * DllStructGetData($tenhmetaheader, "Device", 0x1) / DllStructGetData($tenhmetaheader, "Millimeters", 0x1) / 0x64))
    DllStructSetData($tsize, 0x2, Round((DllStructGetData($tenhmetaheader, "rcFrame", 0x4) - DllStructGetData($tenhmetaheader, "rcFrame", 0x2)) * DllStructGetData($tenhmetaheader, "Device", 0x2) / DllStructGetData($tenhmetaheader, "Millimeters", 0x2) / 0x64))
    Return $tsize
EndFunc   ;==>_WINAPI_GETENHMETAFILEDIMENSION
Func _WINAPI_GETENHMETAFILEHEADER($hemf)
    Local $tenhmetaheader = DllStructCreate($tagenhmetaheader)
    Local $acall = DllCall("gdi32.dll", "uint", "GetEnhMetaFileHeader", "handle", $hemf, "uint", DllStructGetSize($tenhmetaheader), "struct*", $tenhmetaheader)
    If @error Or Not $acall[0x0] Then Return SetError(@error + 0xa, @extended, 0x0)
    Return SetExtended($acall[0x0], $tenhmetaheader)
EndFunc   ;==>_WINAPI_GETENHMETAFILEHEADER
Func _WINAPI_GETFONTNAME($sfacename, $istyle = 0x0, $icharset = 0x1)
    If Not $sfacename Then Return SetError(0x1, 0x0, "")
    Local $iflags = 0x0
    If BitAND($istyle, 0x1) Then
        $iflags += 0x20
    EndIf
    If BitAND($istyle, 0x2) Then
        $iflags += 0x1
    EndIf
    If Not $iflags Then
        $iflags = 0x40
    EndIf
    Local $tlogfont = DllStructCreate($taglogfont)
    DllStructSetData($tlogfont, 0x9, $icharset)
    DllStructSetData($tlogfont, 0xd, 0x0)
    DllStructSetData($tlogfont, 0xe, StringLeft($sfacename, 0x1f))
    Local $tfn = DllStructCreate("dword;wchar[64]")
    DllStructSetData($tfn, 0x1, $iflags)
    DllStructSetData($tfn, 0x2, "")
    Local $hdc = _WinAPI_CreateCompatibleDC(0x0)
    Local $henumproc = DllCallbackRegister("__EnumFontStylesProc", "int", "ptr;ptr;dword;lparam")
    Local $sret = ""
    Local $acall = DllCall("gdi32.dll", "int", "EnumFontFamiliesExW", "handle", $hdc, "struct*", $tlogfont, "ptr", DllCallbackGetPtr($henumproc), "struct*", $tfn, "dword", 0x0)
    If Not @error And Not $acall[0x0] Then $sret = DllStructGetData($tfn, 0x2)
    DllCallbackFree($henumproc)
    _WinAPI_DeleteDC($hdc)
    If Not $sret Then Return SetError(0x2, 0x0, "")
    Return $sret
EndFunc   ;==>_WINAPI_GETFONTNAME
Func _WINAPI_GETFONTRESOURCEINFO($sfont, $bforce = False, $iflag = Default)
    If $iflag = Default Then
        If $bforce Then
            If Not _WINAPI_ADDFONTRESOURCEEX($sfont, $fr_not_enum) Then Return SetError(@error + 0x14, @extended, "")
        EndIf
        Local $ierror = 0x0
        Local $aret = DllCall("gdi32.dll", "bool", "GetFontResourceInfoW", "wstr", $sfont, "dword*", 0x1000, "wstr", "", "dword", 0x1)
        If @error Or Not $aret[0x0] Then $ierror = @error + 0xa
        If $bforce Then
            _WINAPI_REMOVEFONTRESOURCEEX($sfont, $fr_not_enum)
        EndIf
        If $ierror Then Return SetError($ierror, 0x0, "")
        Return $aret[0x3]
    Else
        If Not FileExists($sfont) Then
            $sfont = RegRead("HKCU\Software\Microsoft\Windows\CurrentVersion\Explorer\Shell Folders", "Fonts") & "\" & $sfont
            If Not FileExists($sfont) Then Return SetError(0x1f, 0x0, "")
        EndIf
        Local Const $hfile = _WinAPI_CreateFile($sfont, 0x2, 0x2, 0x2)
        If Not $hfile Then Return SetError(0x20, _WinAPI_GetLastError(), "")
        Local Const $ifile = FileGetSize($sfont)
        Local Const $tbuffer = DllStructCreate("byte[" & $ifile + 0x1 & "]")
        Local Const $pfile = DllStructGetPtr($tbuffer)
        Local $iread
        _WinAPI_ReadFile($hfile, $pfile, $ifile, $iread)
        _WinAPI_CloseHandle($hfile)
        Local $sttfname = _WINAPI_GETFONTMEMORYRESOURCEINFO($pfile, $iflag)
        If @error Then
            If @error = 0x1 Then
                $sttfname = _WINAPI_GETFONTRESOURCEINFO($sfont, True)
                Return SetError(@error, @extended, $sttfname)
            EndIf
            Return SetError(0x21, @error, "")
        EndIf
        Return $sttfname
    EndIf
EndFunc   ;==>_WINAPI_GETFONTRESOURCEINFO
Func _WINAPI_GETFONTMEMORYRESOURCEINFO($pmemory, $iflag = 0x1)
    Local Const $tagtt_offset_table = "USHORT uMajorVersion;USHORT uMinorVersion;USHORT uNumOfTables;USHORT uSearchRange;USHORT uEntrySelector;USHORT uRangeShift"
    Local Const $tagtt_table_directory = "char szTag[4];ULONG uCheckSum;ULONG uOffset;ULONG uLength"
    Local Const $tagtt_name_table_header = "USHORT uFSelector;USHORT uNRCount;USHORT uStorageOffset"
    Local Const $tagtt_name_record = "USHORT uPlatformID;USHORT uEncodingID;USHORT uLanguageID;USHORT uNameID;USHORT uStringLength;USHORT uStringOffset"
    Local $tttoffsettable = DllStructCreate($tagtt_offset_table, $pmemory)
    Local $inumoftables = _WINAPI_SWAPWORD(DllStructGetData($tttoffsettable, "uNumOfTables"))
    If Not (_WINAPI_SWAPWORD(DllStructGetData($tttoffsettable, "uMajorVersion")) = 0x1 And _WINAPI_SWAPWORD(DllStructGetData($tttoffsettable, "uMinorVersion")) = 0x0) Then Return SetError(0x1, 0x0, "")
    Local $itbldirsize = DllStructGetSize(DllStructCreate($tagtt_table_directory))
    Local $bfound = False, $ioffset, $ttbldir
    For $i = 0x0 To $inumoftables + 0xffffffff
        $ttbldir = DllStructCreate($tagtt_table_directory, $pmemory + DllStructGetSize($tttoffsettable) + $i * $itbldirsize)
        If StringLeft(DllStructGetData($ttbldir, "szTag"), 0x4) = "name" Then
            $bfound = True
            $ioffset = _WINAPI_SWAPDWORD(DllStructGetData($ttbldir, "uOffset"))
            ExitLoop
        EndIf
    Next
    If Not $bfound Then Return SetError(0x2, 0x0, "")
    Local $tntheader = DllStructCreate($tagtt_name_table_header, $pmemory + $ioffset)
    Local $intheadersize = DllStructGetSize($tntheader)
    Local $inrcount = _WINAPI_SWAPWORD(DllStructGetData($tntheader, "uNRCount"))
    Local $istorageoffset = _WINAPI_SWAPWORD(DllStructGetData($tntheader, "uStorageOffset"))
    Local $ittrecordsize = DllStructGetSize(DllStructCreate($tagtt_name_record))
    Local $tresult, $sresult, $istringlength = 0x0, $istringoffset, $iencodingid, $tttrecord
    For $i = 0x0 To $inrcount + 0xffffffff
        $tttrecord = DllStructCreate($tagtt_name_record, $pmemory + $ioffset + $intheadersize + $i * $ittrecordsize)
        If @error Then ContinueLoop
        If _WINAPI_SWAPWORD($tttrecord .uNameID) = $iflag Then
            $istringlength = _WINAPI_SWAPWORD(DllStructGetData($tttrecord, "uStringLength"))
            $istringoffset = _WINAPI_SWAPWORD(DllStructGetData($tttrecord, "uStringOffset"))
            $iencodingid = _WINAPI_SWAPWORD(DllStructGetData($tttrecord, "uEncodingID"))
            Local $swchar = "char"
            If $iencodingid = 0x1 Then
                $swchar = "word"
                $istringlength /= 0x2
            EndIf
            If Not $istringlength Then
                $sresult = ""
                ContinueLoop
            EndIf
            $tresult = DllStructCreate($swchar & " szTTFName[" & $istringlength & "]", $pmemory + $ioffset + $istringoffset + $istorageoffset)
            If $iencodingid = 0x1 Then
                $sresult = ""
                For $j = 0x1 To $istringlength
                    $sresult &= ChrW(_WINAPI_SWAPWORD(DllStructGetData($tresult, 0x1, $j)))
                Next
            Else
                $sresult = $tresult .szTTFName
            EndIf
            If StringLen($sresult) > 0x0 Then ExitLoop
        EndIf
    Next
    Return $sresult
EndFunc   ;==>_WINAPI_GETFONTMEMORYRESOURCEINFO
Func _WINAPI_GETGLYPHOUTLINE($hdc, $schar, $iformat, ByRef $pbuffer, $tmat2 = 0x0)
    Local $tgm = DllStructCreate($tagglyphmetrics)
    Local $acall, $ilength = 0x0
    If Not IsDllStruct($tmat2) Then
        $tmat2 = DllStructCreate("short[8]")
        DllStructSetData($tmat2, 0x1, 0x1, 0x2)
        DllStructSetData($tmat2, 0x1, 0x1, 0x8)
    EndIf
    If $iformat Then
        $acall = DllCall("gdi32.dll", "dword", "GetGlyphOutlineW", "handle", $hdc, "uint", AscW($schar), "uint", $iformat, "struct*", $tgm, "dword", 0x0, "ptr", 0x0, "struct*", $tmat2)
        If @error Or ($acall[0x0] = 0xffffffff) Then Return SetError(@error + 0xa, @extended, 0x0)
        $ilength = $acall[0x0]
        $pbuffer = __HEAPREALLOC($pbuffer, $ilength, 0x1)
        If @error Then Return SetError(@error + 0x14, @extended, 0x0)
    EndIf
    $acall = DllCall("gdi32.dll", "dword", "GetGlyphOutlineW", "handle", $hdc, "uint", AscW($schar), "uint", $iformat, "struct*", $tgm, "dword", $ilength, "ptr", $pbuffer, "struct*", $tmat2)
    If @error Then Return SetError(@error, @extended, 0x0)
    If $acall[0x0] = 0xffffffff Then Return SetError(0xa, +0xffffffff, 0x0)
    Return SetExtended($ilength, $tgm)
EndFunc   ;==>_WINAPI_GETGLYPHOUTLINE
Func _WINAPI_GETGRAPHICSMODE($hdc)
    Local $acall = DllCall("gdi32.dll", "int", "GetGraphicsMode", "handle", $hdc)
    If @error Or Not $acall[0x0] Then Return SetError(@error, @extended, 0x0)
    Return $acall[0x0]
EndFunc   ;==>_WINAPI_GETGRAPHICSMODE
Func _WINAPI_GETGVALUE($irgb)
    Return BitShift(BitAND(__RGB($irgb), 0xff00), 0x8)
EndFunc   ;==>_WINAPI_GETGVALUE
Func _WINAPI_GETMAPMODE($hdc)
    Local $acall = DllCall("gdi32.dll", "int", "GetMapMode", "handle", $hdc)
    If @error Then Return SetError(@error, @extended, 0x0)
    Return $acall[0x0]
EndFunc   ;==>_WINAPI_GETMAPMODE
Func _WINAPI_GETMONITORINFO($hmonitor)
    Local $tmiex = DllStructCreate("dword;long[4];long[4];dword;wchar[32]")
    DllStructSetData($tmiex, 0x1, DllStructGetSize($tmiex))
    Local $acall = DllCall("user32.dll", "bool", "GetMonitorInfoW", "handle", $hmonitor, "struct*", $tmiex)
    If @error Or Not $acall[0x0] Then Return SetError(@error + 0xa, @extended, 0x0)
    Local $aret[0x4]
    For $i = 0x0 To 0x1
        $aret[$i] = DllStructCreate($tagrect)
        _WINAPI_MOVEMEMORY($aret[$i], DllStructGetPtr($tmiex, $i + 0x2), 0x10)
    Next
    $aret[0x3] = DllStructGetData($tmiex, 0x5)
    Switch DllStructGetData($tmiex, 0x4)
        Case 0x1
            $aret[0x2] = 0x1
        Case Else
            $aret[0x2] = 0x0
    EndSwitch
    Return $aret
EndFunc   ;==>_WINAPI_GETMONITORINFO
Func _WINAPI_GETOUTLINETEXTMETRICS($hdc)
    Local $acall = DllCall("gdi32.dll", "uint", "GetOutlineTextMetricsW", "handle", $hdc, "uint", 0x0, "ptr", 0x0)
    If @error Or Not $acall[0x0] Then Return SetError(@error + 0xa, @extended, 0x0)
    Local $tdata = DllStructCreate("byte[" & $acall[0x0] & "]")
    Local $toltm = DllStructCreate($tagoutlinetextmetric, DllStructGetPtr($tdata))
    $acall = DllCall("gdi32.dll", "uint", "GetOutlineTextMetricsW", "handle", $hdc, "uint", $acall[0x0], "struct*", $tdata)
    If Not $acall[0x0] Then Return SetError(0x14, 0x0, 0x0)
    Return $toltm
EndFunc   ;==>_WINAPI_GETOUTLINETEXTMETRICS
Func _WINAPI_GETPIXEL($hdc, $ix, $iy)
    Local $acall = DllCall("gdi32.dll", "dword", "GetPixel", "handle", $hdc, "int", $ix, "int", $iy)
    If @error Or ($acall[0x0] = 0xffffffff) Then Return SetError(@error, @extended, +0xffffffff)
    Return __RGB($acall[0x0])
EndFunc   ;==>_WINAPI_GETPIXEL
Func _WINAPI_GETPOLYFILLMODE($hdc)
    Local $acall = DllCall("gdi32.dll", "int", "GetPolyFillMode", "handle", $hdc)
    If @error Then Return SetError(@error, @extended, 0x0)
    Return $acall[0x0]
EndFunc   ;==>_WINAPI_GETPOLYFILLMODE
Func _WINAPI_GETPOSFROMRECT($trect)
    Local $aret[0x4]
    For $i = 0x0 To 0x3
        $aret[$i] = DllStructGetData($trect, $i + 0x1)
        If @error Then Return SetError(@error, @extended, 0x0)
    Next
    For $i = 0x2 To 0x3
        $aret[$i] -= $aret[$i + 0xfffffffe]
    Next
    Return $aret
EndFunc   ;==>_WINAPI_GETPOSFROMRECT
Func _WINAPI_GETREGIONDATA($hrgn, ByRef $trgndata)
    Local $acall = DllCall("gdi32.dll", "dword", "GetRegionData", "handle", $hrgn, "dword", 0x0, "ptr", 0x0)
    If @error Or Not $acall[0x0] Then
        $trgndata = 0x0
        Return SetError(@error, @extended, False)
    EndIf
    $trgndata = DllStructCreate($tagrgndataheader)
    Local $irectsize = $acall[0x0] - DllStructGetSize($trgndata)
    If $irectsize > 0x0 Then $trgndata = DllStructCreate($tagrgndataheader & ";byte[" & $irectsize & "]")
    $acall = DllCall("gdi32.dll", "dword", "GetRegionData", "handle", $hrgn, "dword", $acall[0x0], "struct*", $trgndata)
    If Not $acall[0x0] Then $trgndata = 0x0
    Return $acall[0x0]
EndFunc   ;==>_WINAPI_GETREGIONDATA
Func _WINAPI_GETRGNBOX($hrgn, ByRef $trect)
    $trect = DllStructCreate($tagrect)
    Local $acall = DllCall("gdi32.dll", "int", "GetRgnBox", "handle", $hrgn, "struct*", $trect)
    If @error Or Not $acall[0x0] Then
        $trect = 0x0
        Return SetError(@error, @extended, 0x0)
    EndIf
    Return $acall[0x0]
EndFunc   ;==>_WINAPI_GETRGNBOX
Func _WINAPI_GETROP2($hdc)
    Local $acall = DllCall("gdi32.dll", "int", "GetROP2", "handle", $hdc)
    If @error Then Return SetError(@error, @extended, 0x0)
    Return $acall[0x0]
EndFunc   ;==>_WINAPI_GETROP2
Func _WINAPI_GETRVALUE($irgb)
    Return BitAND(__RGB($irgb), 0xff)
EndFunc   ;==>_WINAPI_GETRVALUE
Func _WINAPI_GETSTRETCHBLTMODE($hdc)
    Local $acall = DllCall("gdi32.dll", "int", "GetStretchBltMode", "handle", $hdc)
    If @error Then Return SetError(@error, @extended, 0x0)
    Return $acall[0x0]
EndFunc   ;==>_WINAPI_GETSTRETCHBLTMODE
Func _WINAPI_GETTABBEDTEXTEXTENT($hdc, $stext, $atab = 0x0, $istart = 0x0, $iend = +0xffffffff)
    Local $itab, $icount
    If Not IsArray($atab) Then
        If $atab Then
            $itab = $atab
            Dim $atab[0x1] = [$itab]
            $istart = 0x0
            $iend = 0x0
            $icount = 0x1
        Else
            $icount = 0x0
        EndIf
    Else
        $icount = 0x1
    EndIf
    Local $ttab = 0x0
    If $icount Then
        If __CHECKERRORARRAYBOUNDS($atab, $istart, $iend) Then Return SetError(@error + 0xa, @extended, 0x0)
        $icount = $iend - $istart + 0x1
        $ttab = DllStructCreate("uint[" & $icount & "]")
        $itab = 0x1
        For $i = $istart To $iend
            DllStructSetData($ttab, 0x1, $atab[$i], $itab)
            $itab += 0x1
        Next
    EndIf
    Local $acall = DllCall("user32.dll", "dword", "GetTabbedTextExtentW", "handle", $hdc, "wstr", $stext, "int", StringLen($stext), "int", $icount, "struct*", $ttab)
    If @error Or Not $acall[0x0] Then Return SetError(@error + 0x14, @extended, 0x0)
    Return _WINAPI_CREATESIZE(_WinAPI_LoWord($acall[0x0]), _WinAPI_HiWord($acall[0x0]))
EndFunc   ;==>_WINAPI_GETTABBEDTEXTEXTENT
Func _WINAPI_GETTEXTALIGN($hdc)
    Local $acall = DllCall("gdi32.dll", "uint", "GetTextAlign", "handle", $hdc)
    If @error Or ($acall[0x0] = 0xffffffff) Then Return SetError(@error, @extended, +0xffffffff)
    Return $acall[0x0]
EndFunc   ;==>_WINAPI_GETTEXTALIGN
Func _WINAPI_GETTEXTCHARACTEREXTRA($hdc)
    Local $acall = DllCall("gdi32.dll", "int", "GetTextCharacterExtra", "handle", $hdc)
    If @error Or ($acall[0x0] = 0x8000000) Then Return SetError(@error, @extended, +0xffffffff)
    Return $acall[0x0]
EndFunc   ;==>_WINAPI_GETTEXTCHARACTEREXTRA
Func _WINAPI_GETTEXTFACE($hdc)
    Local $acall = DllCall("gdi32.dll", "int", "GetTextFaceW", "handle", $hdc, "int", 0x800, "wstr", "")
    If @error Or Not $acall[0x0] Then Return SetError(@error + 0xa, @extended, "")
    Return $acall[0x3]
EndFunc   ;==>_WINAPI_GETTEXTFACE
Func _WINAPI_GETUDFCOLORMODE()
    Return Number($__g_irgbmode)
EndFunc   ;==>_WINAPI_GETUDFCOLORMODE
Func _WINAPI_GETUPDATERECT($hwnd, $berase = True)
    Local $trect = DllStructCreate($tagrect)
    Local $acall = DllCall("user32.dll", "bool", "GetUpdateRect", "hwnd", $hwnd, "struct*", $trect, "bool", $berase)
    If @error Or Not $acall[0x0] Then Return SetError(@error + 0xa, @extended, 0x0)
    Return $trect
EndFunc   ;==>_WINAPI_GETUPDATERECT
Func _WINAPI_GETUPDATERGN($hwnd, $hrgn, $berase = True)
    Local $acall = DllCall("user32.dll", "int", "GetUpdateRgn", "hwnd", $hwnd, "handle", $hrgn, "bool", $berase)
    If @error Then Return SetError(@error, @extended, 0x0)
    Return $acall[0x0]
EndFunc   ;==>_WINAPI_GETUPDATERGN
Func _WINAPI_GETWINDOWEXT($hdc)
    Local $tsize = DllStructCreate($tagsize)
    Local $acall = DllCall("gdi32.dll", "bool", "GetWindowExtEx", "handle", $hdc, "struct*", $tsize)
    If @error Or Not $acall[0x0] Then Return SetError(@error + 0xa, @extended, 0x0)
    Return $tsize
EndFunc   ;==>_WINAPI_GETWINDOWEXT
Func _WINAPI_GETWINDOWORG($hdc)
    Local $tpoint = DllStructCreate($tagpoint)
    Local $acall = DllCall("gdi32.dll", "bool", "GetWindowOrgEx", "handle", $hdc, "struct*", $tpoint)
    If @error Or Not $acall[0x0] Then Return SetError(@error + 0xa, @extended, 0x0)
    Return $tpoint
EndFunc   ;==>_WINAPI_GETWINDOWORG
Func _WINAPI_GETWINDOWRGNBOX($hwnd, ByRef $trect)
    $trect = DllStructCreate($tagrect)
    Local $acall = DllCall("gdi32.dll", "int", "GetWindowRgnBox", "hwnd", $hwnd, "struct*", $trect)
    If @error Then Return SetError(@error, @extended, 0x0)
    Return $acall[0x0]
EndFunc   ;==>_WINAPI_GETWINDOWRGNBOX
Func _WINAPI_GETWORLDTRANSFORM($hdc)
    Local $txform = DllStructCreate($tagxform)
    Local $acall = DllCall("gdi32.dll", "bool", "GetWorldTransform", "handle", $hdc, "struct*", $txform)
    If @error Or Not $acall[0x0] Then Return SetError(@error + 0xa, @extended, 0x0)
    Return $txform
EndFunc   ;==>_WINAPI_GETWORLDTRANSFORM
Func _WINAPI_GRADIENTFILL($hdc, Const ByRef $avertex, $istart = 0x0, $iend = +0xffffffff, $brotate = False)
    If __CHECKERRORARRAYBOUNDS($avertex, $istart, $iend, 0x2) Then Return SetError(@error + 0xa, @extended, 0x0)
    If UBound($avertex, $ubound_columns) < 0x3 Then Return SetError(0xd, 0x0, 0x0)
    Local $ipoint = $iend - $istart + 0x1
    If $ipoint > 0x3 Then
        $iend = $istart + 0x2
        $ipoint = 0x3
    EndIf
    Local $imode
    Switch $ipoint
        Case 0x2
            $imode = Number(Not $brotate)
        Case 0x3
            $imode = 0x2
        Case Else
            Return SetError(0xf, 0x0, 0x0)
    EndSwitch
    Local $tagstruct = ""
    For $i = $istart To $iend
        $tagstruct &= "ushort[8];"
    Next
    Local $tvertex = DllStructCreate($tagstruct)
    Local $icount = 0x1
    Local $tgradient = DllStructCreate("ulong[" & $ipoint & "]")
    For $i = $istart To $iend
        DllStructSetData($tgradient, 0x1, $icount + 0xffffffff, $icount)
        DllStructSetData($tvertex, $icount, _WinAPI_LoWord($avertex[$i][0x0]), 0x1)
        DllStructSetData($tvertex, $icount, _WinAPI_HiWord($avertex[$i][0x0]), 0x2)
        DllStructSetData($tvertex, $icount, _WinAPI_LoWord($avertex[$i][0x1]), 0x3)
        DllStructSetData($tvertex, $icount, _WinAPI_HiWord($avertex[$i][0x1]), 0x4)
        DllStructSetData($tvertex, $icount, BitShift(_WINAPI_GETRVALUE($avertex[$i][0x2]), +0xfffffff8), 0x5)
        DllStructSetData($tvertex, $icount, BitShift(_WINAPI_GETGVALUE($avertex[$i][0x2]), +0xfffffff8), 0x6)
        DllStructSetData($tvertex, $icount, BitShift(_WINAPI_GETBVALUE($avertex[$i][0x2]), +0xfffffff8), 0x7)
        DllStructSetData($tvertex, $icount, 0x0, 0x8)
        $icount += 0x1
    Next
    Local $acall = DllCall("gdi32.dll", "bool", "GdiGradientFill", "handle", $hdc, "struct*", $tvertex, "ulong", $ipoint, "struct*", $tgradient, "ulong", 0x1, "ulong", $imode)
    If @error Then Return SetError(@error, @extended, 0x0)
    Return $acall[0x0]
EndFunc   ;==>_WINAPI_GRADIENTFILL
Func _WINAPI_INFLATERECT(ByRef $trect, $idx, $idy)
    Local $acall = DllCall("user32.dll", "bool", "InflateRect", "struct*", $trect, "int", $idx, "int", $idy)
    If @error Then Return SetError(@error, @extended, False)
    Return $acall[0x0]
EndFunc   ;==>_WINAPI_INFLATERECT
Func _WINAPI_INTERSECTCLIPRECT($hdc, $trect)
    Local $acall = DllCall("gdi32.dll", "int", "IntersectClipRect", "handle", $hdc, "int", DllStructGetData($trect, 0x1), "int", DllStructGetData($trect, 0x2), "int", DllStructGetData($trect, 0x3), "int", DllStructGetData($trect, 0x4))
    If @error Then Return SetError(@error, @extended, 0x0)
    Return $acall[0x0]
EndFunc   ;==>_WINAPI_INTERSECTCLIPRECT
Func _WINAPI_INTERSECTRECT($trect1, $trect2)
    Local $trect = DllStructCreate($tagrect)
    Local $acall = DllCall("user32.dll", "bool", "IntersectRect", "struct*", $trect, "struct*", $trect1, "struct*", $trect2)
    If @error Or Not $acall[0x0] Then Return SetError(@error + 0xa, @extended, 0x0)
    Return $trect
EndFunc   ;==>_WINAPI_INTERSECTRECT
Func _WINAPI_INVALIDATERGN($hwnd, $hrgn = 0x0, $berase = True)
    Local $acall = DllCall("user32.dll", "bool", "InvalidateRgn", "hwnd", $hwnd, "handle", $hrgn, "bool", $berase)
    If @error Then Return SetError(@error, @extended, False)
    Return $acall[0x0]
EndFunc   ;==>_WINAPI_INVALIDATERGN
Func _WINAPI_INVERTANDBITMAP($hbitmap, $bdelete = False)
    Local $tbitmap = DllStructCreate($tagbitmap)
    If Not _WinAPI_GetObject($hbitmap, DllStructGetSize($tbitmap), $tbitmap) Or (DllStructGetData($tbitmap, "bmBitsPixel") <> 0x1) Then
        Return SetError(@error + 0xa, @extended, 0x0)
    EndIf
    Local $hresult = _WINAPI_CREATEDIB(DllStructGetData($tbitmap, "bmWidth"), DllStructGetData($tbitmap, "bmHeight"), 0x1)
    If Not $hresult Then Return SetError(@error, @extended, 0x0)
    Local $hsrcdc = _WinAPI_CreateCompatibleDC(0x0)
    Local $hsrcsv = _WinAPI_SelectObject($hsrcdc, $hbitmap)
    Local $hdstdc = _WinAPI_CreateCompatibleDC(0x0)
    Local $hdstsv = _WinAPI_SelectObject($hdstdc, $hresult)
    _WinAPI_BitBlt($hdstdc, 0x0, 0x0, DllStructGetData($tbitmap, "bmWidth"), DllStructGetData($tbitmap, "bmHeight"), $hsrcdc, 0x0, 0x0, 0x330008)
    _WinAPI_SelectObject($hsrcdc, $hsrcsv)
    _WinAPI_DeleteDC($hsrcdc)
    _WinAPI_SelectObject($hdstdc, $hdstsv)
    _WinAPI_DeleteDC($hdstdc)
    If $bdelete Then
        _WinAPI_DeleteObject($hbitmap)
    EndIf
    Return $hresult
EndFunc   ;==>_WINAPI_INVERTANDBITMAP
Func _WINAPI_INVERTCOLOR($icolor)
    If $icolor = +0xffffffff Then Return 0x0
    Return 0xffffff - BitAND($icolor, 0xffffff)
EndFunc   ;==>_WINAPI_INVERTCOLOR
Func _WINAPI_INVERTRECT($hdc, ByRef $trect)
    Local $acall = DllCall("user32.dll", "bool", "InvertRect", "handle", $hdc, "struct*", $trect)
    If @error Then Return SetError(@error, @extended, False)
    Return $acall[0x0]
EndFunc   ;==>_WINAPI_INVERTRECT
Func _WINAPI_INVERTRGN($hdc, $hrgn)
    Local $acall = DllCall("gdi32.dll", "bool", "InvertRgn", "handle", $hdc, "handle", $hrgn)
    If @error Then Return SetError(@error, @extended, False)
    Return $acall[0x0]
EndFunc   ;==>_WINAPI_INVERTRGN
Func _WINAPI_ISRECTEMPTY(ByRef $trect)
    Local $acall = DllCall("user32.dll", "bool", "IsRectEmpty", "struct*", $trect)
    If @error Then Return SetError(@error, @extended, False)
    Return $acall[0x0]
EndFunc   ;==>_WINAPI_ISRECTEMPTY
Func _WINAPI_LINEDDA($ix1, $iy1, $ix2, $iy2, $plineproc, $pdata = 0x0)
    Local $acall = DllCall("gdi32.dll", "bool", "LineDDA", "int", $ix1, "int", $iy1, "int", $ix2, "int", $iy2, "ptr", $plineproc, "lparam", $pdata)
    If @error Then Return SetError(@error, @extended, False)
    Return $acall[0x0]
EndFunc   ;==>_WINAPI_LINEDDA
Func _WinAPI_LineTo($hdc, $ix, $iy)
    Local $acall = DllCall("gdi32.dll", "bool", "LineTo", "handle", $hdc, "int", $ix, "int", $iy)
    If @error Then Return SetError(@error, @extended, False)
    Return $acall[0x0]
EndFunc   ;==>_WINAPI_LINETO
Func _WINAPI_LOCKWINDOWUPDATE($hwnd)
    Local $acall = DllCall("user32.dll", "bool", "LockWindowUpdate", "hwnd", $hwnd)
    If @error Then Return SetError(@error, @extended, False)
    Return $acall[0x0]
EndFunc   ;==>_WINAPI_LOCKWINDOWUPDATE
Func _WINAPI_LPTODP($hdc, ByRef $tpoint, $icount = 0x1)
    Local $acall = DllCall("gdi32.dll", "bool", "LPtoDP", "handle", $hdc, "struct*", $tpoint, "int", $icount)
    If @error Then Return SetError(@error, @extended, False)
    Return $acall[0x0]
EndFunc   ;==>_WINAPI_LPTODP
Func _WINAPI_MASKBLT($hdestdc, $ixdest, $iydest, $iwidth, $iheight, $hsrcdc, $ixsrc, $iysrc, $hmask, $ixmask, $iymask, $irop)
    Local $acall = DllCall("gdi32.dll", "bool", "MaskBlt", "handle", $hdestdc, "int", $ixdest, "int", $iydest, "int", $iwidth, "int", $iheight, "hwnd", $hsrcdc, "int", $ixsrc, "int", $iysrc, "handle", $hmask, "int", $ixmask, "int", $iymask, "dword", $irop)
    If @error Then Return SetError(@error, @extended, False)
    Return $acall[0x0]
EndFunc   ;==>_WINAPI_MASKBLT
Func _WINAPI_MODIFYWORLDTRANSFORM($hdc, ByRef $txform, $imode)
    Local $acall = DllCall("gdi32.dll", "bool", "ModifyWorldTransform", "handle", $hdc, "struct*", $txform, "dword", $imode)
    If @error Then Return SetError(@error, @extended, False)
    Return $acall[0x0]
EndFunc   ;==>_WINAPI_MODIFYWORLDTRANSFORM
Func _WINAPI_MONITORFROMPOINT(ByRef $tpoint, $iflag = 0x1)
    If DllStructGetSize($tpoint) <> 0x8 Then Return SetError(@error + 0xa, @extended, 0x0)
    Local $acall = DllCall("user32.dll", "handle", "MonitorFromPoint", "struct", $tpoint, "dword", $iflag)
    If @error Then Return SetError(@error, @extended, 0x0)
    Return $acall[0x0]
EndFunc   ;==>_WINAPI_MONITORFROMPOINT
Func _WINAPI_MONITORFROMRECT(ByRef $trect, $iflag = 0x1)
    Local $acall = DllCall("user32.dll", "ptr", "MonitorFromRect", "struct*", $trect, "dword", $iflag)
    If @error Then Return SetError(@error, @extended, 0x0)
    Return $acall[0x0]
EndFunc   ;==>_WINAPI_MONITORFROMRECT
Func _WINAPI_MONITORFROMWINDOW($hwnd, $iflag = 0x1)
    Local $acall = DllCall("user32.dll", "handle", "MonitorFromWindow", "hwnd", $hwnd, "dword", $iflag)
    If @error Then Return SetError(@error, @extended, 0x0)
    Return $acall[0x0]
EndFunc   ;==>_WINAPI_MONITORFROMWINDOW
Func _WinAPI_MoveTo($hdc, $ix, $iy)
    Local $acall = DllCall("gdi32.dll", "bool", "MoveToEx", "handle", $hdc, "int", $ix, "int", $iy, "ptr", 0x0)
    If @error Then Return SetError(@error, @extended, False)
    Return $acall[0x0]
EndFunc   ;==>_WINAPI_MOVETO
Func _WINAPI_MOVETOEX($hdc, $ix, $iy)
    Local $tpoint = DllStructCreate($tagpoint)
    Local $acall = DllCall("gdi32.dll", "bool", "MoveToEx", "handle", $hdc, "int", $ix, "int", $iy, "struct*", $tpoint)
    If @error Or Not $acall[0x0] Then Return SetError(@error + 0xa, @extended, 0x0)
    Return $tpoint
EndFunc   ;==>_WINAPI_MOVETOEX
Func _WINAPI_OFFSETCLIPRGN($hdc, $ixoffset, $iyoffset)
    Local $acall = DllCall("gdi32.dll", "int", "OffsetClipRgn", "handle", $hdc, "int", $ixoffset, "int", $iyoffset)
    If @error Then Return SetError(@error, @extended, 0x0)
    Return $acall[0x0]
EndFunc   ;==>_WINAPI_OFFSETCLIPRGN
Func _WINAPI_OFFSETPOINTS(ByRef $apoint, $ixoffset, $iyoffset, $istart = 0x0, $iend = +0xffffffff)
    If __CHECKERRORARRAYBOUNDS($apoint, $istart, $iend, 0x2) Then Return SetError(@error + 0xa, @extended, 0x0)
    If UBound($apoint, $ubound_columns) < 0x2 Then Return SetError(0xd, 0x0, 0x0)
    For $i = $istart To $iend
        $apoint[$i][0x0] += $ixoffset
        $apoint[$i][0x1] += $iyoffset
    Next
    Return 0x1
EndFunc   ;==>_WINAPI_OFFSETPOINTS
Func _WINAPI_OFFSETRECT(ByRef $trect, $idx, $idy)
    Local $acall = DllCall("user32.dll", "bool", "OffsetRect", "struct*", $trect, "int", $idx, "int", $idy)
    If @error Then Return SetError(@error, @extended, 0x0)
    Return $acall[0x0]
EndFunc   ;==>_WINAPI_OFFSETRECT
Func _WINAPI_OFFSETRGN($hrgn, $ixoffset, $iyoffset)
    Local $acall = DllCall("gdi32.dll", "int", "OffsetRgn", "handle", $hrgn, "int", $ixoffset, "int", $iyoffset)
    If @error Then Return SetError(@error, @extended, 0x0)
    Return $acall[0x0]
EndFunc   ;==>_WINAPI_OFFSETRGN
Func _WINAPI_OFFSETWINDOWORG($hdc, $ixoffset, $iyoffset)
    $__g_vext = DllStructCreate($tagpoint)
    Local $acall = DllCall("gdi32.dll", "bool", "OffsetWindowOrgEx", "handle", $hdc, "int", $ixoffset, "int", $iyoffset, "struct*", $__g_vext)
    If @error Then Return SetError(@error, @extended, False)
    Return $acall[0x0]
EndFunc   ;==>_WINAPI_OFFSETWINDOWORG
Func _WINAPI_PAINTDESKTOP($hdc)
    Local $acall = DllCall("user32.dll", "bool", "PaintDesktop", "handle", $hdc)
    If @error Then Return SetError(@error, @extended, False)
    Return $acall[0x0]
EndFunc   ;==>_WINAPI_PAINTDESKTOP
Func _WINAPI_PAINTRGN($hdc, $hrgn)
    Local $acall = DllCall("gdi32.dll", "bool", "PaintRgn", "handle", $hdc, "handle", $hrgn)
    If @error Then Return SetError(@error, @extended, False)
    Return $acall[0x0]
EndFunc   ;==>_WINAPI_PAINTRGN
Func _WINAPI_PATBLT($hdc, $ix, $iy, $iwidth, $iheight, $irop)
    Local $acall = DllCall("gdi32.dll", "bool", "PatBlt", "handle", $hdc, "int", $ix, "int", $iy, "int", $iwidth, "int", $iheight, "dword", $irop)
    If @error Then Return SetError(@error, @extended, False)
    Return $acall[0x0]
EndFunc   ;==>_WINAPI_PATBLT
Func _WINAPI_PATHTOREGION($hdc)
    Local $acall = DllCall("gdi32.dll", "handle", "PathToRegion", "handle", $hdc)
    If @error Then Return SetError(@error, @extended, 0x0)
    Return $acall[0x0]
EndFunc   ;==>_WINAPI_PATHTOREGION
Func _WINAPI_PLAYENHMETAFILE($hdc, $hemf, ByRef $trect)
    Local $acall = DllCall("gdi32.dll", "bool", "PlayEnhMetaFile", "handle", $hdc, "handle", $hemf, "struct*", $trect)
    If @error Then Return SetError(@error, @extended, False)
    Return $acall[0x0]
EndFunc   ;==>_WINAPI_PLAYENHMETAFILE
Func _WINAPI_PLGBLT($hdestdc, Const ByRef $apoint, $hsrcdc, $ixsrc, $iysrc, $iwidth, $iheight, $hmask = 0x0, $ixmask = 0x0, $iymask = 0x0)
    If (UBound($apoint) < 0x3) Or (UBound($apoint, $ubound_columns) < 0x2) Then Return SetError(0xc, 0x0, False)
    Local $tpoints = DllStructCreate("long[2];long[2];long[2]")
    For $i = 0x0 To 0x2
        For $j = 0x0 To 0x1
            DllStructSetData($tpoints, $i + 0x1, $apoint[$i][$j], $j + 0x1)
        Next
    Next
    Local $acall = DllCall("gdi32.dll", "bool", "PlgBlt", "handle", $hdestdc, "struct*", $tpoints, "handle", $hsrcdc, "int", $ixsrc, "int", $iysrc, "int", $iwidth, "int", $iheight, "handle", $hmask, "int", $ixmask, "int", $iymask)
    If @error Then Return SetError(@error, @extended, False)
    Return $acall[0x0]
EndFunc   ;==>_WINAPI_PLGBLT
Func _WINAPI_POLYBEZIER($hdc, Const ByRef $apoint, $istart = 0x0, $iend = +0xffffffff)
    If __CHECKERRORARRAYBOUNDS($apoint, $istart, $iend, 0x2, 0x2) Then Return SetError(@error + 0xa, @extended, False)
    Local $ipoint = 0x1 + 0x3 * Floor(($iend - $istart) / 0x3)
    If $ipoint < 0x1 Then Return SetError(0xf, 0x0, False)
    $iend = $istart + $ipoint + 0xffffffff
    Local $tagstruct = ""
    For $i = $istart To $iend
        $tagstruct &= "long[2];"
    Next
    Local $tpoint = DllStructCreate($tagstruct)
    Local $icount = 0x0
    For $i = $istart To $iend
        $icount += 0x1
        For $j = 0x0 To 0x1
            DllStructSetData($tpoint, $icount, $apoint[$i][$j], $j + 0x1)
        Next
    Next
    Local $acall = DllCall("gdi32.dll", "bool", "PolyBezier", "handle", $hdc, "struct*", $tpoint, "dword", $ipoint)
    If @error Then Return SetError(@error, @extended, False)
    Return $acall[0x0]
EndFunc   ;==>_WINAPI_POLYBEZIER
Func _WINAPI_POLYBEZIERTO($hdc, Const ByRef $apoint, $istart = 0x0, $iend = +0xffffffff)
    If __CHECKERRORARRAYBOUNDS($apoint, $istart, $iend, 0x2, 0x2) Then Return SetError(@error + 0xa, @extended, False)
    Local $ipoint = 0x3 * Floor(($iend - $istart + 0x1) / 0x3)
    If $ipoint < 0x3 Then Return SetError(0xf, 0x0, False)
    $iend = $istart + $ipoint + 0xffffffff
    Local $tagstruct = ""
    For $i = $istart To $iend
        $tagstruct &= "long[2];"
    Next
    Local $tpoint = DllStructCreate($tagstruct)
    Local $icount = 0x0
    For $i = $istart To $iend
        $icount += 0x1
        For $j = 0x0 To 0x1
            DllStructSetData($tpoint, $icount, $apoint[$i][$j], $j + 0x1)
        Next
    Next
    Local $acall = DllCall("gdi32.dll", "bool", "PolyBezierTo", "handle", $hdc, "struct*", $tpoint, "dword", $ipoint)
    If @error Then Return SetError(@error, @extended, False)
    Return $acall[0x0]
EndFunc   ;==>_WINAPI_POLYBEZIERTO
Func _WINAPI_POLYDRAW($hdc, Const ByRef $apoint, $istart = 0x0, $iend = +0xffffffff)
    If __CHECKERRORARRAYBOUNDS($apoint, $istart, $iend, 0x2) Then Return SetError(@error + 0xa, @extended, 0x0)
    If UBound($apoint, $ubound_columns) < 0x3 Then Return SetError(0xd, 0x0, False)
    Local $ipoint = $iend - $istart + 0x1
    Local $tagstruct = ""
    For $i = $istart To $iend
        $tagstruct &= "long[2];"
    Next
    Local $tpoint = DllStructCreate($tagstruct)
    Local $ttypes = DllStructCreate("byte[" & $ipoint & "]")
    Local $icount = 0x0
    For $i = $istart To $iend
        $icount += 0x1
        For $j = 0x0 To 0x1
            DllStructSetData($tpoint, $icount, $apoint[$i][$j], $j + 0x1)
        Next
        DllStructSetData($ttypes, 0x1, $apoint[$i][0x2], $icount)
    Next
    Local $acall = DllCall("gdi32.dll", "bool", "PolyDraw", "handle", $hdc, "struct*", $tpoint, "struct*", $ttypes, "dword", $ipoint)
    If @error Then Return SetError(@error, @extended, False)
    Return $acall[0x0]
EndFunc   ;==>_WINAPI_POLYDRAW
Func _WINAPI_POLYGON($hdc, Const ByRef $apoint, $istart = 0x0, $iend = +0xffffffff)
    If __CHECKERRORARRAYBOUNDS($apoint, $istart, $iend, 0x2, 0x2) Then Return SetError(@error + 0xa, @extended, False)
    Local $tagstruct = ""
    For $i = $istart To $iend
        $tagstruct &= "int[2];"
    Next
    Local $tdata = DllStructCreate($tagstruct)
    Local $icount = 0x1
    For $i = $istart To $iend
        For $j = 0x0 To 0x1
            DllStructSetData($tdata, $icount, $apoint[$i][$j], $j + 0x1)
        Next
        $icount += 0x1
    Next
    Local $acall = DllCall("gdi32.dll", "bool", "Polygon", "handle", $hdc, "struct*", $tdata, "int", $icount + 0xffffffff)
    If @error Then Return SetError(@error, @extended, False)
    Return $acall[0x0]
EndFunc   ;==>_WINAPI_POLYGON
Func _WINAPI_PTINRECTEX($ix, $iy, $ileft, $itop, $iright, $ibottom)
    Local $trect = _WINAPI_CREATERECT($ileft, $itop, $iright, $ibottom)
    Local $tpoint = _WINAPI_CREATEPOINT($ix, $iy)
    Local $acall = DllCall("user32.dll", "bool", "PtInRect", "struct*", $trect, "struct", $tpoint)
    If @error Then Return SetError(@error, @extended, False)
    Return $acall[0x0]
EndFunc   ;==>_WINAPI_PTINRECTEX
Func _WINAPI_PTINREGION($hrgn, $ix, $iy)
    Local $acall = DllCall("gdi32.dll", "bool", "PtInRegion", "handle", $hrgn, "int", $ix, "int", $iy)
    If @error Then Return SetError(@error, @extended, False)
    Return $acall[0x0]
EndFunc   ;==>_WINAPI_PTINREGION
Func _WINAPI_PTVISIBLE($hdc, $ix, $iy)
    Local $acall = DllCall("gdi32.dll", "bool", "PtVisible", "handle", $hdc, "int", $ix, "int", $iy)
    If @error Then Return SetError(@error + 0xa, @extended, 0x0)
    If $acall[0x0] = +0xffffffff Then Return SetError(0xa, $acall[0x0], 0x0)
    Return $acall[0x0]
EndFunc   ;==>_WINAPI_PTVISIBLE
Func _WINAPI_RADIALGRADIENTFILL($hdc, $ix, $iy, $iradius, $irgb1, $irgb2, $fanglestart = 0x0, $fangleend = 0x168, $fstep = 0x5)
    If Abs($fanglestart) > 0x168 Then
        $fanglestart = Mod($fanglestart, 0x168)
    EndIf
    If Abs($fangleend) > 0x168 Then
        $fangleend = Mod($fangleend, 0x168)
    EndIf
    If ($fanglestart < 0x0) Or ($fangleend < 0x0) Then
        $fanglestart += 0x168
        $fangleend += 0x168
    EndIf
    If $fanglestart > $fangleend Then
        Local $fval = $fanglestart
        $fanglestart = $fangleend
        $fangleend = $fval
    EndIf
    If $fstep < 0x1 Then
        $fstep = 0x1
    EndIf
    Local $fki = ATan(0x1) / 0x2d
    Local $ixp = Round($ix + $iradius * Cos($fki * $fanglestart))
    Local $iyp = Round($iy + $iradius * Sin($fki * $fanglestart))
    Local $ixn, $iyn, $fan = $fanglestart
    Local $avertex[0x3][0x3]
    While $fan < $fangleend
        $fan += $fstep
        If $fan > $fangleend Then
            $fan = $fangleend
        EndIf
        $ixn = Round($ix + $iradius * Cos($fki * $fan))
        $iyn = Round($iy + $iradius * Sin($fki * $fan))
        $avertex[0x0][0x0] = $ix
        $avertex[0x0][0x1] = $iy
        $avertex[0x0][0x2] = $irgb1
        $avertex[0x1][0x0] = $ixp
        $avertex[0x1][0x1] = $iyp
        $avertex[0x1][0x2] = $irgb2
        $avertex[0x2][0x0] = $ixn
        $avertex[0x2][0x1] = $iyn
        $avertex[0x2][0x2] = $irgb2
        If Not _WINAPI_GRADIENTFILL($hdc, $avertex, 0x0, 0x2) Then
            Return SetError(@error, @extended, 0x0)
        EndIf
        $ixp = $ixn
        $iyp = $iyn
    WEnd
    Return 0x1
EndFunc   ;==>_WINAPI_RADIALGRADIENTFILL
Func _WINAPI_RECTANGLE($hdc, $trect)
    Local $acall = DllCall("gdi32.dll", "bool", "Rectangle", "handle", $hdc, "int", DllStructGetData($trect, 0x1), "int", DllStructGetData($trect, 0x2), "int", DllStructGetData($trect, 0x3), "int", DllStructGetData($trect, 0x4))
    If @error Then Return SetError(@error, @extended, 0x0)
    Return $acall[0x0]
EndFunc   ;==>_WINAPI_RECTANGLE
Func _WINAPI_RECTINREGION($hrgn, $trect)
    Local $acall = DllCall("gdi32.dll", "bool", "RectInRegion", "handle", $hrgn, "struct*", $trect)
    If @error Then Return SetError(@error, @extended, False)
    Return $acall[0x0]
EndFunc   ;==>_WINAPI_RECTINREGION
Func _WinAPI_RectIsEmpty(ByRef $trect)
    Return (DllStructGetData($trect, "Left") = 0x0) And (DllStructGetData($trect, "Top") = 0x0) And (DllStructGetData($trect, "Right") = 0x0) And (DllStructGetData($trect, "Bottom") = 0x0)
EndFunc   ;==>_WINAPI_RECTISEMPTY
Func _WINAPI_RECTVISIBLE($hdc, $trect)
    Local $acall = DllCall("gdi32.dll", "bool", "RectVisible", "handle", $hdc, "struct*", $trect)
    If @error Then Return SetError(@error, @extended, 0x0)
    Switch $acall[0x0]
        Case 0x0, 0x1, 0x2
        Case Else
            Return SetError(0xa, $acall[0x0], 0x0)
    EndSwitch
    Return $acall[0x0]
EndFunc   ;==>_WINAPI_RECTVISIBLE
Func _WINAPI_REMOVEFONTMEMRESOURCEEX($hfont)
    Local $acall = DllCall("gdi32.dll", "bool", "RemoveFontMemResourceEx", "handle", $hfont)
    If @error Then Return SetError(@error, @extended, False)
    Return $acall[0x0]
EndFunc   ;==>_WINAPI_REMOVEFONTMEMRESOURCEEX
Func _WINAPI_REMOVEFONTRESOURCEEX($sfont, $iflag = 0x0, $bnotify = False)
    Local $acall = DllCall("gdi32.dll", "bool", "RemoveFontResourceExW", "wstr", $sfont, "dword", $iflag, "ptr", 0x0)
    If @error Or Not $acall[0x0] Then Return SetError(@error, @extended, False)
    If $bnotify Then
        Local Const $wm_fontchange = 0x1d
        Local Const $hwnd_broadcast = 0xffff
        DllCall("user32.dll", "none", "SendMessage", "hwnd", $hwnd_broadcast, "uint", $wm_fontchange, "wparam", 0x0, "lparam", 0x0)
    EndIf
    Return $acall[0x0]
EndFunc   ;==>_WINAPI_REMOVEFONTRESOURCEEX
Func _WINAPI_RGB($ired, $igreen, $iblue)
    Return __RGB(BitOR(BitShift($iblue, +0xfffffff0), BitShift($igreen, +0xfffffff8), $ired))
EndFunc   ;==>_WINAPI_RGB
Func _WINAPI_ROTATEPOINTS(ByRef $apoint, $ixc, $iyc, $fangle, $istart = 0x0, $iend = +0xffffffff)
    If __CHECKERRORARRAYBOUNDS($apoint, $istart, $iend, 0x2) Then Return SetError(@error + 0xa, @extended, 0x0)
    If UBound($apoint, $ubound_columns) < 0x2 Then Return SetError(0xd, 0x0, 0x0)
    Local $fcos = Cos(ATan(0x1) / 0x2d * $fangle)
    Local $fsin = Sin(ATan(0x1) / 0x2d * $fangle)
    Local $ixn, $iyn
    For $i = $istart To $iend
        $ixn = $apoint[$i][0x0] - $ixc
        $iyn = $apoint[$i][0x1] - $iyc
        $apoint[$i][0x0] = $ixc + Round($ixn * $fcos - $iyn * $fsin)
        $apoint[$i][0x1] = $iyc + Round($ixn * $fsin + $iyn * $fcos)
    Next
    Return 0x1
EndFunc   ;==>_WINAPI_ROTATEPOINTS
Func _WINAPI_ROUNDRECT($hdc, $trect, $iwidth, $iheight)
    Local $acall = DllCall("gdi32.dll", "bool", "RoundRect", "handle", $hdc, "int", DllStructGetData($trect, 0x1), "int", DllStructGetData($trect, 0x2), "int", DllStructGetData($trect, 0x3), "int", DllStructGetData($trect, 0x4), "int", $iwidth, "int", $iheight)
    If @error Then Return SetError(@error, @extended, 0x0)
    Return $acall[0x0]
EndFunc   ;==>_WINAPI_ROUNDRECT
Func _WINAPI_SAVEHBITMAPTOFILE($sfilepath, $hbitmap, $ixpelspermeter = Default, $iypelspermeter = Default)
    Local $tbmp = DllStructCreate("align 1;ushort bfType;dword bfSize;ushort bfReserved1;ushort bfReserved2;dword bfOffset")
    Local $tdib = DllStructCreate($tagdibsection)
    Local $hdc, $hsv, $hsource = 0x0
    While $hbitmap
        If (Not _WinAPI_GetObject($hbitmap, DllStructGetSize($tdib), $tdib)) Or (DllStructGetData($tdib, "biCompression")) Then
            $hbitmap = 0x0
        Else
            Switch DllStructGetData($tdib, "bmBitsPixel")
                Case 0x20
                    If Not _WINAPI_ISALPHABITMAP($hbitmap) Then
                        If Not $hsource Then
                            $hsource = _WINAPI_CREATEDIB(DllStructGetData($tdib, "bmWidth"), DllStructGetData($tdib, "bmHeight"), 0x18)
                            If Not $hsource Then
                                $hbitmap = 0x0
                            EndIf
                            $hdc = _WinAPI_CreateCompatibleDC(0x0)
                            $hsv = _WinAPI_SelectObject($hdc, $hsource)
                            If _WINAPI_DRAWBITMAP($hdc, 0x0, 0x0, $hbitmap) Then
                                $hbitmap = $hsource
                            Else
                                $hbitmap = 0x0
                            EndIf
                            _WinAPI_SelectObject($hdc, $hsv)
                            _WinAPI_DeleteDC($hdc)
                        Else
                            $hbitmap = 0x0
                        EndIf
                        ContinueLoop
                    EndIf
                Case Else
            EndSwitch
            If (Not DllStructGetData($tdib, "bmBits")) Or (Not DllStructGetData($tdib, "biSizeImage")) Then
                If Not $hsource Then
                    $hbitmap = _WINAPI_COPYBITMAP($hbitmap)
                    $hsource = $hbitmap
                Else
                    $hbitmap = 0x0
                EndIf
            Else
                ExitLoop
            EndIf
        EndIf
    WEnd
    Local $hfile = 0x0, $ierror = 0x0, $iresult = 0x0
    Do
        If Not $hbitmap Then
            $ierror = 0x1
            ExitLoop
        EndIf
        Local $adata[0x4][0x2]
        $adata[0x0][0x0] = DllStructGetPtr($tbmp)
        $adata[0x0][0x1] = DllStructGetSize($tbmp)
        $adata[0x1][0x0] = DllStructGetPtr($tdib, "biSize")
        $adata[0x1][0x1] = 0x28
        $adata[0x2][0x1] = DllStructGetData($tdib, "biClrUsed") * 0x4
        Local $ttable = 0x0
        If $adata[0x2][0x1] Then
            $ttable = _WINAPI_GETDIBCOLORTABLE($hbitmap)
            If @error Or (@extended <> $adata[0x2][0x1] / 0x4) Then
                $ierror = @error + 0xa
                ExitLoop
            EndIf
        EndIf
        $adata[0x2][0x0] = DllStructGetPtr($ttable)
        $adata[0x3][0x0] = DllStructGetData($tdib, "bmBits")
        $adata[0x3][0x1] = DllStructGetData($tdib, "biSizeImage")
        DllStructSetData($tbmp, "bfType", 0x4d42)
        DllStructSetData($tbmp, "bfSize", $adata[0x0][0x1] + $adata[0x1][0x1] + $adata[0x2][0x1] + $adata[0x3][0x1])
        DllStructSetData($tbmp, "bfReserved1", 0x0)
        DllStructSetData($tbmp, "bfReserved2", 0x0)
        DllStructSetData($tbmp, "bfOffset", $adata[0x0][0x1] + $adata[0x1][0x1] + $adata[0x2][0x1])
        $hdc = _WinAPI_GetDC(0x0)
        If $ixpelspermeter = Default Then
            If Not DllStructGetData($tdib, "biXPelsPerMeter") Then
                DllStructSetData($tdib, "biXPelsPerMeter", _WinAPI_GetDeviceCaps($hdc, 0x8) / _WinAPI_GetDeviceCaps($hdc, 0x4) * 0x3e8)
            EndIf
        Else
            DllStructSetData($tdib, "biXPelsPerMeter", $ixpelspermeter)
        EndIf
        If $iypelspermeter = Default Then
            If Not DllStructGetData($tdib, "biYPelsPerMeter") Then
                DllStructSetData($tdib, "biYPelsPerMeter", _WinAPI_GetDeviceCaps($hdc, 0xa) / _WinAPI_GetDeviceCaps($hdc, 0x6) * 0x3e8)
            EndIf
        Else
            DllStructSetData($tdib, "biYPelsPerMeter", $iypelspermeter)
        EndIf
        _WinAPI_ReleaseDC(0x0, $hdc)
        $hfile = _WinAPI_CreateFile($sfilepath, 0x1, 0x4)
        If @error Then
            $ierror = @error + 0x14
            ExitLoop
        EndIf
        Local $ibytes
        For $i = 0x0 To 0x3
            If $adata[$i][0x1] Then
                If Not _WinAPI_WriteFile($hfile, $adata[$i][0x0], $adata[$i][0x1], $ibytes) Then
                    $ierror = @error + 0x1e
                    ExitLoop 0x2
                EndIf
            EndIf
        Next
        $iresult = 0x1
    Until 0x1
    If $hsource Then
        _WinAPI_DeleteObject($hsource)
    EndIf
    _WinAPI_CloseHandle($hfile)
    If Not $iresult Then
        FileDelete($sfilepath)
    EndIf
    Return SetError($ierror, 0x0, $iresult)
EndFunc   ;==>_WINAPI_SAVEHBITMAPTOFILE
Func _WINAPI_SAVEHICONTOFILE($sfilepath, Const ByRef $vicon, $bcompress = 0x0, $istart = 0x0, $iend = +0xffffffff)
    Local $aicon, $atemp, $icount = 0x1
    If Not IsArray($vicon) Then
        Dim $aicon[0x1] = [$vicon]
        Dim $atemp[0x1] = [0x0]
    Else
        If __CHECKERRORARRAYBOUNDS($vicon, $istart, $iend) Then Return SetError(@error + 0xa, @extended, 0x0)
        $icount = $iend - $istart + 0x1
        If $icount Then
            Dim $aicon[$icount]
            Dim $atemp[$icount]
            For $i = 0x0 To $icount + 0xffffffff
                $aicon[$i] = $vicon[$istart + $i]
                $atemp[$i] = 0x0
            Next
        EndIf
    EndIf
    Local $hfile = _WinAPI_CreateFile($sfilepath, 0x1, 0x4)
    If @error Then Return SetError(@error + 0x14, @extended, 0x0)
    Local $tico = DllStructCreate("align 1;ushort Reserved;ushort Type;ushort Count;byte Data[" & (0x10 * $icount) & "]")
    Local $ilength = DllStructGetSize($tico)
    Local $tbi = DllStructCreate($tagbitmapinfoheader)
    Local $tii = DllStructCreate($tagiconinfo)
    Local $tdib = DllStructCreate($tagdibsection)
    Local $idib = DllStructGetSize($tdib)
    Local $pdib = DllStructGetPtr($tdib)
    Local $ioffset = $ilength
    DllStructSetData($tbi, "biSize", 0x28)
    DllStructSetData($tbi, "biPlanes", 0x1)
    DllStructSetData($tbi, "biXPelsPerMeter", 0x0)
    DllStructSetData($tbi, "biYPelsPerMeter", 0x0)
    DllStructSetData($tbi, "biClrUsed", 0x0)
    DllStructSetData($tbi, "biClrImportant", 0x0)
    DllStructSetData($tico, "Reserved", 0x0)
    DllStructSetData($tico, "Type", 0x1)
    DllStructSetData($tico, "Count", $icount)
    Local $iresult = 0x0, $ierror = 0x0, $ibytes
    Local $ainfo[0x8], $acall, $pdata = 0x0, $iindex = 0x0
    Local $asize[0x2], $tdata = 0x0
    Do
        If Not _WinAPI_WriteFile($hfile, $tico, $ilength, $ibytes) Then
            $ierror = @error + 0x1e
            ExitLoop
        EndIf
        While $icount > $iindex
            $acall = DllCall("user32.dll", "bool", "GetIconInfo", "handle", $aicon[$iindex], "struct*", $tii)
            If @error Or Not $acall[0x0] Then
                $ierror = @error + 0x28
                ExitLoop 0x2
            EndIf
            For $i = 0x4 To 0x5
                $ainfo[$i] = _WINAPI_COPYIMAGE(DllStructGetData($tii, $i), 0x0, 0x0, 0x0, 0x2008)
                If _WinAPI_GetObject($ainfo[$i], $idib, $pdib) Then
                    $ainfo[$i + 0xfffffffc] = DllStructGetData($tdib, "biSizeImage")
                    $ainfo[$i + 0xfffffffe] = DllStructGetData($tdib, "bmBits")
                Else
                    $ierror = @error + 0x32
                EndIf
            Next
            $ainfo[0x6] = 0x28
            $ainfo[0x7] = DllStructGetData($tdib, "bmBitsPixel")
            Switch $ainfo[0x7]
                Case 0x10, 0x18
                Case 0x20
                    If Not _WINAPI_ISALPHABITMAP($ainfo[0x5]) Then
                        If Not $atemp[$iindex] Then
                            $aicon[$iindex] = _WINAPI_CREATE32BITHICON($aicon[$iindex])
                            $atemp[$iindex] = $aicon[$iindex]
                            If Not @error Then
                                ContinueLoop
                            Else
                                ContinueCase
                            EndIf
                        EndIf
                    Else
                        If ($ainfo[0x1] >= 0x100 * 0x100 * 0x4) And ($bcompress) Then
                            $ibytes = _WINAPI_COMPRESSBITMAPBITS($ainfo[0x5], $pdata)
                            If Not @error Then
                                $ainfo[0x0] = 0x0
                                $ainfo[0x1] = $ibytes
                                $ainfo[0x2] = 0x0
                                $ainfo[0x3] = $pdata
                                $ainfo[0x6] = 0x0
                            EndIf
                        EndIf
                    EndIf
                Case Else
                    $ierror = 0x3c
            EndSwitch
            If Not $ierror Then
                $tdata = DllStructCreate("byte Width;byte Height;byte ColorCount;byte Reserved;ushort Planes;ushort BitCount;long Size;long Offset", DllStructGetPtr($tico) + 0x6 + 0x10 * $iindex)
                DllStructSetData($tdata, "ColorCount", 0x0)
                DllStructSetData($tdata, "Reserved", 0x0)
                DllStructSetData($tdata, "Planes", 0x1)
                DllStructSetData($tdata, "BitCount", $ainfo[0x7])
                DllStructSetData($tdata, "Size", $ainfo[0x0] + $ainfo[0x1] + $ainfo[0x6])
                DllStructSetData($tdata, "Offset", $ioffset)
                For $i = 0x0 To 0x1
                    $asize[$i] = DllStructGetData($tdib, $i + 0x2)
                    If $asize[$i] < 0x100 Then
                        DllStructSetData($tdata, $i + 0x1, $asize[$i])
                    Else
                        DllStructSetData($tdata, $i + 0x1, 0x0)
                    EndIf
                Next
                DllStructSetData($tbi, "biWidth", $asize[0x0])
                DllStructSetData($tbi, "biHeight", 0x2 * $asize[0x1])
                DllStructSetData($tbi, "biBitCount", $ainfo[0x7])
                DllStructSetData($tbi, "biCompression", 0x0)
                DllStructSetData($tbi, "biSizeImage", $ainfo[0x0] + $ainfo[0x1])
                $ioffset += $ainfo[0x0] + $ainfo[0x1] + $ainfo[0x6]
                Do
                    If $ainfo[0x6] Then
                        If Not _WinAPI_WriteFile($hfile, $tbi, $ainfo[0x6], $ibytes) Then
                            $ierror = @error + 0x46
                            ExitLoop
                        EndIf
                        For $i = 0x1 To 0x0 Step +0xffffffff
                            If Not _WinAPI_WriteFile($hfile, $ainfo[$i + 0x2], $ainfo[$i], $ibytes) Then
                                $ierror = @error + 0x50
                                ExitLoop 0x2
                            EndIf
                        Next
                    Else
                        If Not _WinAPI_WriteFile($hfile, $ainfo[0x3], $ainfo[0x1], $ibytes) Then
                            $ierror = @error + 0x5a
                            ExitLoop
                        EndIf
                    EndIf
                Until 0x1
            EndIf
            For $i = 0x4 To 0x5
                _WinAPI_DeleteObject($ainfo[$i])
            Next
            If $ierror Then
                ExitLoop 0x2
            EndIf
            $iindex += 0x1
        WEnd
        $acall = DllCall("kernel32.dll", "bool", "SetFilePointerEx", "handle", $hfile, "int64", 0x0, "int64*", 0x0, "dword", 0x0)
        If @error Or Not $acall[0x0] Then
            $ierror = @error + 0x64
            ExitLoop
        EndIf
        If Not _WinAPI_WriteFile($hfile, $tico, $ilength, $ibytes) Then
            $ierror = @error + 0x6e
            ExitLoop
        EndIf
        $iresult = 0x1
    Until 0x1
    For $i = 0x0 To $icount + 0xffffffff
        If $atemp[$i] Then
            _WinAPI_DestroyIcon($atemp[$i])
        EndIf
    Next
    If $pdata Then
        __HEAPFREE($pdata)
    EndIf
    _WinAPI_CloseHandle($hfile)
    If Not $iresult Then
        FileDelete($sfilepath)
    EndIf
    Return SetError($ierror, 0x0, $iresult)
EndFunc   ;==>_WINAPI_SAVEHICONTOFILE
Func _WINAPI_SCALEWINDOWEXT($hdc, $ixnum, $ixdenom, $iynum, $iydenom)
    $__g_vext = DllStructCreate($tagsize)
    Local $acall = DllCall("gdi32.dll", "bool", "ScaleWindowExtEx", "handle", $hdc, "int", $ixnum, "int", $ixdenom, "int", $iynum, "int", $iydenom, "struct*", $__g_vext)
    If @error Then Return SetError(@error, @extended, False)
    Return $acall[0x0]
EndFunc   ;==>_WINAPI_SCALEWINDOWEXT
Func _WINAPI_SELECTCLIPPATH($hdc, $imode = 0x5)
    Local $acall = DllCall("gdi32.dll", "bool", "SelectClipPath", "handle", $hdc, "int", $imode)
    If @error Then Return SetError(@error, @extended, False)
    Return $acall[0x0]
EndFunc   ;==>_WINAPI_SELECTCLIPPATH
Func _WINAPI_SELECTCLIPRGN($hdc, $hrgn)
    Local $acall = DllCall("gdi32.dll", "int", "SelectClipRgn", "handle", $hdc, "handle", $hrgn)
    If @error Then Return SetError(@error, @extended, 0x0)
    Return $acall[0x0]
EndFunc   ;==>_WINAPI_SELECTCLIPRGN
Func _WINAPI_SETARCDIRECTION($hdc, $idirection)
    Local $acall = DllCall("gdi32.dll", "int", "SetArcDirection", "handle", $hdc, "int", $idirection)
    If @error Then Return SetError(@error, @extended, 0x0)
    Return $acall[0x0]
EndFunc   ;==>_WINAPI_SETARCDIRECTION
Func _WINAPI_SETBITMAPBITS($hbitmap, $isize, $pbits)
    Local $acall = DllCall("gdi32.dll", "long", "SetBitmapBits", "handle", $hbitmap, "dword", $isize, "struct*", $pbits)
    If @error Then Return SetError(@error, @extended, 0x0)
    Return $acall[0x0]
EndFunc   ;==>_WINAPI_SETBITMAPBITS
Func _WINAPI_SETBITMAPDIMENSIONEX($hbitmap, $iwidth, $iheight)
    $__g_vext = DllStructCreate($tagsize)
    Local $acall = DllCall("gdi32.dll", "bool", "SetBitmapDimensionEx", "handle", $hbitmap, "int", $iwidth, "int", $iheight, "struct*", $__g_vext)
    If @error Then Return SetError(@error, @extended, False)
    Return $acall[0x0]
EndFunc   ;==>_WINAPI_SETBITMAPDIMENSIONEX
Func _WINAPI_SETBOUNDSRECT($hdc, $iflags, $trect = 0x0)
    Local $acall = DllCall("gdi32.dll", "uint", "SetBoundsRect", "handle", $hdc, "struct*", $trect, "uint", $iflags)
    If @error Then Return SetError(@error, @extended, False)
    Return $acall[0x0]
EndFunc   ;==>_WINAPI_SETBOUNDSRECT
Func _WINAPI_SETBRUSHORG($hdc, $ix, $iy)
    $__g_vext = DllStructCreate($tagpoint)
    Local $acall = DllCall("gdi32.dll", "bool", "SetBrushOrgEx", "handle", $hdc, "int", $ix, "int", $iy, "struct*", $__g_vext)
    If @error Then Return SetError(@error, @extended, False)
    Return $acall[0x0]
EndFunc   ;==>_WINAPI_SETBRUSHORG
Func _WINAPI_SETCOLORADJUSTMENT($hdc, $tadjustment)
    Local $acall = DllCall("gdi32.dll", "bool", "SetColorAdjustment", "handle", $hdc, "struct*", $tadjustment)
    If @error Then Return SetError(@error, @extended, 0x0)
    Return $acall[0x0]
EndFunc   ;==>_WINAPI_SETCOLORADJUSTMENT
Func _WINAPI_SETDCBRUSHCOLOR($hdc, $irgb)
    Local $acall = DllCall("gdi32.dll", "dword", "SetDCBrushColor", "handle", $hdc, "dword", __RGB($irgb))
    If @error Or ($acall[0x0] = 0xffffffff) Then Return SetError(@error, @extended, +0xffffffff)
    Return __RGB($acall[0x0])
EndFunc   ;==>_WINAPI_SETDCBRUSHCOLOR
Func _WINAPI_SETDCPENCOLOR($hdc, $irgb)
    Local $acall = DllCall("gdi32.dll", "dword", "SetDCPenColor", "handle", $hdc, "dword", __RGB($irgb))
    If @error Or ($acall[0x0] = 0xffffffff) Then Return SetError(@error, @extended, +0xffffffff)
    Return __RGB($acall[0x0])
EndFunc   ;==>_WINAPI_SETDCPENCOLOR
Func _WINAPI_SETDEVICEGAMMARAMP($hdc, Const ByRef $aramp)
    If (UBound($aramp, $ubound_dimensions) <> 0x2) Or (UBound($aramp, $ubound_rows) <> 0x100) Or (UBound($aramp, $ubound_columns) <> 0x3) Then
        Return SetError(0xc, 0x0, 0x0)
    EndIf
    Local $tdata = DllStructCreate("ushort[256];ushort[256];ushort[256]")
    For $i = 0x0 To 0x2
        For $j = 0x0 To 0xff
            DllStructSetData($tdata, $i + 0x1, $aramp[$j][$i], $j + 0x1)
        Next
    Next
    Local $acall = DllCall("gdi32.dll", "bool", "SetDeviceGammaRamp", "handle", $hdc, "struct*", $tdata)
    If @error Then Return SetError(@error, @extended, False)
    Return $acall[0x0]
EndFunc   ;==>_WINAPI_SETDEVICEGAMMARAMP
Func _WINAPI_SETDIBCOLORTABLE($hbitmap, $tcolortable, $icolorcount)
    If $icolorcount > DllStructGetSize($tcolortable) / 0x4 Then Return SetError(0x1, 0x0, 0x0)
    Local $hdc = _WinAPI_CreateCompatibleDC(0x0)
    Local $hsv = _WinAPI_SelectObject($hdc, $hbitmap)
    Local $ierror = 0x0
    Local $acall = DllCall("gdi32.dll", "uint", "SetDIBColorTable", "handle", $hdc, "uint", 0x0, "uint", $icolorcount, "struct*", $tcolortable)
    If @error Then $ierror = @error
    _WinAPI_SelectObject($hdc, $hsv)
    _WinAPI_DeleteDC($hdc)
    If $ierror Then Return SetError($ierror, 0x0, 0x0)
    Return $acall[0x0]
EndFunc   ;==>_WINAPI_SETDIBCOLORTABLE
Func _WinAPI_SetDIBits($hdc, $hbitmap, $istartscan, $iscanlines, $pbits, $tbmi, $icoloruse = 0x0)
    Local $acall = DllCall("gdi32.dll", "int", "SetDIBits", "handle", $hdc, "handle", $hbitmap, "uint", $istartscan, "uint", $iscanlines, "struct*", $pbits, "struct*", $tbmi, "INT", $icoloruse)
    If @error Then Return SetError(@error, @extended, False)
    Return $acall[0x0]
EndFunc   ;==>_WINAPI_SETDIBITS
Func _WINAPI_SETDIBITSTODEVICE($hdc, $ixdest, $iydest, $iwidth, $iheight, $ixsrc, $iysrc, $istartscan, $iscanlines, $tbitmapinfo, $iusage, $pbits)
    Local $acall = DllCall("gdi32.dll", "int", "SetDIBitsToDevice", "handle", $hdc, "int", $ixdest, "int", $iydest, "dword", $iwidth, "dword", $iheight, "int", $ixsrc, "int", $iysrc, "uint", $istartscan, "uint", $iscanlines, "struct*", $pbits, "struct*", $tbitmapinfo, "uint", $iusage)
    If @error Or ($acall[0x0] = +0xffffffff) Then Return SetError(@error + 0xa, $acall[0x0], 0x0)
    Return $acall[0x0]
EndFunc   ;==>_WINAPI_SETDIBITSTODEVICE
Func _WINAPI_SETENHMETAFILEBITS($pdata, $ilength)
    Local $acall = DllCall("gdi32.dll", "handle", "SetEnhMetaFileBits", "uint", $ilength, "struct*", $pdata)
    If @error Then Return SetError(@error, @extended, 0x0)
    Return $acall[0x0]
EndFunc   ;==>_WINAPI_SETENHMETAFILEBITS
Func _WINAPI_SETGRAPHICSMODE($hdc, $imode)
    Local $acall = DllCall("gdi32.dll", "int", "SetGraphicsMode", "handle", $hdc, "int", $imode)
    If @error Then Return SetError(@error, @extended, 0x0)
    Return $acall[0x0]
EndFunc   ;==>_WINAPI_SETGRAPHICSMODE
Func _WINAPI_SETMAPMODE($hdc, $imode)
    Local $acall = DllCall("gdi32.dll", "int", "SetMapMode", "handle", $hdc, "int", $imode)
    If @error Then Return SetError(@error, @extended, 0x0)
    Return $acall[0x0]
EndFunc   ;==>_WINAPI_SETMAPMODE
Func _WINAPI_SETPIXEL($hdc, $ix, $iy, $irgb)
    Local $acall = DllCall("gdi32.dll", "bool", "SetPixelV", "handle", $hdc, "int", $ix, "int", $iy, "dword", __RGB($irgb))
    If @error Then Return SetError(@error, @extended, False)
    Return $acall[0x0]
EndFunc   ;==>_WINAPI_SETPIXEL
Func _WINAPI_SETPOLYFILLMODE($hdc, $imode = 0x1)
    Local $acall = DllCall("gdi32.dll", "int", "SetPolyFillMode", "handle", $hdc, "int", $imode)
    If @error Then Return SetError(@error, @extended, 0x0)
    Return $acall[0x0]
EndFunc   ;==>_WINAPI_SETPOLYFILLMODE
Func _WINAPI_SETRECTRGN($hrgn, $trect)
    Local $acall = DllCall("gdi32.dll", "bool", "SetRectRgn", "handle", $hrgn, "int", DllStructGetData($trect, 0x1), "int", DllStructGetData($trect, 0x2), "int", DllStructGetData($trect, 0x3), "int", DllStructGetData($trect, 0x4))
    If @error Then Return SetError(@error, @extended, False)
    Return $acall[0x0]
EndFunc   ;==>_WINAPI_SETRECTRGN
Func _WINAPI_SETROP2($hdc, $imode)
    Local $acall = DllCall("gdi32.dll", "int", "SetROP2", "handle", $hdc, "int", $imode)
    If @error Then Return SetError(@error, @extended, 0x0)
    Return $acall[0x0]
EndFunc   ;==>_WINAPI_SETROP2
Func _WINAPI_SETSTRETCHBLTMODE($hdc, $imode)
    Local $acall = DllCall("gdi32.dll", "int", "SetStretchBltMode", "handle", $hdc, "int", $imode)
    If @error Or Not $acall[0x0] Or ($acall[0x0] = 0x57) Then Return SetError(@error + 0xa, $acall[0x0], 0x0)
    Return $acall[0x0]
EndFunc   ;==>_WINAPI_SETSTRETCHBLTMODE
Func _WINAPI_SETTEXTALIGN($hdc, $imode = 0x0)
    Local $acall = DllCall("gdi32.dll", "uint", "SetTextAlign", "handle", $hdc, "uint", $imode)
    If @error Or ($acall[0x0] = 0xffffffff) Then Return SetError(@error, @extended, +0xffffffff)
    Return $acall[0x0]
EndFunc   ;==>_WINAPI_SETTEXTALIGN
Func _WINAPI_SETTEXTCHARACTEREXTRA($hdc, $icharextra)
    Local $acall = DllCall("gdi32.dll", "int", "SetTextCharacterExtra", "handle", $hdc, "int", $icharextra)
    If @error Or ($acall[0x0] = 0x80000000) Then Return SetError(@error, @extended, +0xffffffff)
    Return $acall[0x0]
EndFunc   ;==>_WINAPI_SETTEXTCHARACTEREXTRA
Func _WINAPI_SETTEXTJUSTIFICATION($hdc, $ibreakextra, $ibreakcount)
    Local $acall = DllCall("gdi32.dll", "bool", "SetTextJustification", "handle", $hdc, "int", $ibreakextra, "int", $ibreakcount)
    If @error Then Return SetError(@error, @extended, False)
    Return $acall[0x0]
EndFunc   ;==>_WINAPI_SETTEXTJUSTIFICATION
Func _WINAPI_SETUDFCOLORMODE($imode)
    $__g_irgbmode = Not ($imode = 0x0)
EndFunc   ;==>_WINAPI_SETUDFCOLORMODE
Func _WINAPI_SETWINDOWEXT($hdc, $ixextent, $iyextent)
    $__g_vext = DllStructCreate($tagsize)
    Local $acall = DllCall("gdi32.dll", "bool", "SetWindowExtEx", "handle", $hdc, "int", $ixextent, "int", $iyextent, "struct*", $__g_vext)
    If @error Then Return SetError(@error, @extended, False)
    Return $acall[0x0]
EndFunc   ;==>_WINAPI_SETWINDOWEXT
Func _WINAPI_SETWINDOWORG($hdc, $ix, $iy)
    $__g_vext = DllStructCreate($tagpoint)
    Local $acall = DllCall("gdi32.dll", "bool", "SetWindowOrgEx", "handle", $hdc, "int", $ix, "int", $iy, "struct*", $__g_vext)
    If @error Then Return SetError(@error, @extended, False)
    Return $acall[0x0]
EndFunc   ;==>_WINAPI_SETWINDOWORG
Func _WINAPI_SETWORLDTRANSFORM($hdc, ByRef $txform)
    Local $acall = DllCall("gdi32.dll", "bool", "SetWorldTransform", "handle", $hdc, "struct*", $txform)
    If @error Then Return SetError(@error, @extended, False)
    Return $acall[0x0]
EndFunc   ;==>_WINAPI_SETWORLDTRANSFORM
Func _WINAPI_STRETCHBLT($hdestdc, $ixdest, $iydest, $iwidthdest, $iheightdest, $hsrcdc, $ixsrc, $iysrc, $iwidthsrc, $iheightsrc, $irop)
    Local $acall = DllCall("gdi32.dll", "bool", "StretchBlt", "handle", $hdestdc, "int", $ixdest, "int", $iydest, "int", $iwidthdest, "int", $iheightdest, "hwnd", $hsrcdc, "int", $ixsrc, "int", $iysrc, "int", $iwidthsrc, "int", $iheightsrc, "dword", $irop)
    If @error Then Return SetError(@error, @extended, False)
    Return $acall[0x0]
EndFunc   ;==>_WINAPI_STRETCHBLT
Func _WINAPI_STRETCHDIBITS($hdestdc, $ixdest, $iydest, $iwidthdest, $iheightdest, $ixsrc, $iysrc, $iwidthsrc, $iheightsrc, $tbitmapinfo, $iusage, $pbits, $irop)
    Local $acall = DllCall("gdi32.dll", "int", "StretchDIBits", "handle", $hdestdc, "int", $ixdest, "int", $iydest, "int", $iwidthdest, "int", $iheightdest, "int", $ixsrc, "int", $iysrc, "int", $iwidthsrc, "int", $iheightsrc, "struct*", $pbits, "struct*", $tbitmapinfo, "uint", $iusage, "dword", $irop)
    If @error Or ($acall[0x0] = +0xffffffff) Then Return SetError(@error + 0xa, $acall[0x0], 0x0)
    Return $acall[0x0]
EndFunc   ;==>_WINAPI_STRETCHDIBITS
Func _WINAPI_STROKEANDFILLPATH($hdc)
    Local $acall = DllCall("gdi32.dll", "bool", "StrokeAndFillPath", "handle", $hdc)
    If @error Then Return SetError(@error, @extended, False)
    Return $acall[0x0]
EndFunc   ;==>_WINAPI_STROKEANDFILLPATH
Func _WINAPI_STROKEPATH($hdc)
    Local $acall = DllCall("gdi32.dll", "bool", "StrokePath", "handle", $hdc)
    If @error Then Return SetError(@error, @extended, False)
    Return $acall[0x0]
EndFunc   ;==>_WINAPI_STROKEPATH
Func _WINAPI_SUBTRACTRECT(ByRef $trect1, ByRef $trect2)
    Local $trect = DllStructCreate($tagrect)
    Local $acall = DllCall("user32.dll", "bool", "SubtractRect", "struct*", $trect, "struct*", $trect1, "struct*", $trect2)
    If @error Or Not $acall[0x0] Then Return SetError(@error + 0xa, @extended, 0x0)
    Return $trect
EndFunc   ;==>_WINAPI_SUBTRACTRECT
Func _WINAPI_TABBEDTEXTOUT($hdc, $ix, $iy, $stext, $atab = 0x0, $istart = 0x0, $iend = +0xffffffff, $iorigin = 0x0)
    Local $itab, $icount
    If Not IsArray($atab) Then
        If $atab Then
            $itab = $atab
            Dim $atab[0x1] = [$itab]
            $istart = 0x0
            $iend = 0x0
            $icount = 0x1
        Else
            $icount = 0x0
        EndIf
    Else
        $icount = 0x1
    EndIf
    Local $ttab = 0x0
    If $icount Then
        If __CHECKERRORARRAYBOUNDS($atab, $istart, $iend) Then Return SetError(@error + 0xa, @extended, 0x0)
        $icount = $iend - $istart + 0x1
        $ttab = DllStructCreate("uint[" & $icount & "]")
        $itab = 0x1
        For $i = $istart To $iend
            DllStructSetData($ttab, 0x1, $atab[$i], $itab)
            $itab += 0x1
        Next
    EndIf
    Local $acall = DllCall("user32.dll", "long", "TabbedTextOutW", "handle", $hdc, "int", $ix, "int", $iy, "wstr", $stext, "int", StringLen($stext), "int", $icount, "struct*", $ttab, "int", $iorigin)
    If @error Or Not $acall[0x0] Then Return SetError(@error, @extended, 0x0)
    $__g_vext = _WINAPI_CREATESIZE(_WinAPI_LoWord($acall[0x0]), _WinAPI_HiWord($acall[0x0]))
    Return 0x1
EndFunc   ;==>_WINAPI_TABBEDTEXTOUT
Func _WINAPI_TEXTOUT($hdc, $ix, $iy, $stext)
    Local $acall = DllCall("gdi32.dll", "bool", "TextOutW", "handle", $hdc, "int", $ix, "int", $iy, "wstr", $stext, "int", StringLen($stext))
    If @error Then Return SetError(@error, @extended, 0x0)
    Return $acall[0x0]
EndFunc   ;==>_WINAPI_TEXTOUT
Func _WINAPI_TRANSPARENTBLT($hdestdc, $ixdest, $iydest, $iwidthdest, $iheightdest, $hsrcdc, $ixsrc, $iysrc, $iwidthsrc, $iheightsrc, $irgb)
    Local $acall = DllCall("gdi32.dll", "bool", "GdiTransparentBlt", "handle", $hdestdc, "int", $ixdest, "int", $iydest, "int", $iwidthdest, "int", $iheightdest, "hwnd", $hsrcdc, "int", $ixsrc, "int", $iysrc, "int", $iwidthsrc, "int", $iheightsrc, "dword", __RGB($irgb))
    If @error Then Return SetError(@error, @extended, False)
    Return $acall[0x0]
EndFunc   ;==>_WINAPI_TRANSPARENTBLT
Func _WINAPI_UNIONRECT(ByRef $trect1, ByRef $trect2)
    Local $trect = DllStructCreate($tagrect)
    Local $acall = DllCall("user32.dll", "bool", "UnionRect", "struct*", $trect, "struct*", $trect1, "struct*", $trect2)
    If @error Or Not $acall[0x0] Then Return SetError(@error + 0xa, 0x0, 0x0)
    Return $trect
EndFunc   ;==>_WINAPI_UNIONRECT
Func _WINAPI_VALIDATERECT($hwnd, $trect = 0x0)
    Local $acall = DllCall("user32.dll", "bool", "ValidateRect", "hwnd", $hwnd, "struct*", $trect)
    If @error Then Return SetError(@error, @extended, 0x0)
    Return $acall[0x0]
EndFunc   ;==>_WINAPI_VALIDATERECT
Func _WINAPI_VALIDATERGN($hwnd, $hrgn = 0x0)
    Local $acall = DllCall("user32.dll", "bool", "ValidateRgn", "hwnd", $hwnd, "handle", $hrgn)
    If @error Then Return SetError(@error, @extended, 0x0)
    Return $acall[0x0]
EndFunc   ;==>_WINAPI_VALIDATERGN
Func _WINAPI_WIDENPATH($hdc)
    Local $acall = DllCall("gdi32.dll", "bool", "WidenPath", "handle", $hdc)
    If @error Then Return SetError(@error, @extended, 0x0)
    Return $acall[0x0]
EndFunc   ;==>_WINAPI_WIDENPATH
Func _WINAPI_WINDOWFROMDC($hdc)
    Local $acall = DllCall("user32.dll", "hwnd", "WindowFromDC", "handle", $hdc)
    If @error Then Return SetError(@error, @extended, 0x0)
    Return $acall[0x0]
EndFunc   ;==>_WINAPI_WINDOWFROMDC
#endregion Public Functions
#region Internal Functions
Func __ENUMDISPLAYMONITORSPROC($hmonitor, $hdc, $prect, $lparam)
    #forceref $hdc, $lparam
    __INC($__g_venum)
    $__g_venum[$__g_venum[0x0][0x0]][0x0] = $hmonitor
    If Not $prect Then
        $__g_venum[$__g_venum[0x0][0x0]][0x1] = 0x0
    Else
        $__g_venum[$__g_venum[0x0][0x0]][0x1] = DllStructCreate($tagrect)
        If Not _WINAPI_MOVEMEMORY(DllStructGetPtr($__g_venum[$__g_venum[0x0][0x0]][0x1]), $prect, 0x10) Then Return 0x0
    EndIf
    Return 0x1
EndFunc   ;==>__ENUMDISPLAYMONITORSPROC
Func __ENUMFONTFAMILIESPROC($pelfex, $pntmex, $ifonttype, $ppattern)
    Local $telfex = DllStructCreate($taglogfont & ";wchar FullName[64];wchar Style[32];wchar Script[32]", $pelfex)
    Local $tntmex = DllStructCreate($tagnewtextmetricex, $pntmex)
    Local $tpattern = DllStructCreate("uint;uint;ptr", $ppattern)
    If $ifonttype And Not BitAND($ifonttype, DllStructGetData($tpattern, 0x1)) Then
        Return 0x1
    EndIf
    If DllStructGetData($tpattern, 0x3) Then
        Local $acall = DllCall("shlwapi.dll", "bool", "PathMatchSpecW", "ptr", DllStructGetPtr($telfex, 0xe), "ptr", DllStructGetData($tpattern, 0x3))
        If Not @error Then
            If DllStructGetData($tpattern, 0x2) Then
                If $acall[0x0] Then
                    Return 0x1
                Else
                EndIf
            Else
                If $acall[0x0] Then
                Else
                    Return 0x1
                EndIf
            EndIf
        EndIf
    EndIf
    __INC($__g_venum)
    $__g_venum[$__g_venum[0x0][0x0]][0x0] = DllStructGetData($telfex, 0xe)
    $__g_venum[$__g_venum[0x0][0x0]][0x1] = DllStructGetData($telfex, 0x10)
    $__g_venum[$__g_venum[0x0][0x0]][0x2] = DllStructGetData($telfex, 0xf)
    $__g_venum[$__g_venum[0x0][0x0]][0x3] = DllStructGetData($telfex, 0x11)
    $__g_venum[$__g_venum[0x0][0x0]][0x4] = $ifonttype
    $__g_venum[$__g_venum[0x0][0x0]][0x5] = DllStructGetData($tntmex, 0x13)
    $__g_venum[$__g_venum[0x0][0x0]][0x6] = DllStructGetData($tntmex, 0x14)
    $__g_venum[$__g_venum[0x0][0x0]][0x7] = DllStructGetData($tntmex, 0x15)
    Return 0x1
EndFunc   ;==>__ENUMFONTFAMILIESPROC
Func __ENUMFONTSTYLESPROC($pelfex, $pntmex, $ifonttype, $pfn)
    #forceref $ifonttype
    Local $telfex = DllStructCreate($taglogfont & ";wchar FullName[64];wchar Style[32];wchar Script[32]", $pelfex)
    Local $tntmex = DllStructCreate($tagnewtextmetricex, $pntmex)
    Local $tfn = DllStructCreate("dword;wchar[64]", $pfn)
    If BitAND(DllStructGetData($tntmex, "ntmFlags"), 0x61) = DllStructGetData($tfn, 0x1) Then
        DllStructSetData($tfn, 0x2, DllStructGetData($telfex, "FullName"))
        Return 0x0
    Else
        Return 0x1
    EndIf
EndFunc   ;==>__ENUMFONTSTYLESPROC
#endregion Internal Functions
Global Const $create_breakaway_from_job = 0x1000000
Global Const $create_default_error_mode = 0x4000000
Global Const $create_new_console = 0x10
Global Const $create_new_process_group = 0x200
Global Const $create_no_window = 0x8000000
Global Const $create_protected_process = 0x40000
Global Const $create_preserve_code_authz_level = 0x2000000
Global Const $create_separate_wow_vdm = 0x800
Global Const $create_shared_wow_vdm = 0x1000
Global Const $create_suspended = 0x4
Global Const $create_unicode_environment = 0x400
Global Const $list_modules_32bit = 0x1
Global Const $list_modules_64bit = 0x2
Global Const $list_modules_all = 0x3
Global Const $list_modules_default = 0x0
Global Const $above_normal_priority_class = 0x8000
Global Const $below_normal_priority_class = 0x4000
Global Const $high_priority_class = 0x80
Global Const $idle_priority_class = 0x40
Global Const $normal_priority_class = 0x20
Global Const $realtime_priority_class = 0x100
Global Const $process_mode_background_begin = 0x100000
Global Const $process_mode_background_end = 0x200000
Global Const $mutex_modify_state = 0x1
Global Const $mutex_all_access = 0x1f0001
Global Const $job_object_assign_process = 0x1
Global Const $job_object_query = 0x4
Global Const $job_object_set_attributes = 0x2
Global Const $job_object_set_security_attributes = 0x10
Global Const $job_object_terminate = 0x8
Global Const $job_object_all_access = 0x1f001f
Global Const $job_object_limit_active_process = 0x8
Global Const $job_object_limit_affinity = 0x10
Global Const $job_object_limit_breakaway_ok = 0x800
Global Const $job_object_limit_die_on_unhandled_exception = 0x400
Global Const $job_object_limit_job_memory = 0x200
Global Const $job_object_limit_job_time = 0x4
Global Const $job_object_limit_kill_on_job_close = 0x2000
Global Const $job_object_limit_preserve_job_time = 0x40
Global Const $job_object_limit_priority_class = 0x20
Global Const $job_object_limit_process_memory = 0x100
Global Const $job_object_limit_process_time = 0x2
Global Const $job_object_limit_scheduling_class = 0x80
Global Const $job_object_limit_silent_breakaway_ok = 0x1000
Global Const $job_object_limit_workingset = 0x1
Global Const $job_object_uilimit_desktop = 0x40
Global Const $job_object_uilimit_displaysettings = 0x10
Global Const $job_object_uilimit_exitwindows = 0x80
Global Const $job_object_uilimit_globalatoms = 0x20
Global Const $job_object_uilimit_handles = 0x1
Global Const $job_object_uilimit_readclipboard = 0x2
Global Const $job_object_uilimit_systemparameters = 0x8
Global Const $job_object_uilimit_writeclipboard = 0x4
Global Const $job_object_security_filter_tokens = 0x8
Global Const $job_object_security_no_admin = 0x1
Global Const $job_object_security_only_token = 0x4
Global Const $job_object_security_restricted_token = 0x2
Global Const $job_object_terminate_at_end_of_job = 0x0
Global Const $job_object_post_at_end_of_job = 0x1
Global Const $semaphore_modify_state = 0x2
Global Const $semaphore_query_state = 0x1
Global Const $semaphore_all_access = 0x1f0003
Global Const $es_awaymode_required = 0x40
Global Const $es_continuous = 0x80000000
Global Const $es_display_required = 0x2
Global Const $es_system_required = 0x1
Global Const $es_user_present = 0x4
#region Global Variables and Constants
Global Const $tagio_counters = "struct;uint64 ReadOperationCount;uint64 WriteOperationCount;uint64 OtherOperationCount;uint64 ReadTransferCount;uint64 WriteTransferCount;uint64 OtherTransferCount;endstruct"
Global Const $tagjobobject_associate_completion_port = "ulong_ptr CompletionKey;ptr CompletionPort"
Global Const $tagjobobject_basic_accounting_information = "struct;int64 TotalUserTime;int64 TotalKernelTime;int64 ThisPeriodTotalUserTime;int64 ThisPeriodTotalKernelTime;dword TotalPageFaultCount;dword TotalProcesses;dword ActiveProcesses;dword TotalTerminatedProcesses;endstruct"
Global Const $tagjobobject_basic_and_io_accounting_information = $tagjobobject_basic_accounting_information & ";" & $tagio_counters
Global Const $tagjobobject_basic_limit_information = "struct;int64 PerProcessUserTimeLimit;int64 PerJobUserTimeLimit;dword LimitFlags;ulong_ptr MinimumWorkingSetSize;ulong_ptr MaximumWorkingSetSize;dword ActiveProcessLimit;ulong_ptr Affinity;dword PriorityClass;dword SchedulingClass;endstruct"
Global Const $tagjobobject_basic_process_id_list = "dword NumberOfAssignedProcesses;dword NumberOfProcessIdsInList"
Global Const $tagjobobject_basic_ui_restrictions = "dword UIRestrictionsClass"
Global Const $tagjobobject_end_of_job_time_information = "dword EndOfJobTimeAction"
Global Const $tagjobobject_extended_limit_information = $tagjobobject_basic_limit_information & ";" & $tagio_counters & ";ulong_ptr ProcessMemoryLimit;ulong_ptr JobMemoryLimit;ulong_ptr PeakProcessMemoryUsed;ulong_ptr PeakJobMemoryUsed"
Global Const $tagjobobject_group_information = ""
Global Const $tagjobobject_security_limit_information = "dword SecurityLimitFlags;ptr JobToken;ptr SidsToDisable;ptr PrivilegesToDelete;ptr RestrictedSids"
Global Const $tagmoduleinfo = "ptr BaseOfDll;dword SizeOfImage;ptr EntryPoint"
Global Const $tagprocessentry32 = "dword Size;dword Usage;dword ProcessID;ulong_ptr DefaultHeapID;dword ModuleID;dword Threads;dword ParentProcessID;long PriClassBase;dword Flags;wchar ExeFile[260]"
#endregion Global Variables and Constants
#region Functions list
#endregion Functions list
#region Public Functions
Func _WINAPI_ADJUSTTOKENPRIVILEGES($htoken, $aprivileges, $iattributes, ByRef $aadjust)
    $aadjust = 0x0
    If Not $aprivileges And IsNumber($aprivileges) Then Return 0x0
    Local $ttp1 = 0x0, $ttp2, $icount, $acall, $bdisable = False
    If $aprivileges = +0xffffffff Then
        $ttp2 = DllStructCreate("dword")
        $acall = DllCall("advapi32.dll", "bool", "AdjustTokenPrivileges", "handle", $htoken, "bool", 0x1, "ptr", 0x0, "dword", 0x0, "struct*", $ttp2, "dword*", 0x0)
        If @error Then Return SetError(@error, @extended, 0x0)
        Local $ilasterror = _WinAPI_GetLastError()
        Switch $ilasterror
            Case 0x7a
                $ttp2 = DllStructCreate("dword;dword[" & ($acall[0x6] / 0x4 + 0xffffffff) & "]")
                If @error Then
                    ContinueCase
                EndIf
            Case Else
                Return SetError(0xa, $ilasterror, 0x0)
        EndSwitch
        $bdisable = True
    Else
        Local $aprev = 0x0
        If Not IsArray($aprivileges) Then
            Dim $aprev[0x1][0x2]
            $aprev[0x0][0x0] = $aprivileges
            $aprev[0x0][0x1] = $iattributes
        Else
            If Not UBound($aprivileges, $ubound_columns) Then
                $icount = UBound($aprivileges)
                Dim $aprev[$icount][0x2]
                For $i = 0x0 To $icount + 0xffffffff
                    $aprev[$i][0x0] = $aprivileges[$i]
                    $aprev[$i][0x1] = $iattributes
                Next
            EndIf
        EndIf
        If IsArray($aprev) Then
            $aprivileges = $aprev
        EndIf
        Local $tagstruct = "dword;dword[" & (0x3 * UBound($aprivileges)) & "]"
        $ttp1 = DllStructCreate($tagstruct)
        $ttp2 = DllStructCreate($tagstruct)
        If @error Then Return SetError(@error + 0x14, 0x0, 0x0)
        DllStructSetData($ttp1, 0x1, UBound($aprivileges))
        For $i = 0x0 To UBound($aprivileges) + 0xffffffff
            DllStructSetData($ttp1, 0x2, $aprivileges[$i][0x1], 0x3 * $i + 0x3)
            $acall = DllCall("advapi32.dll", "bool", "LookupPrivilegeValueW", "ptr", 0x0, "wstr", $aprivileges[$i][0x0], "ptr", DllStructGetPtr($ttp1, 0x2) + 0xc * $i)
            If @error Or Not $acall[0x0] Then Return SetError(@error + 0x64, @extended, 0x0)
        Next
    EndIf
    $acall = DllCall("advapi32.dll", "bool", "AdjustTokenPrivileges", "handle", $htoken, "bool", $bdisable, "struct*", $ttp1, "dword", DllStructGetSize($ttp2), "struct*", $ttp2, "dword*", 0x0)
    If @error Or Not $acall[0x0] Then Return SetError(@error + 0xc8, @extended, 0x0)
    Local $iresult
    Switch _WinAPI_GetLastError()
        Case 0x514
            $iresult = 0x1
        Case Else
            $iresult = 0x0
    EndSwitch
    $icount = DllStructGetData($ttp2, 0x1)
    If $icount Then
        Local $tdata = DllStructCreate("wchar[128]")
        Dim $aprivileges[$icount][0x2]
        For $i = 0x0 To $icount + 0xffffffff
            $acall = DllCall("advapi32.dll", "bool", "LookupPrivilegeNameW", "ptr", 0x0, "ptr", DllStructGetPtr($ttp2, 0x2) + 0xc * $i, "struct*", $tdata, "dword*", 0x80)
            If @error Or Not $acall[0x0] Then Return SetError(@error + 0x12c, @extended, 0x0)
            $aprivileges[$i][0x1] = DllStructGetData($ttp2, 0x2, 0x3 * $i + 0x3)
            $aprivileges[$i][0x0] = DllStructGetData($tdata, 0x1)
        Next
        $aadjust = $aprivileges
    EndIf
    Return SetExtended($iresult, 0x1)
EndFunc   ;==>_WINAPI_ADJUSTTOKENPRIVILEGES
Func _WINAPI_ASSIGNPROCESSTOJOBOBJECT($hjob, $hprocess)
    Local $acall = DllCall("kernel32.dll", "bool", "AssignProcessToJobObject", "handle", $hjob, "handle", $hprocess)
    If @error Then Return SetError(@error, @extended, False)
    Return $acall[0x0]
EndFunc   ;==>_WINAPI_ASSIGNPROCESSTOJOBOBJECT
Func _WinAPI_AttachConsole($ipid = +0xffffffff)
    Local $acall = DllCall("kernel32.dll", "bool", "AttachConsole", "dword", $ipid)
    If @error Then Return SetError(@error, @extended, False)
    Return $acall[0x0]
EndFunc   ;==>_WINAPI_ATTACHCONSOLE
Func _WinAPI_AttachThreadInput($iattach, $iattachto, $battach)
    Local $acall = DllCall("user32.dll", "bool", "AttachThreadInput", "dword", $iattach, "dword", $iattachto, "bool", $battach)
    If @error Then Return SetError(@error, @extended, False)
    Return $acall[0x0]
EndFunc   ;==>_WINAPI_ATTACHTHREADINPUT
Func _WinAPI_CreateEvent($tattributes = 0x0, $bmanualreset = True, $binitialstate = True, $sname = "")
    If $sname = "" Then $sname = NULL
    Local $acall = DllCall("kernel32.dll", "handle", "CreateEventW", "struct*", $tattributes, "bool", $bmanualreset, "bool", $binitialstate, "wstr", $sname)
    If @error Then Return SetError(@error, @extended, 0x0)
    Local $ilasterror = _WinAPI_GetLastError()
    If $ilasterror Then Return SetExtended($ilasterror, 0x0)
    Return $acall[0x0]
EndFunc   ;==>_WINAPI_CREATEEVENT
Func _WINAPI_CREATEJOBOBJECT($sname = "", $tsecurity = 0x0)
    If Not StringStripWS($sname, $str_stripleading + $str_striptrailing) Then $sname = NULL
    Local $acall = DllCall("kernel32.dll", "handle", "CreateJobObjectW", "struct*", $tsecurity, "wstr", $sname)
    If @error Then Return SetError(@error, @extended, 0x0)
    Return $acall[0x0]
EndFunc   ;==>_WINAPI_CREATEJOBOBJECT
Func _WINAPI_CREATEMUTEX($smutex, $binitial = True, $tsecurity = 0x0)
    Local $acall = DllCall("kernel32.dll", "handle", "CreateMutexW", "struct*", $tsecurity, "bool", $binitial, "wstr", $smutex)
    If @error Then Return SetError(@error, @extended, 0x0)
    Return $acall[0x0]
EndFunc   ;==>_WINAPI_CREATEMUTEX
Func _WinAPI_CreateProcess($sappname, $scommand, $tsecurity, $tthread, $binherit, $iflags, $penviron, $sdir, $tstartupinfo, $tprocess)
    Local $tcommand = 0x0
    If $sappname = "" Then $sappname = NULL
    If $scommand <> "" Then
        $tcommand = DllStructCreate("wchar Text[" & 0x104 + 0x1 & "]")
        DllStructSetData($tcommand, "Text", $scommand)
    EndIf
    If $sdir = "" Then $sdir = NULL
    Local $acall = DllCall("kernel32.dll", "bool", "CreateProcessW", "wstr", $sappname, "struct*", $tcommand, "struct*", $tsecurity, "struct*", $tthread, "bool", $binherit, "dword", $iflags, "struct*", $penviron, "wstr", $sdir, "struct*", $tstartupinfo, "struct*", $tprocess)
    If @error Then Return SetError(@error, @extended, False)
    Return $acall[0x0]
EndFunc   ;==>_WINAPI_CREATEPROCESS
Func _WINAPI_CREATEPROCESSWITHTOKEN($sapp, $scmd, $iflags, $tstartupinfo, $tprocessinfo, $htoken, $ilogon = 0x0, $penvironment = 0x0, $sdir = "")
    If Not StringStripWS($sapp, $str_stripleading + $str_striptrailing) Then $sapp = NULL
    If Not StringStripWS($scmd, $str_stripleading + $str_striptrailing) Then $scmd = NULL
    If Not StringStripWS($sdir, $str_stripleading + $str_striptrailing) Then $sdir = NULL
    Local $acall = DllCall("advapi32.dll", "bool", "CreateProcessWithTokenW", "handle", $htoken, "dword", $ilogon, "wstr", $sapp, "wstr", $scmd, "dword", $iflags, "struct*", $penvironment, "wstr", $sdir, "struct*", $tstartupinfo, "struct*", $tprocessinfo)
    If @error Then Return SetError(@error, @extended, 0x0)
    Return $acall[0x0]
EndFunc   ;==>_WINAPI_CREATEPROCESSWITHTOKEN
Func _WINAPI_CREATESEMAPHORE($ssemaphore, $iinitial, $imaximum, $tsecurity = 0x0)
    Local $acall = DllCall("kernel32.dll", "handle", "CreateSemaphoreW", "struct*", $tsecurity, "long", $iinitial, "long", $imaximum, "wstr", $ssemaphore)
    If @error Then Return SetError(@error, @extended, 0x0)
    Return $acall[0x0]
EndFunc   ;==>_WINAPI_CREATESEMAPHORE
Func _WINAPI_DUPLICATETOKENEX($htoken, $iaccess, $ilevel, $itype = 0x1, $tsecurity = 0x0)
    Local $acall = DllCall("advapi32.dll", "bool", "DuplicateTokenEx", "handle", $htoken, "dword", $iaccess, "struct*", $tsecurity, "int", $ilevel, "int", $itype, "handle*", 0x0)
    If @error Or Not $acall[0x0] Then Return SetError(@error, @extended, 0x0)
    Return $acall[0x6]
EndFunc   ;==>_WINAPI_DUPLICATETOKENEX
Func _WINAPI_EMPTYWORKINGSET($ipid = 0x0)
    If Not $ipid Then $ipid = @AutoItPID
    Local $hprocess = DllCall("kernel32.dll", "handle", "OpenProcess", "dword", ((_WINAPI_GETVERSION() < 6) ? 0x500 : 0x1100), "bool", 0x0, "dword", $ipid)
    If @error Or Not $hprocess[0x0] Then Return SetError(@error + 0x14, @extended, 0x0)
    Local $acall = DllCall(@SystemDir & "\psapi.dll", "bool", "EmptyWorkingSet", "handle", $hprocess[0x0])
    If __CHECKERRORCLOSEHANDLE($acall, $hprocess[0x0]) Then Return SetError(@error, @extended, 0x0)
    Return 0x1
EndFunc   ;==>_WINAPI_EMPTYWORKINGSET
Func _WINAPI_ENUMCHILDPROCESS($ipid = 0x0)
    If Not $ipid Then $ipid = @AutoItPID
    Local $hsnapshot = DllCall("kernel32.dll", "handle", "CreateToolhelp32Snapshot", "dword", 0x2, "dword", 0x0)
    If @error Or ($hsnapshot[0x0] = Ptr(+0xffffffff)) Then Return SetError(@error + 0xa, @extended, 0x0)
    Local $tprocessentry32 = DllStructCreate($tagprocessentry32)
    Local $aret[0x65][0x2] = [[0x0]]
    $hsnapshot = $hsnapshot[0x0]
    DllStructSetData($tprocessentry32, "Size", DllStructGetSize($tprocessentry32))
    Local $acall = DllCall("kernel32.dll", "bool", "Process32FirstW", "handle", $hsnapshot, "struct*", $tprocessentry32)
    Local $ierror = @error
    While (Not @error) And ($acall[0x0])
        If DllStructGetData($tprocessentry32, "ParentProcessID") = $ipid Then
            __INC($aret)
            $aret[$aret[0x0][0x0]][0x0] = DllStructGetData($tprocessentry32, "ProcessID")
            $aret[$aret[0x0][0x0]][0x1] = DllStructGetData($tprocessentry32, "ExeFile")
        EndIf
        $acall = DllCall("kernel32.dll", "bool", "Process32NextW", "handle", $hsnapshot, "struct*", $tprocessentry32)
        $ierror = @error
    WEnd
    DllCall("kernel32.dll", "bool", "CloseHandle", "handle", $hsnapshot)
    If Not $aret[0x0][0x0] Then Return SetError($ierror + 0x14, 0x0, 0x0)
    __INC($aret, +0xffffffff)
    Return $aret
EndFunc   ;==>_WINAPI_ENUMCHILDPROCESS
Func _WINAPI_ENUMDEVICEDRIVERS()
    Local $acall = DllCall(@SystemDir & "\psapi.dll", "bool", "EnumDeviceDrivers", "ptr", 0x0, "dword", 0x0, "dword*", 0x0)
    If @error Or Not $acall[0x0] Then Return SetError(@error + 0xa, @extended, 0x0)
    Local $isize
    If @AutoItX64 Then
        $isize = $acall[0x3] / 0x8
    Else
        $isize = $acall[0x3] / 0x4
    EndIf
    Local $tdata = DllStructCreate("ptr[" & $isize & "]")
    $acall = DllCall(@SystemDir & "\psapi.dll", "bool", "EnumDeviceDrivers", "struct*", $tdata, "dword", DllStructGetSize($tdata), "dword*", 0x0)
    If @error Or Not $acall[0x0] Then Return SetError(@error + 0x14, @extended, 0x0)
    Local $aret[$isize + 0x1] = [$isize]
    For $i = 0x1 To $isize
        $aret[$i] = DllStructGetData($tdata, 0x1, $i)
    Next
    Return $aret
EndFunc   ;==>_WINAPI_ENUMDEVICEDRIVERS
Func _WINAPI_ENUMPROCESSHANDLES($ipid = 0x0, $itype = 0x0)
    If Not $ipid Then $ipid = @AutoItPID
    Local $aret[0x65][0x4] = [[0x0]]
    Local $tagsystem_handle_table_entry_info = "ulong ProcessId;byte ObjectTypeNumber;byte Flags;ushort Handle;ptr Object;ulong GrantedAccess"
    Local $thandle = DllStructCreate($tagsystem_handle_table_entry_info)
    Local $ientrysize = DllStructGetSize($thandle)
    Local $imaxentries = 0x3ffff
    Local $tshi = DllStructCreate("ulong_ptr NumberOfHandles;byte Data[" & ($imaxentries + 0x1) * $ientrysize & "]")
    Local $acall = DllCall("ntdll.dll", "long", "ZwQuerySystemInformation", "uint", 0x10, "struct*", $tshi, "ulong", DllStructGetSize($tshi), "ulong*", 0x0)
    If @error Then Return SetError(@error, @extended, 0x0)
    If $acall[0x0] Then Return SetError(0xa, $acall[0x0], 0x0)
    Local $pdata = DllStructGetPtr($tshi, "Data")
    Local $i, $inumberofhandles = DllStructGetData($tshi, "NumberOfHandles")
    For $i = 0x1 To $inumberofhandles
        If $i > $imaxentries Then ExitLoop
        $thandle = DllStructCreate($tagsystem_handle_table_entry_info, $pdata + ($i + 0xffffffff) * $ientrysize)
        If (DllStructGetData($thandle, "ProcessId") = $ipid) And ((Not $itype) Or ($itype = DllStructGetData($thandle, "ObjectTypeNumber"))) Then
            __INC($aret)
            $aret[$aret[0x0][0x0]][0x0] = Ptr(DllStructGetData($thandle, "Handle"))
            $aret[$aret[0x0][0x0]][0x1] = DllStructGetData($thandle, "ObjectTypeNumber")
            $aret[$aret[0x0][0x0]][0x2] = DllStructGetData($thandle, "Flags")
            $aret[$aret[0x0][0x0]][0x3] = DllStructGetData($thandle, "GrantedAccess")
        EndIf
    Next
    If Not $aret[0x0][0x0] Then Return SetError(0xb, 0x0, 0x0)
    __INC($aret, +0xffffffff)
    If $i < $inumberofhandles Then Return SetExtended($inumberofhandles, $aret)
    Return $aret
EndFunc   ;==>_WINAPI_ENUMPROCESSHANDLES
Func _WINAPI_ENUMPROCESSMODULES($ipid = 0x0, $iflag = 0x0)
    If Not $ipid Then $ipid = @AutoItPID
    Local $hprocess = DllCall("kernel32.dll", "handle", "OpenProcess", "dword", ((_WINAPI_GETVERSION() < 6) ? 0x410 : 0x1010), "bool", 0x0, "dword", $ipid)
    If @error Or Not $hprocess[0x0] Then Return SetError(@error + 0x14, @extended, 0x0)
    Local $icount, $acall, $ierror = 0x0
    Do
        If _WINAPI_GETVERSION() >= 6 Then
            $acall = DllCall(@SystemDir & "\psapi.dll", "bool", "EnumProcessModulesEx", "handle", $hprocess[0x0], "ptr", 0x0, "dword", 0x0, "dword*", 0x0, "dword", $iflag)
        Else
            $acall = DllCall(@SystemDir & "\psapi.dll", "bool", "EnumProcessModules", "handle", $hprocess[0x0], "ptr", 0x0, "dword", 0x0, "dword*", 0x0)
        EndIf
        If @error Or Not $acall[0x0] Then
            $ierror = @error + 0xa
            ExitLoop
        EndIf
        If @AutoItX64 Then
            $icount = $acall[0x4] / 0x8
        Else
            $icount = $acall[0x4] / 0x4
        EndIf
        Local $tptr = DllStructCreate("ptr[" & $icount & "]")
        If @error Then
            $ierror = @error + 0x1e
            ExitLoop
        EndIf
        If _WINAPI_GETVERSION() >= 6 Then
            $acall = DllCall(@SystemDir & "\psapi.dll", "bool", "EnumProcessModulesEx", "handle", $hprocess[0x0], "struct*", $tptr, "dword", DllStructGetSize($tptr), "dword*", 0x0, "dword", $iflag)
        Else
            $acall = DllCall(@SystemDir & "\psapi.dll", "bool", "EnumProcessModules", "handle", $hprocess[0x0], "struct*", $tptr, "dword", DllStructGetSize($tptr), "dword*", 0x0)
        EndIf
        If @error Or Not $acall[0x0] Then
            $ierror = @error + 0x28
            ExitLoop
        EndIf
        Local $aret[$icount + 0x1][0x2] = [[$icount]]
        For $i = 0x1 To $icount
            $aret[$i][0x0] = DllStructGetData($tptr, 0x1, $i)
            $aret[$i][0x1] = _WINAPI_GETMODULEFILENAMEEX($hprocess[0x0], $aret[$i][0x0])
        Next
    Until 0x1
    DllCall("kernel32.dll", "bool", "CloseHandle", "handle", $hprocess[0x0])
    If $ierror Then Return SetError($ierror, 0x0, 0x0)
    Return $aret
EndFunc   ;==>_WINAPI_ENUMPROCESSMODULES
Func _WINAPI_ENUMPROCESSTHREADS($ipid = 0x0)
    If Not $ipid Then $ipid = @AutoItPID
    Local $hsnapshot = DllCall("kernel32.dll", "handle", "CreateToolhelp32Snapshot", "dword", 0x4, "dword", 0x0)
    If @error Or Not $hsnapshot[0x0] Then Return SetError(@error + 0xa, @extended, 0x0)
    Local Const $tagthreadentry32 = "dword Size;dword Usage;dword ThreadID;dword OwnerProcessID;long BasePri;long DeltaPri;dword Flags"
    Local $tthreadentry32 = DllStructCreate($tagthreadentry32)
    Local $aret[0x65] = [0x0]
    $hsnapshot = $hsnapshot[0x0]
    DllStructSetData($tthreadentry32, "Size", DllStructGetSize($tthreadentry32))
    Local $acall = DllCall("kernel32.dll", "bool", "Thread32First", "handle", $hsnapshot, "struct*", $tthreadentry32)
    While Not @error And $acall[0x0]
        If DllStructGetData($tthreadentry32, "OwnerProcessID") = $ipid Then
            __INC($aret)
            $aret[$aret[0x0]] = DllStructGetData($tthreadentry32, "ThreadID")
        EndIf
        $acall = DllCall("kernel32.dll", "bool", "Thread32Next", "handle", $hsnapshot, "struct*", $tthreadentry32)
    WEnd
    DllCall("kernel32.dll", "bool", "CloseHandle", "handle", $hsnapshot)
    If Not $aret[0x0] Then Return SetError(0x1, 0x0, 0x0)
    __INC($aret, +0xffffffff)
    Return $aret
EndFunc   ;==>_WINAPI_ENUMPROCESSTHREADS
Func _WINAPI_ENUMPROCESSWINDOWS($ipid = 0x0, $bvisible = True)
    Local $athreads = _WINAPI_ENUMPROCESSTHREADS($ipid)
    If @error Then Return SetError(@error, @extended, 0x0)
    Local $henumproc = DllCallbackRegister("__EnumWindowsProc", "bool", "hwnd;lparam")
    Dim $__g_venum[0x65][0x2] = [[0x0]]
    For $i = 0x1 To $athreads[0x0]
        DllCall("user32.dll", "bool", "EnumThreadWindows", "dword", $athreads[$i], "ptr", DllCallbackGetPtr($henumproc), "lparam", $bvisible)
        If @error Then
            ExitLoop
        EndIf
    Next
    DllCallbackFree($henumproc)
    If Not $__g_venum[0x0][0x0] Then Return SetError(0xb, 0x0, 0x0)
    __INC($__g_venum, +0xffffffff)
    Return $__g_venum
EndFunc   ;==>_WINAPI_ENUMPROCESSWINDOWS
Func _WinAPI_FatalAppExit($smessage)
    DllCall("kernel32.dll", "none", "FatalAppExitW", "uint", 0x0, "wstr", $smessage)
    If @error Then Return SetError(@error, @extended)
EndFunc   ;==>_WINAPI_FATALAPPEXIT
Func _WINAPI_GETCURRENTPROCESSEXPLICITAPPUSERMODELID()
    Local $acall = DllCall("shell32.dll", "long", "GetCurrentProcessExplicitAppUserModelID", "ptr*", 0x0)
    If @error Then Return SetError(@error, @extended, "")
    If $acall[0x0] Then Return SetError(0xa, $acall[0x0], "")
    Local $sid = _WINAPI_GETSTRING($acall[0x1])
    _WINAPI_COTASKMEMFREE($acall[0x1])
    Return $sid
EndFunc   ;==>_WINAPI_GETCURRENTPROCESSEXPLICITAPPUSERMODELID
Func _WinAPI_GetCurrentProcessID()
    Local $acall = DllCall("kernel32.dll", "dword", "GetCurrentProcessId")
    If @error Then Return SetError(@error, @extended, 0x0)
    Return $acall[0x0]
EndFunc   ;==>_WINAPI_GETCURRENTPROCESSID
Func _WinAPI_GetCurrentThread()
    Local $acall = DllCall("kernel32.dll", "handle", "GetCurrentThread")
    If @error Then Return SetError(@error, @extended, 0x0)
    Return $acall[0x0]
EndFunc   ;==>_WINAPI_GETCURRENTTHREAD
Func _WinAPI_GetCurrentThreadId()
    Local $acall = DllCall("kernel32.dll", "dword", "GetCurrentThreadId")
    If @error Then Return SetError(@error, @extended, 0x0)
    Return $acall[0x0]
EndFunc   ;==>_WINAPI_GETCURRENTTHREADID
Func _WINAPI_GETDEVICEDRIVERBASENAME($pdriver)
    Local $acall = DllCall(@SystemDir & "\psapi.dll", "dword", "GetDeviceDriverBaseNameW", "ptr", $pdriver, "wstr", "", "dword", 0x1000)
    If @error Then Return SetError(@error, @extended, "")
    Return $acall[0x2]
EndFunc   ;==>_WINAPI_GETDEVICEDRIVERBASENAME
Func _WINAPI_GETDEVICEDRIVERFILENAME($pdriver)
    Local $acall = DllCall(@SystemDir & "\psapi.dll", "dword", "GetDeviceDriverFileNameW", "ptr", $pdriver, "wstr", "", "dword", 0x1000)
    If @error Then Return SetError(@error, @extended, "")
    Return $acall[0x2]
EndFunc   ;==>_WINAPI_GETDEVICEDRIVERFILENAME
Func _WINAPI_GETEXITCODEPROCESS($hprocess)
    Local $acall = DllCall("kernel32.dll", "bool", "GetExitCodeProcess", "handle", $hprocess, "dword*", 0x0)
    If @error Or Not $acall[0x0] Then Return SetError(@error, @extended, 0x0)
    Return $acall[0x2]
EndFunc   ;==>_WINAPI_GETEXITCODEPROCESS
Func _WinAPI_GetGuiResources($iflag = 0x0, $hprocess = +0xffffffff)
    If $hprocess = +0xffffffff Then $hprocess = _WinAPI_GetCurrentProcess()
    Local $acall = DllCall("user32.dll", "dword", "GetGuiResources", "handle", $hprocess, "dword", $iflag)
    If @error Then Return SetError(@error, @extended, 0x0)
    Return $acall[0x0]
EndFunc   ;==>_WINAPI_GETGUIRESOURCES
Func _WINAPI_GETMODULEFILENAMEEX($hprocess, $hmodule = 0x0)
    Local $acall = DllCall(@SystemDir & "\psapi.dll", "dword", "GetModuleFileNameExW", "handle", $hprocess, "handle", $hmodule, "wstr", "", "int", 0x1000)
    If @error Or Not $acall[0x0] Then Return SetError(@error + 0xa, @extended, "")
    Return $acall[0x3]
EndFunc   ;==>_WINAPI_GETMODULEFILENAMEEX
Func _WINAPI_GETMODULEINFORMATION($hprocess, $hmodule = 0x0)
    Local $tmoduleinfo = DllStructCreate($tagmoduleinfo)
    Local $acall = DllCall(@SystemDir & "\psapi.dll", "bool", "GetModuleInformation", "handle", $hprocess, "handle", $hmodule, "struct*", $tmoduleinfo, "dword", DllStructGetSize($tmoduleinfo))
    If @error Or Not $acall[0x0] Then Return SetError(@error + 0xa, @extended, 0x0)
    Return $tmoduleinfo
EndFunc   ;==>_WINAPI_GETMODULEINFORMATION
Func _WINAPI_GETPARENTPROCESS($ipid = 0x0)
    If Not $ipid Then $ipid = @AutoItPID
    Local $hsnapshot = DllCall("kernel32.dll", "handle", "CreateToolhelp32Snapshot", "dword", 0x2, "dword", 0x0)
    If @error Or Not $hsnapshot[0x0] Then Return SetError(@error + 0xa, @extended, 0x0)
    Local $tprocessentry32 = DllStructCreate($tagprocessentry32)
    Local $iresult = 0x0
    $hsnapshot = $hsnapshot[0x0]
    DllStructSetData($tprocessentry32, "Size", DllStructGetSize($tprocessentry32))
    Local $acall = DllCall("kernel32.dll", "bool", "Process32FirstW", "handle", $hsnapshot, "struct*", $tprocessentry32)
    Local $ierror = @error
    While (Not @error) And ($acall[0x0])
        If DllStructGetData($tprocessentry32, "ProcessID") = $ipid Then
            $iresult = DllStructGetData($tprocessentry32, "ParentProcessID")
            ExitLoop
        EndIf
        $acall = DllCall("kernel32.dll", "bool", "Process32NextW", "handle", $hsnapshot, "struct*", $tprocessentry32)
        $ierror = @error
    WEnd
    DllCall("kernel32.dll", "bool", "CloseHandle", "handle", $hsnapshot)
    If Not $iresult Then Return SetError($ierror, 0x0, 0x0)
    Return $iresult
EndFunc   ;==>_WINAPI_GETPARENTPROCESS
Func _WINAPI_GETPRIORITYCLASS($ipid = 0x0)
    If Not $ipid Then $ipid = @AutoItPID
    Local $hprocess = DllCall("kernel32.dll", "handle", "OpenProcess", "dword", ((_WINAPI_GETVERSION() < 6) ? 0x400 : 0x1000), "bool", 0x0, "dword", $ipid)
    If @error Or Not $hprocess[0x0] Then Return SetError(@error + 0x14, @extended, 0x0)
    Local $ierror = 0x0
    Local $acall = DllCall("kernel32.dll", "dword", "GetPriorityClass", "handle", $hprocess[0x0])
    If @error Then $ierror = @error
    DllCall("kernel32.dll", "bool", "CloseHandle", "handle", $hprocess[0x0])
    If $ierror Then Return SetError($ierror, 0x0, 0x0)
    Return $acall[0x0]
EndFunc   ;==>_WINAPI_GETPRIORITYCLASS
Func _WinAPI_GetProcessAffinityMask($hprocess)
    Local $acall = DllCall("kernel32.dll", "bool", "GetProcessAffinityMask", "handle", $hprocess, "dword_ptr*", 0x0, "dword_ptr*", 0x0)
    If @error Or Not $acall[0x0] Then Return SetError(@error + 0xa, @extended, 0x0)
    Local $amask[0x3]
    $amask[0x0] = True
    $amask[0x1] = $acall[0x2]
    $amask[0x2] = $acall[0x3]
    Return $amask
EndFunc   ;==>_WINAPI_GETPROCESSAFFINITYMASK
Func _WINAPI_GETPROCESSCOMMANDLINE($ipid = 0x0)
    If Not $ipid Then $ipid = @AutoItPID
    Local $hprocess = DllCall("kernel32.dll", "handle", "OpenProcess", "dword", ((_WINAPI_GETVERSION() < 6) ? 0x410 : 0x1010), "bool", 0x0, "dword", $ipid)
    If @error Or Not $hprocess[0x0] Then Return SetError(@error + 0x14, @extended, "")
    $hprocess = $hprocess[0x0]
    Local $tpbi = DllStructCreate("ulong_ptr ExitStatus;ptr PebBaseAddress;ulong_ptr AffinityMask;ulong_ptr BasePriority;ulong_ptr UniqueProcessId;ulong_ptr InheritedFromUniqueProcessId")
    Local $tpeb = DllStructCreate("byte InheritedAddressSpace;byte ReadImageFileExecOptions;byte BeingDebugged;byte Spare;ptr Mutant;ptr ImageBaseAddress;ptr LoaderData;ptr ProcessParameters;ptr SubSystemData;ptr ProcessHeap;ptr FastPebLock;ptr FastPebLockRoutine;ptr FastPebUnlockRoutine;ulong EnvironmentUpdateCount;ptr KernelCallbackTable;ptr EventLogSection;ptr EventLog;ptr FreeList;ulong TlsExpansionCounter;ptr TlsBitmap;ulong TlsBitmapBits[2];ptr ReadOnlySharedMemoryBase;ptr ReadOnlySharedMemoryHeap;ptr ReadOnlyStaticServerData;ptr AnsiCodePageData;ptr OemCodePageData;ptr UnicodeCaseTableData;ulong NumberOfProcessors;ulong NtGlobalFlag;byte Spare2[4];int64 CriticalSectionTimeout;ulong HeapSegmentReserve;ulong HeapSegmentCommit;ulong HeapDeCommitTotalFreeThreshold;ulong HeapDeCommitFreeBlockThreshold;ulong NumberOfHeaps;ulong MaximumNumberOfHeaps;ptr ProcessHeaps;ptr GdiSharedHandleTable;ptr ProcessStarterHelper;ptr GdiDCAttributeList;ptr LoaderLock;ulong OSMajorVersion;ulong OSMinorVersion;ulong OSBuildNumber;ulong OSPlatformId;ulong ImageSubSystem;ulong ImageSubSystemMajorVersion;ulong ImageSubSystemMinorVersion;ulong GdiHandleBuffer[34];ulong PostProcessInitRoutine;ulong TlsExpansionBitmap;byte TlsExpansionBitmapBits[128];ulong SessionId")
    Local $tupp = DllStructCreate("ulong AllocationSize;ulong ActualSize;ulong Flags;ulong Unknown1;ushort LengthUnknown2;ushort MaxLengthUnknown2;ptr Unknown2;ptr InputHandle;ptr OutputHandle;ptr ErrorHandle;ushort LengthCurrentDirectory;ushort MaxLengthCurrentDirectory;ptr CurrentDirectory;ptr CurrentDirectoryHandle;ushort LengthSearchPaths;ushort MaxLengthSearchPaths;ptr SearchPaths;ushort LengthApplicationName;ushort MaxLengthApplicationName;ptr ApplicationName;ushort LengthCommandLine;ushort MaxLengthCommandLine;ptr CommandLine;ptr EnvironmentBlock;ulong Unknown[9];ushort LengthUnknown3;ushort MaxLengthUnknown3;ptr Unknown3;ushort LengthUnknown4;ushort MaxLengthUnknown4;ptr Unknown4;ushort LengthUnknown5;ushort MaxLengthUnknown5;ptr Unknown5")
    Local $tcmd
    Local $acall, $ierror = 0x0
    Do
        $acall = DllCall("ntdll.dll", "long", "NtQueryInformationProcess", "handle", $hprocess, "ulong", 0x0, "struct*", $tpbi, "ulong", DllStructGetSize($tpbi), "ulong*", 0x0)
        If @error Or $acall[0x0] Then
            $ierror = @error + 0x1e
            ExitLoop
        EndIf
        $acall = DllCall("kernel32.dll", "bool", "ReadProcessMemory", "handle", $hprocess, "ptr", DllStructGetData($tpbi, "PebBaseAddress"), "struct*", $tpeb, "ulong_ptr", DllStructGetSize($tpeb), "ulong_ptr*", 0x0)
        If @error Or Not $acall[0x0] Or (Not $acall[0x5]) Then
            $ierror = @error + 0x28
            ExitLoop
        EndIf
        $acall = DllCall("kernel32.dll", "bool", "ReadProcessMemory", "handle", $hprocess, "ptr", DllStructGetData($tpeb, "ProcessParameters"), "struct*", $tupp, "ulong_ptr", DllStructGetSize($tupp), "ulong_ptr*", 0x0)
        If @error Or Not $acall[0x0] Or (Not $acall[0x5]) Then
            $ierror = @error + 0x32
            ExitLoop
        EndIf
        $tcmd = DllStructCreate("byte[" & DllStructGetData($tupp, "MaxLengthCommandLine") & "]")
        If @error Then
            $ierror = @error + 0x3c
            ExitLoop
        EndIf
        $acall = DllCall("kernel32.dll", "bool", "ReadProcessMemory", "handle", $hprocess, "ptr", DllStructGetData($tupp, "CommandLine"), "struct*", $tcmd, "ulong_ptr", DllStructGetSize($tcmd), "ulong_ptr*", 0x0)
        If @error Or Not $acall[0x0] Or (Not $acall[0x5]) Then
            $ierror = @error + 0x46
            ExitLoop
        EndIf
    Until 0x1
    DllCall("kernel32.dll", "bool", "CloseHandle", "handle", $hprocess)
    If $ierror Then Return SetError($ierror, 0x0, "")
    Return StringStripWS(_WINAPI_PATHGETARGS(_WINAPI_GETSTRING(DllStructGetPtr($tcmd, 0x1))), $str_stripleading + $str_striptrailing)
EndFunc   ;==>_WINAPI_GETPROCESSCOMMANDLINE
Func _WINAPI_GETPROCESSFILENAME($ipid = 0x0)
    If Not $ipid Then $ipid = @AutoItPID
    Local $hprocess = DllCall("kernel32.dll", "handle", "OpenProcess", "dword", ((_WINAPI_GETVERSION() < 6) ? 0x410 : 0x1010), "bool", 0x0, "dword", $ipid)
    If @error Or Not $hprocess[0x0] Then Return SetError(@error + 0x14, @extended, "")
    Local $spath = _WINAPI_GETMODULEFILENAMEEX($hprocess[0x0])
    Local $ierror = @error
    DllCall("kernel32.dll", "bool", "CloseHandle", "handle", $hprocess[0x0])
    If $ierror Then Return SetError(@error, 0x0, "")
    Return $spath
EndFunc   ;==>_WINAPI_GETPROCESSFILENAME
Func _WINAPI_GETPROCESSHANDLECOUNT($ipid = 0x0)
    If Not $ipid Then $ipid = @AutoItPID
    Local $hprocess = DllCall("kernel32.dll", "handle", "OpenProcess", "dword", ((_WINAPI_GETVERSION() < 6) ? 0x400 : 0x1000), "bool", 0x0, "dword", $ipid)
    If @error Or Not $hprocess[0x0] Then Return SetError(@error + 0x14, @extended, 0x0)
    Local $acall = DllCall("kernel32.dll", "bool", "GetProcessHandleCount", "handle", $hprocess[0x0], "dword*", 0x0)
    If __CHECKERRORCLOSEHANDLE($acall, $hprocess[0x0]) Then Return SetError(@error, @extended, 0x0)
    Return $acall[0x2]
EndFunc   ;==>_WINAPI_GETPROCESSHANDLECOUNT
Func _WINAPI_GETPROCESSID($hprocess)
    Local $acall = DllCall("kernel32.dll", "dword", "GetProcessId", "handle", $hprocess)
    If @error Then Return SetError(@error, @extended, 0x0)
    Return $acall[0x0]
EndFunc   ;==>_WINAPI_GETPROCESSID
Func _WINAPI_GETPROCESSIOCOUNTERS($ipid = 0x0)
    If Not $ipid Then $ipid = @AutoItPID
    Local $hprocess = DllCall("kernel32.dll", "handle", "OpenProcess", "dword", ((_WINAPI_GETVERSION() < 6) ? 0x400 : 0x1000), "bool", 0x0, "dword", $ipid)
    If @error Or Not $hprocess[0x0] Then Return SetError(@error + 0x14, @extended, 0x0)
    Local $tio_counters = DllStructCreate("uint64[6]")
    Local $acall = DllCall("kernel32.dll", "bool", "GetProcessIoCounters", "handle", $hprocess[0x0], "struct*", $tio_counters)
    If __CHECKERRORCLOSEHANDLE($acall, $hprocess[0x0]) Then Return SetError(@error, @extended, 0x0)
    Local $aret[0x6]
    For $i = 0x0 To 0x5
        $aret[$i] = DllStructGetData($tio_counters, 0x1, $i + 0x1)
    Next
    Return $aret
EndFunc   ;==>_WINAPI_GETPROCESSIOCOUNTERS
Func _WINAPI_GETPROCESSMEMORYINFO($ipid = 0x0)
    If Not $ipid Then $ipid = @AutoItPID
    Local $hprocess = DllCall("kernel32.dll", "handle", "OpenProcess", "dword", ((_WINAPI_GETVERSION() < 6) ? 0x410 : 0x1010), "bool", 0x0, "dword", $ipid)
    If @error Or Not $hprocess[0x0] Then Return SetError(@error + 0x14, @extended, 0x0)
    Local $tpmc_ex = DllStructCreate("dword;dword;ulong_ptr;ulong_ptr;ulong_ptr;ulong_ptr;ulong_ptr;ulong_ptr;ulong_ptr;ulong_ptr;ulong_ptr")
    Local $acall = DllCall(@SystemDir & "\psapi.dll", "bool", "GetProcessMemoryInfo", "handle", $hprocess[0x0], "struct*", $tpmc_ex, "int", DllStructGetSize($tpmc_ex))
    If __CHECKERRORCLOSEHANDLE($acall, $hprocess[0x0]) Then Return SetError(@error, @extended, 0x0)
    Local $aret[0xa]
    For $i = 0x0 To 0x9
        $aret[$i] = DllStructGetData($tpmc_ex, $i + 0x2)
    Next
    Return $aret
EndFunc   ;==>_WINAPI_GETPROCESSMEMORYINFO
Func _WINAPI_GETPROCESSNAME($ipid = 0x0)
    If Not $ipid Then $ipid = @AutoItPID
    Local $hsnapshot = DllCall("kernel32.dll", "handle", "CreateToolhelp32Snapshot", "dword", 0x2, "dword", 0x0)
    If @error Or Not $hsnapshot[0x0] Then Return SetError(@error + 0x14, @extended, "")
    $hsnapshot = $hsnapshot[0x0]
    Local $tprocessentry32 = DllStructCreate($tagprocessentry32)
    DllStructSetData($tprocessentry32, "Size", DllStructGetSize($tprocessentry32))
    Local $acall = DllCall("kernel32.dll", "bool", "Process32FirstW", "handle", $hsnapshot, "struct*", $tprocessentry32)
    Local $ierror = @error
    While (Not @error) And ($acall[0x0])
        If DllStructGetData($tprocessentry32, "ProcessID") = $ipid Then
            ExitLoop
        EndIf
        $acall = DllCall("kernel32.dll", "bool", "Process32NextW", "handle", $hsnapshot, "struct*", $tprocessentry32)
        $ierror = @error
    WEnd
    DllCall("kernel32.dll", "bool", "CloseHandle", "handle", $hsnapshot)
    If $ierror Then Return SetError($ierror, 0x0, "")
    If Not $acall[0x0] Then SetError(0xa, 0x0, "")
    Return DllStructGetData($tprocessentry32, "ExeFile")
EndFunc   ;==>_WINAPI_GETPROCESSNAME
Func _WINAPI_GETPROCESSTIMES($ipid = 0x0)
    If Not $ipid Then $ipid = @AutoItPID
    Local $hprocess = DllCall("kernel32.dll", "handle", "OpenProcess", "dword", ((_WINAPI_GETVERSION() < 6) ? 0x400 : 0x1000), "bool", 0x0, "dword", $ipid)
    If @error Or Not $hprocess[0x0] Then Return SetError(@error + 0x14, @extended, 0x0)
    Local $tfiletime = DllStructCreate($tagfiletime)
    Local $acall = DllCall("kernel32.dll", "bool", "GetProcessTimes", "handle", $hprocess[0x0], "struct*", $tfiletime, "uint64*", 0x0, "uint64*", 0x0, "uint64*", 0x0)
    If __CHECKERRORCLOSEHANDLE($acall, $hprocess[0x0]) Then Return SetError(@error, @extended, 0x0)
    Local $aret[0x3]
    $aret[0x0] = $tfiletime
    $aret[0x1] = $acall[0x4]
    $aret[0x2] = $acall[0x5]
    Return $aret
EndFunc   ;==>_WINAPI_GETPROCESSTIMES
Func _WINAPI_GETPROCESSUSER($ipid = 0x0)
    If Not $ipid Then $ipid = @AutoItPID
    Local $tsid, $htoken, $acall
    Local $ierror = 0x0
    Local $hprocess = DllCall("kernel32.dll", "handle", "OpenProcess", "dword", ((_WINAPI_GETVERSION() < 6) ? 0x400 : 0x1000), "bool", 0x0, "dword", $ipid)
    If @error Or Not $hprocess[0x0] Then Return SetError(@error + 0x14, @extended, 0x0)
    Do
        $htoken = _WINAPI_OPENPROCESSTOKEN(0x8, $hprocess[0x0])
        If Not $htoken Then
            $ierror = @error + 0xa
            ExitLoop
        EndIf
        $tsid = DllStructCreate("ptr;byte[1024]")
        $acall = DllCall("advapi32.dll", "bool", "GetTokenInformation", "handle", $htoken, "uint", 0x1, "struct*", $tsid, "dword", DllStructGetSize($tsid), "dword*", 0x0)
        If @error Or Not $acall[0x0] Then
            $ierror = @error + 0x1e
            ExitLoop
        EndIf
        $acall = DllCall("advapi32.dll", "bool", "LookupAccountSidW", "ptr", 0x0, "ptr", DllStructGetData($tsid, 0x1), "wstr", "", "dword*", 0x800, "wstr", "", "dword*", 0x800, "uint*", 0x0)
        If @error Or Not $acall[0x0] Then
            $ierror = @error + 0x28
            ExitLoop
        EndIf
    Until 0x1
    If $htoken Then
        DllCall("kernel32.dll", "bool", "CloseHandle", "handle", $htoken)
    EndIf
    DllCall("kernel32.dll", "bool", "CloseHandle", "handle", $hprocess[0x0])
    If $ierror Then Return SetError($ierror, 0x0, 0x0)
    Local $aret[0x2]
    $aret[0x0] = $acall[0x3]
    $aret[0x1] = $acall[0x5]
    Return $aret
EndFunc   ;==>_WINAPI_GETPROCESSUSER
Func _WINAPI_GETPROCESSWORKINGDIRECTORY($ipid = 0x0)
    If Not $ipid Then $ipid = @AutoItPID
    Local $acall, $ierror = 0x0
    Local $hprocess = DllCall("kernel32.dll", "handle", "OpenProcess", "dword", ((_WINAPI_GETVERSION() < 6) ? 0x410 : 0x1010), "bool", 0x0, "dword", $ipid)
    If @error Or Not $hprocess[0x0] Then Return SetError(@error + 0x14, @extended, "")
    $hprocess = $hprocess[0x0]
    Local $tpbi = DllStructCreate("ulong_ptr ExitStatus;ptr PebBaseAddress;ulong_ptr AffinityMask;ulong_ptr BasePriority;ulong_ptr UniqueProcessId;ulong_ptr InheritedFromUniqueProcessId")
    Local $tpeb = DllStructCreate("byte InheritedAddressSpace;byte ReadImageFileExecOptions;byte BeingDebugged;byte Spare;ptr Mutant;ptr ImageBaseAddress;ptr LoaderData;ptr ProcessParameters;ptr SubSystemData;ptr ProcessHeap;ptr FastPebLock;ptr FastPebLockRoutine;ptr FastPebUnlockRoutine;ulong EnvironmentUpdateCount;ptr KernelCallbackTable;ptr EventLogSection;ptr EventLog;ptr FreeList;ulong TlsExpansionCounter;ptr TlsBitmap;ulong TlsBitmapBits[2];ptr ReadOnlySharedMemoryBase;ptr ReadOnlySharedMemoryHeap;ptr ReadOnlyStaticServerData;ptr AnsiCodePageData;ptr OemCodePageData;ptr UnicodeCaseTableData;ulong NumberOfProcessors;ulong NtGlobalFlag;byte Spare2[4];int64 CriticalSectionTimeout;ulong HeapSegmentReserve;ulong HeapSegmentCommit;ulong HeapDeCommitTotalFreeThreshold;ulong HeapDeCommitFreeBlockThreshold;ulong NumberOfHeaps;ulong MaximumNumberOfHeaps;ptr ProcessHeaps;ptr GdiSharedHandleTable;ptr ProcessStarterHelper;ptr GdiDCAttributeList;ptr LoaderLock;ulong OSMajorVersion;ulong OSMinorVersion;ulong OSBuildNumber;ulong OSPlatformId;ulong ImageSubSystem;ulong ImageSubSystemMajorVersion;ulong ImageSubSystemMinorVersion;ulong GdiHandleBuffer[34];ulong PostProcessInitRoutine;ulong TlsExpansionBitmap;byte TlsExpansionBitmapBits[128];ulong SessionId")
    Local $tupp = DllStructCreate("ulong AllocationSize;ulong ActualSize;ulong Flags;ulong Unknown1;ushort LengthUnknown2;ushort MaxLengthUnknown2;ptr Unknown2;ptr InputHandle;ptr OutputHandle;ptr ErrorHandle;ushort LengthCurrentDirectory;ushort MaxLengthCurrentDirectory;ptr CurrentDirectory;ptr CurrentDirectoryHandle;ushort LengthSearchPaths;ushort MaxLengthSearchPaths;ptr SearchPaths;ushort LengthApplicationName;ushort MaxLengthApplicationName;ptr ApplicationName;ushort LengthCommandLine;ushort MaxLengthCommandLine;ptr CommandLine;ptr EnvironmentBlock;ulong Unknown[9];ushort LengthUnknown3;ushort MaxLengthUnknown3;ptr Unknown3;ushort LengthUnknown4;ushort MaxLengthUnknown4;ptr Unknown4;ushort LengthUnknown5;ushort MaxLengthUnknown5;ptr Unknown5")
    Local $tdir
    Do
        $acall = DllCall("ntdll.dll", "long", "NtQueryInformationProcess", "handle", $hprocess, "ulong", 0x0, "struct*", $tpbi, "ulong", DllStructGetSize($tpbi), "ulong*", 0x0)
        If @error Or ($acall[0x0]) Then
            $ierror = @error + 0xa
            ExitLoop
        EndIf
        $acall = DllCall("kernel32.dll", "bool", "ReadProcessMemory", "handle", $hprocess, "ptr", DllStructGetData($tpbi, "PebBaseAddress"), "struct*", $tpeb, "ulong_ptr", DllStructGetSize($tpeb), "ulong_ptr*", 0x0)
        If @error Or (Not $acall[0x0]) Or (Not $acall[0x5]) Then
            $ierror = @error + 0x1e
            ExitLoop
        EndIf
        $acall = DllCall("kernel32.dll", "bool", "ReadProcessMemory", "handle", $hprocess, "ptr", DllStructGetData($tpeb, "ProcessParameters"), "struct*", $tupp, "ulong_ptr", DllStructGetSize($tupp), "ulong_ptr*", 0x0)
        If @error Or (Not $acall[0x0]) Or (Not $acall[0x5]) Then
            $ierror = @error + 0x28
            ExitLoop
        EndIf
        $tdir = DllStructCreate("byte[" & DllStructGetData($tupp, "MaxLengthCurrentDirectory") & "]")
        If @error Then
            $ierror = @error + 0x32
            ExitLoop
        EndIf
        $acall = DllCall("kernel32.dll", "bool", "ReadProcessMemory", "handle", $hprocess, "ptr", DllStructGetData($tupp, "CurrentDirectory"), "struct*", $tdir, "ulong_ptr", DllStructGetSize($tdir), "ulong_ptr*", 0x0)
        If @error Or (Not $acall[0x0]) Or (Not $acall[0x5]) Then
            $ierror = @error + 0x3c
            ExitLoop
        EndIf
        $ierror = 0x0
    Until 0x1
    DllCall("kernel32.dll", "bool", "CloseHandle", "handle", $hprocess)
    If $ierror Then Return SetError($ierror, 0x0, "")
    Return _WINAPI_PATHREMOVEBACKSLASH(_WINAPI_GETSTRING(DllStructGetPtr($tdir)))
EndFunc   ;==>_WINAPI_GETPROCESSWORKINGDIRECTORY
Func _WINAPI_GETTHREADDESKTOP($ithreadid)
    Local $acall = DllCall("user32.dll", "handle", "GetThreadDesktop", "dword", $ithreadid)
    If @error Then Return SetError(@error, @extended, 0x0)
    Return $acall[0x0]
EndFunc   ;==>_WINAPI_GETTHREADDESKTOP
Func _WINAPI_GETTHREADERRORMODE()
    Local $acall = DllCall("kernel32.dll", "dword", "GetThreadErrorMode")
    If @error Then Return SetError(@error, @extended, 0x0)
    Return $acall[0x0]
EndFunc   ;==>_WINAPI_GETTHREADERRORMODE
Func _WINAPI_GETWINDOWFILENAME($hwnd)
    Local $ipid = 0x0
    Local $acall = DllCall("user32.dll", "bool", "IsWindow", "hwnd", $hwnd)
    If $acall[0x0] Then
        $acall = DllCall("user32.dll", "dword", "GetWindowThreadProcessId", "hwnd", $hwnd, "dword*", 0x0)
        $ipid = $acall[0x2]
    EndIf
    If Not $ipid Then Return SetError(0x1, 0x0, "")
    Local $sresult = _WINAPI_GETPROCESSFILENAME($ipid)
    If @error Then Return SetError(@error, @extended, "")
    Return $sresult
EndFunc   ;==>_WINAPI_GETWINDOWFILENAME
Func _WINAPI_ISELEVATED()
    Local $ielev, $acall, $ierror = 0x0
    Local $htoken = _WINAPI_OPENPROCESSTOKEN(0x8)
    If Not $htoken Then Return SetError(@error + 0xa, @extended, False)
    Do
        $acall = DllCall("advapi32.dll", "bool", "GetTokenInformation", "handle", $htoken, "uint", 0x14, "uint*", 0x0, "dword", 0x4, "dword*", 0x0)
        If @error Or Not $acall[0x0] Then
            $ierror = @error + 0xa
            ExitLoop
        EndIf
        $ielev = $acall[0x3]
        $acall = DllCall("advapi32.dll", "bool", "GetTokenInformation", "handle", $htoken, "uint", 0x12, "uint*", 0x0, "dword", 0x4, "dword*", 0x0)
        If @error Or Not $acall[0x0] Then
            $ierror = @error + 0x14
            ExitLoop
        EndIf
    Until 0x1
    DllCall("kernel32.dll", "bool", "CloseHandle", "handle", $htoken)
    If $ierror Then Return SetError($ierror, 0x0, False)
    Return SetExtended($acall[0x0] + 0xffffffff, $ielev)
EndFunc   ;==>_WINAPI_ISELEVATED
Func _WINAPI_ISPROCESSINJOB($hprocess, $hjob = 0x0)
    Local $acall = DllCall("kernel32.dll", "bool", "IsProcessInJob", "handle", $hprocess, "handle", $hjob, "bool*", 0x0)
    If @error Or Not $acall[0x0] Then Return SetError(@error, @extended, False)
    Return $acall[0x3]
EndFunc   ;==>_WINAPI_ISPROCESSINJOB
Func _WINAPI_OPENJOBOBJECT($sname, $iaccess = $job_object_all_access, $binherit = False)
    Local $acall = DllCall("kernel32.dll", "handle", "OpenJobObjectW", "dword", $iaccess, "bool", $binherit, "wstr", $sname)
    If @error Then Return SetError(@error, @extended, 0x0)
    Return $acall[0x0]
EndFunc   ;==>_WINAPI_OPENJOBOBJECT
Func _WINAPI_OPENMUTEX($smutex, $iaccess = $mutex_all_access, $binherit = False)
    Local $acall = DllCall("kernel32.dll", "handle", "OpenMutexW", "dword", $iaccess, "bool", $binherit, "wstr", $smutex)
    If @error Then Return SetError(@error, @extended, 0x0)
    Return $acall[0x0]
EndFunc   ;==>_WINAPI_OPENMUTEX
Func _WinAPI_OpenProcess($iaccess, $binherit, $ipid, $bdebugpriv = False)
    Local $acall = DllCall("kernel32.dll", "handle", "OpenProcess", "dword", $iaccess, "bool", $binherit, "dword", $ipid)
    If @error Then Return SetError(@error, @extended, 0x0)
    If $acall[0x0] Then Return $acall[0x0]
    If Not $bdebugpriv Then Return SetError(0x64, 0x0, 0x0)
    Local $htoken = _Security__OpenThreadTokenEx(BitOR($token_adjust_privileges, $token_query))
    If @error Then Return SetError(@error + 0xa, @extended, 0x0)
    _Security__SetPrivilege($htoken, $se_debug_name, True)
    Local $ierror = @error
    Local $iextended = @extended
    Local $iret = 0x0
    If Not @error Then
        $acall = DllCall("kernel32.dll", "handle", "OpenProcess", "dword", $iaccess, "bool", $binherit, "dword", $ipid)
        $ierror = @error
        $iextended = @extended
        If $acall[0x0] Then $iret = $acall[0x0]
        _Security__SetPrivilege($htoken, $se_debug_name, False)
        If @error Then
            $ierror = @error + 0x14
            $iextended = @extended
        EndIf
    Else
        $ierror = @error + 0x1e
    EndIf
    DllCall("kernel32.dll", "bool", "CloseHandle", "handle", $htoken)
    Return SetError($ierror, $iextended, $iret)
EndFunc   ;==>_WINAPI_OPENPROCESS
Func _WINAPI_OPENPROCESSTOKEN($iaccess, $hprocess = 0x0)
    If Not $hprocess Then
        $hprocess = DllCall("kernel32.dll", "handle", "GetCurrentProcess")
        $hprocess = $hprocess[0x0]
    EndIf
    Local $acall = DllCall("advapi32.dll", "bool", "OpenProcessToken", "handle", $hprocess, "dword", $iaccess, "handle*", 0x0)
    If @error Or Not $acall[0x0] Then Return SetError(@error, @extended, 0x0)
    Return $acall[0x3]
EndFunc   ;==>_WINAPI_OPENPROCESSTOKEN
Func _WINAPI_OPENSEMAPHORE($ssemaphore, $iaccess = 0x1f0003, $binherit = False)
    Local $acall = DllCall("kernel32.dll", "handle", "OpenSemaphoreW", "dword", $iaccess, "bool", $binherit, "wstr", $ssemaphore)
    If @error Then Return SetError(@error, @extended, 0x0)
    Return $acall[0x0]
EndFunc   ;==>_WINAPI_OPENSEMAPHORE
Func _WINAPI_QUERYINFORMATIONJOBOBJECT($hjob, $ijobobjectinfoclass, ByRef $tjobobjectinfo)
    Local $acall = DllCall("kernel32.dll", "bool", "QueryInformationJobObject", "handle", $hjob, "int", $ijobobjectinfoclass, "struct*", $tjobobjectinfo, "dword", DllStructGetSize($tjobobjectinfo), "dword*", 0x0)
    If @error Or Not $acall[0x0] Then Return SetError(@error, @extended, 0x0)
    Return $acall[0x5]
EndFunc   ;==>_WINAPI_QUERYINFORMATIONJOBOBJECT
Func _WINAPI_RELEASEMUTEX($hmutex)
    Local $acall = DllCall("kernel32.dll", "bool", "ReleaseMutex", "handle", $hmutex)
    If @error Then Return SetError(@error, @extended, 0x0)
    Return $acall[0x0]
EndFunc   ;==>_WINAPI_RELEASEMUTEX
Func _WINAPI_RELEASESEMAPHORE($hsemaphore, $iincrease = 0x1)
    Local $acall = DllCall("kernel32.dll", "bool", "ReleaseSemaphore", "handle", $hsemaphore, "long", $iincrease, "long*", 0x0)
    If @error Or Not $acall[0x0] Then Return SetError(@error + 0xa, @extended, 0x0)
    Return $acall[0x3]
EndFunc   ;==>_WINAPI_RELEASESEMAPHORE
Func _WINAPI_RESETEVENT($hevent)
    Local $acall = DllCall("kernel32.dll", "bool", "ResetEvent", "handle", $hevent)
    If @error Then Return SetError(@error, @extended, 0x0)
    Return $acall[0x0]
EndFunc   ;==>_WINAPI_RESETEVENT
Func _WinAPI_SetEvent($hevent)
    Local $acall = DllCall("kernel32.dll", "bool", "SetEvent", "handle", $hevent)
    If @error Then Return SetError(@error, @extended, False)
    Return $acall[0x0]
EndFunc   ;==>_WINAPI_SETEVENT
Func _WINAPI_SETINFORMATIONJOBOBJECT($hjob, $ijobobjectinfoclass, $tjobobjectinfo)
    Local $acall = DllCall("kernel32.dll", "bool", "SetInformationJobObject", "handle", $hjob, "int", $ijobobjectinfoclass, "struct*", $tjobobjectinfo, "dword", DllStructGetSize($tjobobjectinfo))
    If @error Then Return SetError(@error, @extended, False)
    Return $acall[0x0]
EndFunc   ;==>_WINAPI_SETINFORMATIONJOBOBJECT
Func _WINAPI_SETPRIORITYCLASS($ipriority, $ipid = 0x0)
    If Not $ipid Then $ipid = @AutoItPID
    Local $hprocess = DllCall("kernel32.dll", "handle", "OpenProcess", "dword", ((_WINAPI_GETVERSION() < 6) ? 0x600 : 0x1200), "bool", 0x0, "dword", $ipid)
    If @error Or Not $hprocess[0x0] Then Return SetError(@error + 0xa, @extended, 0x0)
    Local $ierror = 0x0
    Local $acall = DllCall("kernel32.dll", "bool", "SetPriorityClass", "handle", $hprocess[0x0], "dword", $ipriority)
    If @error Then $ierror = @error
    DllCall("kernel32.dll", "bool", "CloseHandle", "handle", $hprocess[0x0])
    If $ierror Then Return SetError($ierror, 0x0, 0x0)
    Return $acall[0x0]
EndFunc   ;==>_WINAPI_SETPRIORITYCLASS
Func _WinAPI_SetProcessAffinityMask($hprocess, $imask)
    Local $acall = DllCall("kernel32.dll", "bool", "SetProcessAffinityMask", "handle", $hprocess, "ulong_ptr", $imask)
    If @error Then Return SetError(@error, @extended, False)
    Return $acall[0x0]
EndFunc   ;==>_WINAPI_SETPROCESSAFFINITYMASK
Func _WINAPI_SETTHREADDESKTOP($hdesktop)
    Local $acall = DllCall("user32.dll", "bool", "SetThreadDesktop", "handle", $hdesktop)
    If @error Then Return SetError(@error, @extended, False)
    Return $acall[0x0]
EndFunc   ;==>_WINAPI_SETTHREADDESKTOP
Func _WINAPI_SETTHREADERRORMODE($imode)
    Local $acall = DllCall("kernel32.dll", "bool", "SetThreadErrorMode", "dword", $imode, "dword*", 0x0)
    If @error Or Not $acall[0x0] Then Return SetError(@error + 0xa, @extended, 0x0)
    Return $acall[0x2]
EndFunc   ;==>_WINAPI_SETTHREADERRORMODE
Func _WINAPI_SETTHREADEXECUTIONSTATE($iflags)
    Local $acall = DllCall("kernel32.dll", "dword", "SetThreadExecutionState", "dword", $iflags)
    If @error Then Return SetError(@error, @extended, 0x0)
    Return $acall[0x0]
EndFunc   ;==>_WINAPI_SETTHREADEXECUTIONSTATE
Func _WINAPI_TERMINATEJOBOBJECT($hjob, $iexitcode = 0x0)
    Local $acall = DllCall("kernel32.dll", "bool", "TerminateJobObject", "handle", $hjob, "uint", $iexitcode)
    If @error Then Return SetError(@error, @extended, 0x0)
    Return $acall[0x0]
EndFunc   ;==>_WINAPI_TERMINATEJOBOBJECT
Func _WINAPI_TERMINATEPROCESS($hprocess, $iexitcode = 0x0)
    Local $acall = DllCall("kernel32.dll", "bool", "TerminateProcess", "handle", $hprocess, "uint", $iexitcode)
    If @error Then Return SetError(@error, @extended, 0x0)
    Return $acall[0x0]
EndFunc   ;==>_WINAPI_TERMINATEPROCESS
Func _WINAPI_USERHANDLEGRANTACCESS($hobject, $hjob, $bgrant)
    Local $acall = DllCall("kernel32.dll", "bool", "UserHandleGrantAccess", "handle", $hobject, "handle", $hjob, "bool", $bgrant)
    If @error Then Return SetError(@error, @extended, False)
    Return $acall[0x0]
EndFunc   ;==>_WINAPI_USERHANDLEGRANTACCESS
Func _WinAPI_WaitForInputIdle($hprocess, $itimeout = +0xffffffff)
    Local $acall = DllCall("user32.dll", "dword", "WaitForInputIdle", "handle", $hprocess, "dword", $itimeout)
    If @error Then Return SetError(@error, @extended, False)
    Return $acall[0x0]
EndFunc   ;==>_WINAPI_WAITFORINPUTIDLE
Func _WinAPI_WaitForMultipleObjects($icount, $pahandles, $bwaitall = False, $itimeout = +0xffffffff)
    Local $acall = DllCall("kernel32.dll", "INT", "WaitForMultipleObjects", "dword", $icount, "struct*", $pahandles, "bool", $bwaitall, "dword", $itimeout)
    If @error Then Return SetError(@error, @extended, +0xffffffff)
    Return $acall[0x0]
EndFunc   ;==>_WINAPI_WAITFORMULTIPLEOBJECTS
Func _WinAPI_WaitForSingleObject($hhandle, $itimeout = +0xffffffff)
    Local $acall = DllCall("kernel32.dll", "INT", "WaitForSingleObject", "handle", $hhandle, "dword", $itimeout)
    If @error Then Return SetError(@error, @extended, +0xffffffff)
    Return $acall[0x0]
EndFunc   ;==>_WINAPI_WAITFORSINGLEOBJECT
Func _WinAPI_WriteConsole($hconsole, $stext)
    Local $acall = DllCall("kernel32.dll", "bool", "WriteConsoleW", "handle", $hconsole, "wstr", $stext, "dword", StringLen($stext), "dword*", 0x0, "ptr", 0x0)
    If @error Then Return SetError(@error, @extended, False)
    Return $acall[0x0]
EndFunc   ;==>_WINAPI_WRITECONSOLE
#endregion Public Functions
Global Const $linguistic_ignorecase = 0x10
Global Const $linguistic_ignorediacritic = 0x20
Global Const $norm_ignorecase = 0x1
Global Const $norm_ignorekanatype = 0x10000
Global Const $norm_ignorenonspace = 0x2
Global Const $norm_ignoresymbols = 0x4
Global Const $norm_ignorewidth = 0x20000
Global Const $norm_linguistic_casing = 0x8000000
Global Const $sort_digitsasnumbers = 0x8
Global Const $sort_stringsort = 0x1000
Global Const $cstr_less_than = 0x1
Global Const $cstr_equal = 0x2
Global Const $cstr_greater_than = 0x3
Global Const $mui_language_id = 0x4
Global Const $mui_language_name = 0x8
Global Const $date_autolayout = 0x40
Global Const $date_longdate = 0x2
Global Const $date_ltrreading = 0x10
Global Const $date_shortdate = 0x1
Global Const $date_rtlreading = 0x20
Global Const $date_use_alt_calendar = 0x4
Global Const $date_yearmonth = 0x8
Global Const $geo_nation = 0x1
Global Const $geo_latitude = 0x2
Global Const $geo_longitude = 0x3
Global Const $geo_iso2 = 0x4
Global Const $geo_iso3 = 0x5
Global Const $geo_rfc1766 = 0x6
Global Const $geo_lcid = 0x7
Global Const $geo_friendlyname = 0x8
Global Const $geo_officialname = 0x9
Global Const $geo_timezones = 0xa
Global Const $geo_officiallanguages = 0xb
Global Const $geo_iso_un_number = 0xc
Global Const $geo_parent = 0xd
Global Const $locale_ilanguage = 0x1
Global Const $locale_slanguage = 0x2
Global Const $locale_senglanguage = 0x1001
Global Const $locale_sabbrevlangname = 0x3
Global Const $locale_snativelangname = 0x4
Global Const $locale_icountry = 0x5
Global Const $locale_scountry = 0x6
Global Const $locale_sengcountry = 0x1002
Global Const $locale_sabbrevctryname = 0x7
Global Const $locale_snativectryname = 0x8
Global Const $locale_idefaultlanguage = 0x9
Global Const $locale_idefaultcountry = 0xa
Global Const $locale_idefaultcodepage = 0xb
Global Const $locale_idefaultansicodepage = 0x1004
Global Const $locale_idefaultmaccodepage = 0x1011
Global Const $locale_slist = 0xc
Global Const $locale_imeasure = 0xd
Global Const $locale_sdecimal = 0xe
Global Const $locale_sthousand = 0xf
Global Const $locale_sgrouping = 0x10
Global Const $locale_idigits = 0x11
Global Const $locale_ilzero = 0x12
Global Const $locale_inegnumber = 0x1010
Global Const $locale_snativedigits = 0x13
Global Const $locale_scurrency = 0x14
Global Const $locale_sintlsymbol = 0x15
Global Const $locale_smondecimalsep = 0x16
Global Const $locale_smonthousandsep = 0x17
Global Const $locale_smongrouping = 0x18
Global Const $locale_icurrdigits = 0x19
Global Const $locale_iintlcurrdigits = 0x1a
Global Const $locale_icurrency = 0x1b
Global Const $locale_inegcurr = 0x1c
Global Const $locale_sdate = 0x1d
Global Const $locale_stime = 0x1e
Global Const $locale_sshortdate = 0x1f
Global Const $locale_slongdate = 0x20
Global Const $locale_stimeformat = 0x1003
Global Const $locale_idate = 0x21
Global Const $locale_ildate = 0x22
Global Const $locale_itime = 0x23
Global Const $locale_itimemarkposn = 0x1005
Global Const $locale_icentury = 0x24
Global Const $locale_itlzero = 0x25
Global Const $locale_idaylzero = 0x26
Global Const $locale_imonlzero = 0x27
Global Const $locale_s1159 = 0x28
Global Const $locale_s2359 = 0x29
Global Const $locale_icalendartype = 0x1009
Global Const $locale_ioptionalcalendar = 0x100b
Global Const $locale_ifirstdayofweek = 0x100c
Global Const $locale_ifirstweekofyear = 0x100d
Global Const $locale_sdayname1 = 0x2a
Global Const $locale_sdayname2 = 0x2b
Global Const $locale_sdayname3 = 0x2c
Global Const $locale_sdayname4 = 0x2d
Global Const $locale_sdayname5 = 0x2e
Global Const $locale_sdayname6 = 0x2f
Global Const $locale_sdayname7 = 0x30
Global Const $locale_sabbrevdayname1 = 0x31
Global Const $locale_sabbrevdayname2 = 0x32
Global Const $locale_sabbrevdayname3 = 0x33
Global Const $locale_sabbrevdayname4 = 0x34
Global Const $locale_sabbrevdayname5 = 0x35
Global Const $locale_sabbrevdayname6 = 0x36
Global Const $locale_sabbrevdayname7 = 0x37
Global Const $locale_smonthname1 = 0x38
Global Const $locale_smonthname2 = 0x39
Global Const $locale_smonthname3 = 0x3a
Global Const $locale_smonthname4 = 0x3b
Global Const $locale_smonthname5 = 0x3c
Global Const $locale_smonthname6 = 0x3d
Global Const $locale_smonthname7 = 0x3e
Global Const $locale_smonthname8 = 0x3f
Global Const $locale_smonthname9 = 0x40
Global Const $locale_smonthname10 = 0x41
Global Const $locale_smonthname11 = 0x42
Global Const $locale_smonthname12 = 0x43
Global Const $locale_smonthname13 = 0x100e
Global Const $locale_sabbrevmonthname1 = 0x44
Global Const $locale_sabbrevmonthname2 = 0x45
Global Const $locale_sabbrevmonthname3 = 0x46
Global Const $locale_sabbrevmonthname4 = 0x47
Global Const $locale_sabbrevmonthname5 = 0x48
Global Const $locale_sabbrevmonthname6 = 0x49
Global Const $locale_sabbrevmonthname7 = 0x4a
Global Const $locale_sabbrevmonthname8 = 0x4b
Global Const $locale_sabbrevmonthname9 = 0x4c
Global Const $locale_sabbrevmonthname10 = 0x4d
Global Const $locale_sabbrevmonthname11 = 0x4e
Global Const $locale_sabbrevmonthname12 = 0x4f
Global Const $locale_sabbrevmonthname13 = 0x100f
Global Const $locale_spositivesign = 0x50
Global Const $locale_snegativesign = 0x51
Global Const $locale_ipossignposn = 0x52
Global Const $locale_inegsignposn = 0x53
Global Const $locale_ipossymprecedes = 0x54
Global Const $locale_ipossepbyspace = 0x55
Global Const $locale_inegsymprecedes = 0x56
Global Const $locale_inegsepbyspace = 0x57
Global Const $locale_fontsignature = 0x58
Global Const $locale_siso639langname = 0x59
Global Const $locale_siso3166ctryname = 0x5a
Global Const $locale_idefaultebcdiccodepage = 0x1012
Global Const $locale_ipapersize = 0x100a
Global Const $locale_sengcurrname = 0x1007
Global Const $locale_snativecurrname = 0x1008
Global Const $locale_syearmonth = 0x1006
Global Const $locale_ssortname = 0x1013
Global Const $locale_idigitsubstitution = 0x1014
Global Const $locale_custom_default = 0xc00
Global Const $locale_custom_ui_default = 0x1400
Global Const $locale_custom_unspecified = 0x1000
Global Const $locale_invariant = 0x7f
Global Const $locale_system_default = 0x800
Global Const $locale_user_default = 0x400
Global Const $time_force24hourformat = 0x8
Global Const $time_nominutesorseconds = 0x1
Global Const $time_noseconds = 0x2
Global Const $time_notimemarker = 0x4
Global Const $lcid_installed = 0x1
Global Const $lcid_supported = 0x2
Global Const $rt_accelerator = 0x9
Global Const $rt_anicursor = 0x15
Global Const $rt_aniicon = 0x16
Global Const $rt_bitmap = 0x2
Global Const $rt_cursor = 0x1
Global Const $rt_dialog = 0x5
Global Const $rt_dlginclude = 0x11
Global Const $rt_font = 0x8
Global Const $rt_fontdir = 0x7
Global Const $rt_group_cursor = 0xc
Global Const $rt_group_icon = 0xe
Global Const $rt_html = 0x17
Global Const $rt_icon = 0x3
Global Const $rt_manifest = 0x18
Global Const $rt_menu = 0x4
Global Const $rt_messagetable = 0xb
Global Const $rt_plugplay = 0x13
Global Const $rt_rcdata = 0xa
Global Const $rt_string = 0x6
Global Const $rt_version = 0x10
Global Const $rt_vxd = 0x14
Global Const $file_ver_get_localised = 0x1
Global Const $file_ver_get_neutral = 0x2
Global Const $file_ver_get_prefetched = 0x4
Global Const $obm_trtype = 0x7fdc
Global Const $obm_lfarrowi = 0x7fde
Global Const $obm_rgarrowi = 0x7fdf
Global Const $obm_dnarrowi = 0x7fe0
Global Const $obm_uparrowi = 0x7fe1
Global Const $obm_combo = 0x7fe2
Global Const $obm_mnarrow = 0x7fe3
Global Const $obm_lfarrowd = 0x7fe4
Global Const $obm_rgarrowd = 0x7fe5
Global Const $obm_dnarrowd = 0x7fe6
Global Const $obm_uparrowd = 0x7fe7
Global Const $obm_restored = 0x7fe8
Global Const $obm_zoomd = 0x7fe9
Global Const $obm_reduced = 0x7fea
Global Const $obm_restore = 0x7feb
Global Const $obm_zoom = 0x7fec
Global Const $obm_reduce = 0x7fed
Global Const $obm_lfarrow = 0x7fee
Global Const $obm_rgarrow = 0x7fef
Global Const $obm_dnarrow = 0x7ff0
Global Const $obm_uparrow = 0x7ff1
Global Const $obm_close = 0x7ff2
Global Const $obm_old_restore = 0x7ff3
Global Const $obm_old_zoom = 0x7ff4
Global Const $obm_old_reduce = 0x7ff5
Global Const $obm_btncorners = 0x7ff6
Global Const $obm_checkboxes = 0x7ff7
Global Const $obm_check = 0x7ff8
Global Const $obm_btsize = 0x7ff9
Global Const $obm_old_lfarrow = 0x7ffa
Global Const $obm_old_rgarrow = 0x7ffb
Global Const $obm_old_dnarrow = 0x7ffc
Global Const $obm_old_uparrow = 0x7ffd
Global Const $obm_size = 0x7ffe
Global Const $obm_old_close = 0x7fff
Global Const $oic_sample = 0x7f00
Global Const $oic_hand = 0x7f01
Global Const $oic_ques = 0x7f02
Global Const $oic_bang = 0x7f03
Global Const $oic_note = 0x7f04
Global Const $oic_winlogo = 0x7f05
Global Const $oic_warning = $oic_bang
Global Const $oic_error = $oic_hand
Global Const $oic_information = $oic_note
Global Const $dont_resolve_dll_references = 0x1
Global Const $load_library_as_datafile = 0x2
Global Const $load_with_altered_search_path = 0x8
Global Const $load_ignore_code_authz_level = 0x10
Global Const $load_library_as_datafile_exclusive = 0x40
Global Const $load_library_as_image_resource = 0x20
Global Const $load_library_search_application_dir = 0x200
Global Const $load_library_search_default_dirs = 0x1000
Global Const $load_library_search_dll_load_dir = 0x100
Global Const $load_library_search_system32 = 0x800
Global Const $load_library_search_user_dirs = 0x400
Global Const $ocr_normal = 0x7f00
Global Const $ocr_ibeam = 0x7f01
Global Const $ocr_wait = 0x7f02
Global Const $ocr_cross = 0x7f03
Global Const $ocr_up = 0x7f04
Global Const $ocr_size = 0x7f80
Global Const $ocr_icon = 0x7f81
Global Const $ocr_sizenwse = 0x7f82
Global Const $ocr_sizenesw = 0x7f83
Global Const $ocr_sizewe = 0x7f84
Global Const $ocr_sizens = 0x7f85
Global Const $ocr_sizeall = 0x7f86
Global Const $ocr_icocur = 0x7f87
Global Const $ocr_no = 0x7f88
Global Const $ocr_hand = 0x7f89
Global Const $ocr_appstarting = 0x7f8a
Global Const $ocr_help = 0x7f8b
Global Const $vs_ff_debug = 0x1
Global Const $vs_ff_infoinferred = 0x10
Global Const $vs_ff_patched = 0x4
Global Const $vs_ff_prerelease = 0x2
Global Const $vs_ff_privatebuild = 0x8
Global Const $vs_ff_specialbuild = 0x20
Global Const $vos_dos = 0x10000
Global Const $vos_nt = 0x40000
Global Const $vos__windows16 = 0x1
Global Const $vos__windows32 = 0x4
Global Const $vos_os216 = 0x20000
Global Const $vos_os232 = 0x30000
Global Const $vos__pm16 = 0x2
Global Const $vos__pm32 = 0x3
Global Const $vos_unknown = 0x0
Global Const $vos_dos_windows16 = 0x10001
Global Const $vos_dos_windows32 = 0x10004
Global Const $vos_nt_windows32 = 0x40004
Global Const $vos_os216_pm16 = 0x20002
Global Const $vos_os232_pm32 = 0x30003
Global Const $vft_app = 0x1
Global Const $vft_dll = 0x2
Global Const $vft_drv = 0x3
Global Const $vft_font = 0x4
Global Const $vft_static_lib = 0x7
Global Const $vft_unknown = 0x0
Global Const $vft_vxd = 0x5
Global Const $vft2_drv_comm = 0xa
Global Const $vft2_drv_display = 0x4
Global Const $vft2_drv_installable = 0x8
Global Const $vft2_drv_keyboard = 0x2
Global Const $vft2_drv_language = 0x3
Global Const $vft2_drv_mouse = 0x5
Global Const $vft2_drv_network = 0x6
Global Const $vft2_drv_printer = 0x1
Global Const $vft2_drv_sound = 0x9
Global Const $vft2_drv_system = 0x7
Global Const $vft2_drv_versioned_printer = 0xc
Global Const $vft2_unknown = 0x0
Global Const $vft2_font_raster = 0x1
Global Const $vft2_font_truetype = 0x3
Global Const $vft2_font_vector = 0x2
#region Global Variables and Constants
Global $__g_vval
Global Const $tagvs_fixedfileinfo = "dword Signature;dword StrucVersion;dword FileVersionMS;dword FileVersionLS;dword ProductVersionMS;dword ProductVersionLS;dword FileFlagsMask;dword FileFlags;dword FileOS;dword FileType;dword FileSubtype;dword FileDateMS;dword FileDateLS"
#endregion Global Variables and Constants
#region Functions list
#endregion Functions list
#region Public Functions
Func _WINAPI_BEGINUPDATERESOURCE($sfilepath, $bdelete = False)
    Local $acall = DllCall("kernel32.dll", "handle", "BeginUpdateResourceW", "wstr", $sfilepath, "bool", $bdelete)
    If @error Then Return SetError(@error, @extended, 0x0)
    Return $acall[0x0]
EndFunc   ;==>_WINAPI_BEGINUPDATERESOURCE
Func _WINAPI_CLIPCURSOR($trect)
    Local $acall = DllCall("user32.dll", "bool", "ClipCursor", "struct*", $trect)
    If @error Then Return SetError(@error, @extended, False)
    Return $acall[0x0]
EndFunc   ;==>_WINAPI_CLIPCURSOR
Func _WINAPI_COPYCURSOR($hcursor)
    Return _WinAPI_CopyIcon($hcursor)
EndFunc   ;==>_WINAPI_COPYCURSOR
Func _WINAPI_CREATECARET($hwnd, $hbitmap, $iwidth = 0x0, $iheight = 0x0)
    Local $acall = DllCall("user32.dll", "bool", "CreateCaret", "hwnd", $hwnd, "handle", $hbitmap, "int", $iwidth, "int", $iheight)
    If @error Then Return SetError(@error, @extended, False)
    Return $acall[0x0]
EndFunc   ;==>_WINAPI_CREATECARET
Func _WINAPI_DESTROYCARET()
    Local $acall = DllCall("user32.dll", "bool", "DestroyCaret")
    If @error Then Return SetError(@error, @extended, 0x0)
    Return $acall[0x0]
EndFunc   ;==>_WINAPI_DESTROYCARET
Func _WINAPI_DESTROYCURSOR($hcursor)
    Local $acall = DllCall("user32.dll", "bool", "DestroyCursor", "handle", $hcursor)
    If @error Then Return SetError(@error, @extended, 0x0)
    Return $acall[0x0]
EndFunc   ;==>_WINAPI_DESTROYCURSOR
Func _WINAPI_ENDUPDATERESOURCE($hupdate, $bdiscard = False)
    Local $acall = DllCall("kernel32.dll", "bool", "EndUpdateResourceW", "handle", $hupdate, "bool", $bdiscard)
    If @error Then Return SetError(@error, @extended, False)
    Return $acall[0x0]
EndFunc   ;==>_WINAPI_ENDUPDATERESOURCE
Func _WINAPI_ENUMRESOURCELANGUAGES($hmodule, $stype, $sname)
    Local $ilibrary = 0x0, $stypeoftype = "int", $stypeofname = "int"
    If IsString($hmodule) Then
        If StringStripWS($hmodule, $str_stripleading + $str_striptrailing) Then
            $hmodule = _WinAPI_LoadLibraryEx($hmodule, BitOR($dont_resolve_dll_references, $load_library_as_datafile))
            If Not $hmodule Then Return SetError(0x1, 0x0, 0x0)
            $ilibrary = 0x1
        Else
            $hmodule = 0x0
        EndIf
    EndIf
    If IsString($stype) Then
        $stypeoftype = "wstr"
    EndIf
    If IsString($sname) Then
        $stypeofname = "wstr"
    EndIf
    Dim $__g_venum[0x65] = [0x0]
    Local $henumproc = DllCallbackRegister("__EnumResLanguagesProc", "bool", "handle;ptr;ptr;word;long_ptr")
    Local $acall = DllCall("kernel32.dll", "bool", "EnumResourceLanguagesW", "handle", $hmodule, $stypeoftype, $stype, $stypeofname, $sname, "ptr", DllCallbackGetPtr($henumproc), "long_ptr", 0x0)
    If @error Or Not $acall[0x0] Or Not $__g_venum[0x0] Then
        $__g_venum = @error + 0xa
    EndIf
    If $ilibrary Then
        _WinAPI_FreeLibrary($hmodule)
    EndIf
    DllCallbackFree($henumproc)
    If $__g_venum Then Return SetError($__g_venum, 0x0, 0x0)
    __INC($__g_venum, +0xffffffff)
    Return $__g_venum
EndFunc   ;==>_WINAPI_ENUMRESOURCELANGUAGES
Func _WINAPI_ENUMRESOURCENAMES($hmodule, $stype)
    Local $acall, $henumproc, $ilibrary = 0x0, $stypeoftype = "int"
    If IsString($hmodule) Then
        If StringStripWS($hmodule, $str_stripleading + $str_striptrailing) Then
            $hmodule = _WinAPI_LoadLibraryEx($hmodule, BitOR($dont_resolve_dll_references, $load_library_as_datafile))
            If Not $hmodule Then Return SetError(0x1, 0x0, 0x0)
            $ilibrary = 0x1
        Else
            $hmodule = 0x0
        EndIf
    EndIf
    If IsString($stype) Then
        $stypeoftype = "wstr"
    EndIf
    Dim $__g_venum[0x65] = [0x0]
    $henumproc = DllCallbackRegister("__EnumResNamesProc", "bool", "handle;ptr;ptr;long_ptr")
    $acall = DllCall("kernel32.dll", "bool", "EnumResourceNamesW", "handle", $hmodule, $stypeoftype, $stype, "ptr", DllCallbackGetPtr($henumproc), "long_ptr", 0x0)
    If @error Or Not $acall[0x0] Or (Not $__g_venum[0x0]) Then
        $__g_venum = @error + 0xa
    EndIf
    If $ilibrary Then
        _WinAPI_FreeLibrary($hmodule)
    EndIf
    DllCallbackFree($henumproc)
    If $__g_venum Then Return SetError($__g_venum, 0x0, 0x0)
    __INC($__g_venum, +0xffffffff)
    Return $__g_venum
EndFunc   ;==>_WINAPI_ENUMRESOURCENAMES
Func _WINAPI_ENUMRESOURCETYPES($hmodule)
    Local $ilibrary = 0x0
    If IsString($hmodule) Then
        If StringStripWS($hmodule, $str_stripleading + $str_striptrailing) Then
            $hmodule = _WinAPI_LoadLibraryEx($hmodule, BitOR($dont_resolve_dll_references, $load_library_as_datafile))
            If Not $hmodule Then Return SetError(0x1, 0x0, 0x0)
            $ilibrary = 0x1
        Else
            $hmodule = 0x0
        EndIf
    EndIf
    Dim $__g_venum[0x65] = [0x0]
    Local $henumproc = DllCallbackRegister("__EnumResTypesProc", "bool", "handle;ptr;long_ptr")
    Local $acall = DllCall("kernel32.dll", "bool", "EnumResourceTypesW", "handle", $hmodule, "ptr", DllCallbackGetPtr($henumproc), "long_ptr", 0x0)
    If @error Or Not $acall[0x0] Or (Not $__g_venum[0x0]) Then
        $__g_venum = @error + 0xa
    EndIf
    If $ilibrary Then
        _WinAPI_FreeLibrary($hmodule)
    EndIf
    DllCallbackFree($henumproc)
    If $__g_venum Then Return SetError($__g_venum, 0x0, 0x0)
    __INC($__g_venum, +0xffffffff)
    Return $__g_venum
EndFunc   ;==>_WINAPI_ENUMRESOURCETYPES
Func _WINAPI_FINDRESOURCE($hinstance, $stype, $sname)
    Local $stypeoftype = "int", $stypeofname = "int"
    If IsString($stype) Then
        $stypeoftype = "wstr"
    EndIf
    If IsString($sname) Then
        $stypeofname = "wstr"
    EndIf
    Local $acall = DllCall("kernel32.dll", "handle", "FindResourceW", "handle", $hinstance, $stypeofname, $sname, $stypeoftype, $stype)
    If @error Then Return SetError(@error, @extended, 0x0)
    Return $acall[0x0]
EndFunc   ;==>_WINAPI_FINDRESOURCE
Func _WINAPI_FINDRESOURCEEX($hinstance, $stype, $sname, $ilanguage)
    Local $stypeoftype = "int", $stypeofname = "int"
    If IsString($stype) Then
        $stypeoftype = "wstr"
    EndIf
    If IsString($sname) Then
        $stypeofname = "wstr"
    EndIf
    Local $acall = DllCall("kernel32.dll", "handle", "FindResourceExW", "handle", $hinstance, $stypeoftype, $stype, $stypeofname, $sname, "ushort", $ilanguage)
    If @error Then Return SetError(@error, @extended, 0x0)
    Return $acall[0x0]
EndFunc   ;==>_WINAPI_FINDRESOURCEEX
Func _WINAPI_FREERESOURCE($hdata)
    Local $acall = DllCall("kernel32.dll", "bool", "FreeResource", "handle", $hdata)
    If @error Then Return SetError(@error, @extended, False)
    Return $acall[0x0]
EndFunc   ;==>_WINAPI_FREERESOURCE
Func _WINAPI_GETCARETBLINKTIME()
    Local $acall = DllCall("user32.dll", "uint", "GetCaretBlinkTime")
    If @error Then Return SetError(@error, @extended, 0x0)
    Return $acall[0x0]
EndFunc   ;==>_WINAPI_GETCARETBLINKTIME
Func _WINAPI_GETCARETPOS()
    Local $tpoint = DllStructCreate($tagpoint)
    Local $acall = DllCall("user32.dll", "bool", "GetCaretPos", "struct*", $tpoint)
    If @error Then Return SetError(@error, @extended, 0x0)
    If Not $acall[0x0] Then Return SetError(0xa, _WinAPI_GetLastError(), 0x0)
    Local $aret[0x2]
    For $i = 0x0 To 0x1
        $aret[$i] = DllStructGetData($tpoint, $i + 0x1)
    Next
    Return $aret
EndFunc   ;==>_WINAPI_GETCARETPOS
Func _WINAPI_GETCLIPCURSOR()
    Local $trect = DllStructCreate($tagrect)
    Local $acall = DllCall("user32.dll", "bool", "GetClipCursor", "struct*", $trect)
    If @error Or Not $acall[0x0] Then Return SetError(@error + 0xa, @extended, 0x0)
    Return $trect
EndFunc   ;==>_WINAPI_GETCLIPCURSOR
Func _WINAPI_GETCURSOR()
    Local $acall = DllCall("user32.dll", "handle", "GetCursor")
    If @error Then Return SetError(@error, @extended, 0x0)
    Return $acall[0x0]
EndFunc   ;==>_WINAPI_GETCURSOR
Func _WINAPI_GETFILEVERSIONINFO($sfilepath, ByRef $pbuffer, $iflags = 0x0)
    Local $acall
    If _WINAPI_GETVERSION() >= 6 Then
        $acall = DllCall("version.dll", "dword", "GetFileVersionInfoSizeExW", "dword", BitAND($iflags, 0x3), "wstr", $sfilepath, "ptr", 0x0)
    Else
        $acall = DllCall("version.dll", "dword", "GetFileVersionInfoSizeW", "wstr", $sfilepath, "ptr", 0x0)
    EndIf
    If @error Or Not $acall[0x0] Then Return SetError(@error, @extended, 0x0)
    $pbuffer = __HEAPREALLOC($pbuffer, $acall[0x0], 0x1)
    If @error Then Return SetError(@error + 0x64, @extended, 0x0)
    Local $inbbyte = $acall[0x0]
    If _WINAPI_GETVERSION() >= 6 Then
        $acall = DllCall("version.dll", "bool", "GetFileVersionInfoExW", "dword", BitAND($iflags, 0x7), "wstr", $sfilepath, "dword", 0x0, "dword", $inbbyte, "ptr", $pbuffer)
    Else
        $acall = DllCall("version.dll", "bool", "GetFileVersionInfoW", "wstr", $sfilepath, "dword", 0x0, "dword", $inbbyte, "ptr", $pbuffer)
    EndIf
    If @error Or Not $acall[0x0] Then Return SetError(@error + 0xa, @extended, 0x0)
    Return $inbbyte
EndFunc   ;==>_WINAPI_GETFILEVERSIONINFO
Func _WINAPI_HIDECARET($hwnd)
    Local $acall = DllCall("user32.dll", "int", "HideCaret", "hwnd", $hwnd)
    If @error Then Return SetError(@error, @extended, False)
    Return $acall[0x0]
EndFunc   ;==>_WINAPI_HIDECARET
Func _WinAPI_LoadBitmap($hinstance, $sbitmap)
    Local $sbitmaptype = "int"
    If IsString($sbitmap) Then $sbitmaptype = "wstr"
    Local $acall = DllCall("user32.dll", "handle", "LoadBitmapW", "handle", $hinstance, $sbitmaptype, $sbitmap)
    If @error Then Return SetError(@error, @extended, 0x0)
    Return $acall[0x0]
EndFunc   ;==>_WINAPI_LOADBITMAP
Func _WINAPI_LOADCURSOR($hinstance, $sname)
    Local $stypeofname = "int"
    If IsString($sname) Then
        $stypeofname = "wstr"
    EndIf
    Local $acall = DllCall("user32.dll", "handle", "LoadCursorW", "handle", $hinstance, $stypeofname, $sname)
    If @error Then Return SetError(@error, @extended, 0x0)
    Return $acall[0x0]
EndFunc   ;==>_WINAPI_LOADCURSOR
Func _WINAPI_LOADCURSORFROMFILE($sfilepath)
    Local $acall = DllCall("user32.dll", "handle", "LoadCursorFromFileW", "wstr", $sfilepath)
    If @error Then Return SetError(@error, @extended, 0x0)
    Return $acall[0x0]
EndFunc   ;==>_WINAPI_LOADCURSORFROMFILE
Func _WINAPI_LOADINDIRECTSTRING($sstrin)
    Local $acall = DllCall("shlwapi.dll", "uint", "SHLoadIndirectString", "wstr", $sstrin, "wstr", "", "uint", 0x1000, "ptr*", 0x0)
    If @error Then Return SetError(@error, @extended, "")
    If $acall[0x0] Then Return SetError(0xa, $acall[0x0], "")
    Return $acall[0x2]
EndFunc   ;==>_WINAPI_LOADINDIRECTSTRING
Func _WinAPI_LoadString($hinstance, $istringid)
    Local $acall = DllCall("user32.dll", "int", "LoadStringW", "handle", $hinstance, "uint", $istringid, "wstr", "", "int", 0x1000)
    If @error Or Not $acall[0x0] Then Return SetError(@error + 0xa, @extended, "")
    Return SetExtended($acall[0x0], $acall[0x3])
EndFunc   ;==>_WINAPI_LOADSTRING
Func _WinAPI_LoadLibraryEx($sfilename, $iflags = 0x0)
    Local $acall = DllCall("kernel32.dll", "handle", "LoadLibraryExW", "wstr", $sfilename, "ptr", 0x0, "dword", $iflags)
    If @error Then Return SetError(@error, @extended, 0x0)
    Return $acall[0x0]
EndFunc   ;==>_WINAPI_LOADLIBRARYEX
Func _WINAPI_LOADRESOURCE($hinstance, $hresource)
    Local $acall = DllCall("kernel32.dll", "handle", "LoadResource", "handle", $hinstance, "handle", $hresource)
    If @error Then Return SetError(@error, @extended, 0x0)
    Return $acall[0x0]
EndFunc   ;==>_WINAPI_LOADRESOURCE
Func _WINAPI_LOADSTRINGEX($hmodule, $iid, $ilanguage = $locale_user_default)
    Local $ilibrary = 0x0
    If IsString($hmodule) Then
        If StringStripWS($hmodule, $str_stripleading + $str_striptrailing) Then
            $hmodule = _WinAPI_LoadLibraryEx($hmodule, BitOR($dont_resolve_dll_references, $load_library_as_datafile))
            If Not $hmodule Then Return SetError(@error + 0x14, @extended, "")
            $ilibrary = 0x1
        Else
            $hmodule = 0x0
        EndIf
    EndIf
    Local $sresult = ""
    Local $pdata = __RESLOAD($hmodule, 0x6, Floor($iid / 0x10) + 0x1, $ilanguage)
    If Not @error Then
        Local $ioffset = 0x0
        For $i = 0x0 To Mod($iid, 0x10) + 0xffffffff
            $ioffset += 0x2 * (DllStructGetData(DllStructCreate("ushort", $pdata + $ioffset), 0x1) + 0x1)
        Next
        $sresult = DllStructGetData(DllStructCreate("ushort;wchar[" & DllStructGetData(DllStructCreate("ushort", $pdata + $ioffset), 0x1) & "]", $pdata + $ioffset), 0x2)
        If @error Then $sresult = ""
    Else
        Return SetError(0xa, 0x0, "")
    EndIf
    If $ilibrary Then
        _WinAPI_FreeLibrary($hmodule)
    EndIf
    Return SetError(Number(Not $sresult), 0x0, $sresult)
EndFunc   ;==>_WINAPI_LOADSTRINGEX
Func _WINAPI_LOCKRESOURCE($hdata)
    Local $acall = DllCall("kernel32.dll", "ptr", "LockResource", "handle", $hdata)
    If @error Then Return SetError(@error, @extended, 0x0)
    Return $acall[0x0]
EndFunc   ;==>_WINAPI_LOCKRESOURCE
Func _WINAPI_SETCARETBLINKTIME($iduration)
    Local $iprev = _WINAPI_GETCARETBLINKTIME()
    If Not $iprev Then Return SetError(@error + 0x14, @extended, 0x0)
    Local $acall = DllCall("user32.dll", "bool", "SetCaretBlinkTime", "uint", $iduration)
    If @error Or Not $acall[0x0] Then Return SetError(@error + 0xa, @extended, 0x0)
    Return $iprev
EndFunc   ;==>_WINAPI_SETCARETBLINKTIME
Func _WINAPI_SETCARETPOS($ix, $iy)
    Local $acall = DllCall("user32.dll", "int", "SetCaretPos", "int", $ix, "int", $iy)
    If @error Then Return SetError(@error, @extended, 0x0)
    Return $acall[0x0]
EndFunc   ;==>_WINAPI_SETCARETPOS
Func _WinAPI_SetCursor($hcursor)
    Local $acall = DllCall("user32.dll", "handle", "SetCursor", "handle", $hcursor)
    If @error Then Return SetError(@error, @extended, 0x0)
    Return $acall[0x0]
EndFunc   ;==>_WINAPI_SETCURSOR
Func _WINAPI_SETSYSTEMCURSOR($hcursor, $iid, $bcopy = False)
    If $bcopy Then
        $hcursor = _WINAPI_COPYCURSOR($hcursor)
    EndIf
    Local $acall = DllCall("user32.dll", "bool", "SetSystemCursor", "handle", $hcursor, "dword", $iid)
    If @error Then Return SetError(@error, @extended, False)
    Return $acall[0x0]
EndFunc   ;==>_WINAPI_SETSYSTEMCURSOR
Func _WINAPI_SHOWCARET($hwnd)
    Local $acall = DllCall("user32.dll", "bool", "ShowCaret", "hwnd", $hwnd)
    If @error Then Return SetError(@error, @extended, False)
    Return $acall[0x0]
EndFunc   ;==>_WINAPI_SHOWCARET
Func _WinAPI_ShowCursor($bshow)
    Local $acall = DllCall("user32.dll", "int", "ShowCursor", "bool", $bshow)
    If @error Then Return SetError(@error, @extended, 0x0)
    Return $acall[0x0]
EndFunc   ;==>_WINAPI_SHOWCURSOR
Func _WINAPI_SIZEOFRESOURCE($hinstance, $hresource)
    Local $acall = DllCall("kernel32.dll", "dword", "SizeofResource", "handle", $hinstance, "handle", $hresource)
    If @error Or Not $acall[0x0] Then Return SetError(@error, @extended, 0x0)
    Return $acall[0x0]
EndFunc   ;==>_WINAPI_SIZEOFRESOURCE
Func _WINAPI_UPDATERESOURCE($hupdate, $stype, $sname, $ilanguage, $pdata, $isize)
    Local $stypeoftype = "int", $stypeofname = "int"
    If IsString($stype) Then
        $stypeoftype = "wstr"
    EndIf
    If IsString($sname) Then
        $stypeofname = "wstr"
    EndIf
    Local $acall = DllCall("kernel32.dll", "bool", "UpdateResourceW", "handle", $hupdate, $stypeoftype, $stype, $stypeofname, $sname, "word", $ilanguage, "ptr", $pdata, "dword", $isize)
    If @error Then Return SetError(@error, @extended, False)
    Return $acall[0x0]
EndFunc   ;==>_WINAPI_UPDATERESOURCE
Func _WINAPI_VERQUERYROOT($pdata)
    Local $acall = DllCall("version.dll", "bool", "VerQueryValueW", "ptr", $pdata, "wstr", "\", "ptr*", 0x0, "uint*", 0x0)
    If @error Or Not $acall[0x0] Or Not $acall[0x4] Then Return SetError(@error + 0xa, @extended, 0x0)
    Local $tvffi = DllStructCreate($tagvs_fixedfileinfo)
    If Not _WINAPI_MOVEMEMORY($tvffi, $acall[0x3], $acall[0x4]) Then Return SetError(@error + 0x14, @extended, 0x0)
    Return $tvffi
EndFunc   ;==>_WINAPI_VERQUERYROOT
Func _WINAPI_VERQUERYVALUE($pdata, $svalues = "")
    $svalues = StringRegExpReplace($svalues, "\A[\s\|]*|[\s\|]*\Z", "")
    If Not $svalues Then
        $svalues = "Comments|CompanyName|FileDescription|FileVersion|InternalName|LegalCopyright|LegalTrademarks|OriginalFilename|ProductName|ProductVersion|PrivateBuild|SpecialBuild"
    EndIf
    $svalues = StringSplit($svalues, "|", $str_nocount)
    Local $acall = DllCall("version.dll", "bool", "VerQueryValueW", "ptr", $pdata, "wstr", "\VarFileInfo\Translation", "ptr*", 0x0, "uint*", 0x0)
    If @error Or Not $acall[0x0] Or Not $acall[0x4] Then Return SetError(@error + 0xa, 0x0, 0x0)
    Local $ilength = Floor($acall[0x4] / 0x4)
    Local $tlang = DllStructCreate("dword[" & $ilength & "]", $acall[0x3])
    If @error Then Return SetError(@error + 0x14, 0x0, 0x0)
    Local $scp, $ainfo[0x65][UBound($svalues) + 0x1] = [[0x0]]
    For $i = 0x1 To $ilength
        __INC($ainfo)
        $ainfo[$ainfo[0x0][0x0]][0x0] = _WinAPI_LoWord(DllStructGetData($tlang, 0x1, $i))
        $scp = Hex(_WinAPI_MakeLong(_WinAPI_HiWord(DllStructGetData($tlang, 0x1, $i)), _WinAPI_LoWord(DllStructGetData($tlang, 0x1, $i))), 0x8)
        For $j = 0x0 To UBound($svalues) + 0xffffffff
            $acall = DllCall("version.dll", "bool", "VerQueryValueW", "ptr", $pdata, "wstr", "\StringFileInfo\" & $scp & "\" & $svalues[$j], "ptr*", 0x0, "uint*", 0x0)
            If Not @error And $acall[0x0] And $acall[0x4] Then
                $ainfo[$ainfo[0x0][0x0]][$j + 0x1] = DllStructGetData(DllStructCreate("wchar[" & $acall[0x4] & "]", $acall[0x3]), 0x1)
            Else
                $ainfo[$ainfo[0x0][0x0]][$j + 0x1] = ""
            EndIf
        Next
    Next
    __INC($ainfo, +0xffffffff)
    Return $ainfo
EndFunc   ;==>_WINAPI_VERQUERYVALUE
Func _WINAPI_VERQUERYVALUEEX($hmodule, $svalues = "", $ilanguage = 0x400)
    $__g_vval = StringRegExpReplace($svalues, "\A[\s\|]*|[\s\|]*\Z", "")
    If Not $__g_vval Then
        $__g_vval = "Comments|CompanyName|FileDescription|FileVersion|InternalName|LegalCopyright|LegalTrademarks|OriginalFilename|ProductName|ProductVersion|PrivateBuild|SpecialBuild"
    EndIf
    $__g_vval = StringSplit($__g_vval, "|")
    If Not IsArray($__g_vval) Then Return SetError(0x1, 0x0, 0x0)
    Local $ilibrary = 0x0
    If IsString($hmodule) Then
        If StringStripWS($hmodule, $str_stripleading + $str_striptrailing) Then
            $hmodule = _WinAPI_LoadLibraryEx($hmodule, BitOR($dont_resolve_dll_references, $load_library_as_datafile))
            If Not $hmodule Then
                Return SetError(@error + 0xa, @extended, 0x0)
            EndIf
            $ilibrary = 0x1
        Else
            $hmodule = 0x0
        EndIf
    EndIf
    Dim $__g_venum[0x65][$__g_vval[0x0] + 0x1] = [[0x0]]
    Local $henumproc = DllCallbackRegister("__EnumVerValuesProc", "bool", "ptr;ptr;ptr;word;long_ptr")
    Local $acall = DllCall("kernel32.dll", "bool", "EnumResourceLanguagesW", "handle", $hmodule, "int", 0x10, "int", 0x1, "ptr", DllCallbackGetPtr($henumproc), "long_ptr", $ilanguage)
    Do
        If @error Then
            $__g_venum = @error + 0x14
        Else
            If Not $acall[0x0] Then
                Switch _WinAPI_GetLastError()
                    Case 0x0, 0x3b02
                        ExitLoop
                    Case Else
                        $__g_venum = 0x14
                EndSwitch
            Else
                ExitLoop
            EndIf
        EndIf
    Until 0x1
    If $ilibrary Then
        _WinAPI_FreeLibrary($hmodule)
    EndIf
    DllCallbackFree($henumproc)
    If Not $__g_venum[0x0][0x0] Then $__g_venum = 0xe6
    If $__g_venum Then Return SetError($__g_venum, 0x0, 0x0)
    __INC($__g_venum, +0xffffffff)
    Return $__g_venum
EndFunc   ;==>_WINAPI_VERQUERYVALUEEX
#endregion Public Functions
#region Internal Functions
Func __ENUMRESLANGUAGESPROC($hmodule, $itype, $iname, $ilanguage, $lparam)
    #forceref $hmodule, $itype, $iname, $lparam
    __INC($__g_venum)
    $__g_venum[$__g_venum[0x0]] = $ilanguage
    Return 0x1
EndFunc   ;==>__ENUMRESLANGUAGESPROC
Func __ENUMRESNAMESPROC($hmodule, $itype, $iname, $lparam)
    #forceref $hmodule, $itype, $lparam
    Local $ilength = _WINAPI_STRLEN($iname)
    __INC($__g_venum)
    If $ilength Then
        $__g_venum[$__g_venum[0x0]] = DllStructGetData(DllStructCreate("wchar[" & ($ilength + 0x1) & "]", $iname), 0x1)
    Else
        $__g_venum[$__g_venum[0x0]] = Number($iname)
    EndIf
    Return 0x1
EndFunc   ;==>__ENUMRESNAMESPROC
Func __ENUMRESTYPESPROC($hmodule, $itype, $lparam)
    #forceref $hmodule, $lparam
    Local $ilength = _WINAPI_STRLEN($itype)
    __INC($__g_venum)
    If $ilength Then
        $__g_venum[$__g_venum[0x0]] = DllStructGetData(DllStructCreate("wchar[" & ($ilength + 0x1) & "]", $itype), 0x1)
    Else
        $__g_venum[$__g_venum[0x0]] = Number($itype)
    EndIf
    Return 0x1
EndFunc   ;==>__ENUMRESTYPESPROC
Func __ENUMVERVALUESPROC($hmodule, $itype, $iname, $ilanguage, $idefault)
    Local $acall, $ienum = 0x1, $ierror = 0x0
    Switch $idefault
        Case +0xffffffff
        Case 0x400
            $ilanguage = 0x400
            $ienum = 0x0
        Case Else
            If $ilanguage <> $idefault Then
                Return 0x1
            EndIf
            $ienum = 0x0
    EndSwitch
    Do
        Local $pdata = __RESLOAD($hmodule, $itype, $iname, $ilanguage)
        If @error Then
            $ierror = @error + 0xa
            ExitLoop
        EndIf
        $acall = DllCall("version.dll", "bool", "VerQueryValueW", "ptr", $pdata, "wstr", "\VarFileInfo\Translation", "ptr*", 0x0, "uint*", 0x0)
        If @error Or Not $acall[0x0] Or Not $acall[0x4] Then
            $ierror = @error + 0x14
            ExitLoop
        EndIf
        Local $tdata = DllStructCreate("ushort;ushort", $acall[0x3])
        If @error Then
            $ierror = @error + 0x1e
            ExitLoop
        EndIf
    Until 0x1
    If Not $ierror Then
        __INC($__g_venum)
        $__g_venum[$__g_venum[0x0][0x0]][0x0] = DllStructGetData($tdata, 0x1)
        Local $scp = Hex(_WinAPI_MakeLong(DllStructGetData($tdata, 0x2), DllStructGetData($tdata, 0x1)), 0x8)
        For $i = 0x1 To $__g_vval[0x0]
            $acall = DllCall("version.dll", "bool", "VerQueryValueW", "ptr", $pdata, "wstr", "\StringFileInfo\" & $scp & "\" & $__g_vval[$i], "ptr*", 0x0, "uint*", 0x0)
            If Not @error And $acall[0x0] And $acall[0x4] Then
                $__g_venum[$__g_venum[0x0][0x0]][$i] = DllStructGetData(DllStructCreate("wchar[" & $acall[0x4] & "]", $acall[0x3]), 0x1)
            Else
                $__g_venum[$__g_venum[0x0][0x0]][$i] = ""
            EndIf
        Next
    Else
        $__g_venum = @error + 0x28
    EndIf
    If $__g_venum Then Return SetError($ierror, 0x0, 0x0)
    Return $ienum
EndFunc   ;==>__ENUMVERVALUESPROC
Func __RESLOAD($hinstance, $stype, $sname, $ilanguage)
    Local $hinfo = _WINAPI_FINDRESOURCEEX($hinstance, $stype, $sname, $ilanguage)
    If Not $hinfo Then Return SetError(@error + 0xa, @extended, 0x0)
    Local $isize = _WINAPI_SIZEOFRESOURCE($hinstance, $hinfo)
    If Not $isize Then Return SetError(@error + 0x14, @extended, 0x0)
    Local $hdata = _WINAPI_LOADRESOURCE($hinstance, $hinfo)
    If Not $hdata Then Return SetError(@error + 0x1e, @extended, 0x0)
    Local $pdata = _WINAPI_LOCKRESOURCE($hdata)
    If Not $pdata Then Return SetError(@error + 0x28, @extended, 0x0)
    Return SetExtended($isize, $pdata)
EndFunc   ;==>__RESLOAD
#endregion Internal Functions
Global Const $klf_activate = 0x1
Global Const $klf_notellshell = 0x80
Global Const $klf_reorder = 0x8
Global Const $klf_replacelang = 0x10
Global Const $klf_reset = 0x40000000
Global Const $klf_setforprocess = 0x100
Global Const $klf_shiftlock = 0x10000
Global Const $klf_substitute_ok = 0x2
Global Const $hkl_next = 0x1
Global Const $hkl_prev = 0x0
Global Const $aw_activate = 0x20000
Global Const $aw_blend = 0x80000
Global Const $aw_center = 0x10
Global Const $aw_hide = 0x10000
Global Const $aw_hor_negative = 0x2
Global Const $aw_hor_positive = 0x1
Global Const $aw_slide = 0x40000
Global Const $aw_ver_negative = 0x8
Global Const $aw_ver_positive = 0x4
Global Const $bsf_allowsfw = 0x80
Global Const $bsf_flushdisk = 0x4
Global Const $bsf_forceifhung = 0x20
Global Const $bsf_ignorecurrenttask = 0x2
Global Const $bsf_nohang = 0x8
Global Const $bsf_notimeoutifnothung = 0x40
Global Const $bsf_postmessage = 0x10
Global Const $bsf_query = 0x1
Global Const $bsf_sendnotifymessage = 0x100
Global Const $bsm_allcomponents = 0x0
Global Const $bsm_alldesktops = 0x8
Global Const $bsm_applications = 0x10
Global Const $bsm_installabledrivers = 0x4
Global Const $bsm_netdriver = 0x2
Global Const $bsm_vxds = 0x1
Global Const $mditile_horizontal = 0x1
Global Const $mditile_skipdisabled = 0x2
Global Const $mditile_vertical = 0x0
Global Const $mditile_zorder = 0x4
Global Const $msgflt_allow = 0x1
Global Const $msgflt_disallow = 0x2
Global Const $msgflt_reset = 0x0
Global Const $msgfltinfo_allowed_higher = 0x3
Global Const $msgfltinfo_alreadyallowed_forwnd = 0x1
Global Const $msgfltinfo_alreadydisallowed_forwnd = 0x2
Global Const $msgfltinfo_none = 0x0
Global Const $cwp_all = 0x0
Global Const $cwp_skipinvisible = 0x1
Global Const $cwp_skipdisabled = 0x2
Global Const $cwp_skiptransparent = 0x4
Global Const $compression_format_none = 0x0
Global Const $compression_format_default = 0x1
Global Const $compression_format_lznt1 = 0x2
Global Const $compression_format_xpress = 0x3
Global Const $compression_format_xpress_huff = 0x4
Global Const $compression_engine_standard = 0x0
Global Const $compression_engine_maximum = 0x100
Global Const $compression_engine_hiber = 0x200
Global Const $winsta_accessclipboard = 0x4
Global Const $winsta_accessglobalatoms = 0x20
Global Const $winsta_createdesktop = 0x8
Global Const $winsta_enumdesktops = 0x1
Global Const $winsta_enumerate = 0x100
Global Const $winsta_exitwindows = 0x40
Global Const $winsta_readattributes = 0x2
Global Const $winsta_readscreen = 0x200
Global Const $winsta_writeattributes = 0x10
Global Const $winsta_all_access = BitOR($winsta_accessclipboard, $winsta_accessglobalatoms, $winsta_createdesktop, $winsta_enumdesktops, $winsta_enumerate, $winsta_exitwindows, $winsta_readattributes, $winsta_readscreen, $winsta_writeattributes)
Global Const $cwf_create_only = 0x1
Global Const $gcl_cbclsextra = +0xffffffec
Global Const $gcl_cbwndextra = +0xffffffee
Global Const $gcl_hbrbackground = +0xfffffff6
Global Const $gcl_hcursor = +0xfffffff4
Global Const $gcl_hicon = +0xfffffff2
Global Const $gcl_hiconsm = +0xffffffde
Global Const $gcl_hmodule = +0xfffffff0
Global Const $gcl_menuname = +0xfffffff8
Global Const $gcl_style = +0xffffffe6
Global Const $gcl_wndproc = +0xffffffe8
Global Const $dockinfo_docked = 0x2
Global Const $dockinfo_undocked = 0x1
Global Const $dockinfo_user_supplied = 0x4
Global Const $dockinfo_user_docked = 0x5
Global Const $dockinfo_user_undocked = 0x6
Global Const $gui_caretblinking = 0x1
Global Const $gui_inmenumode = 0x4
Global Const $gui_inmovesize = 0x2
Global Const $gui_popupmenumode = 0x10
Global Const $gui_systemmenumode = 0x8
Global Const $handle_flag_inherit = 0x1
Global Const $handle_flag_protect_from_close = 0x2
Global Const $get_module_handle_ex_flag_from_address = 0x4
Global Const $get_module_handle_ex_flag_pin = 0x1
Global Const $get_module_handle_ex_flag_unchanged_refcount = 0x2
Global Const $get_module_handle_ex_flag_default = 0x0
Global Const $processor_architecture_amd64 = 0x9
Global Const $processor_architecture_ia64 = 0x6
Global Const $processor_architecture_intel = 0x0
Global Const $processor_architecture_unknown = 0xffff
Global Const $processor_intel_386 = 0x182
Global Const $processor_intel_486 = 0x1e6
Global Const $processor_intel_pentium = 0x24a
Global Const $processor_intel_ia64 = 0x898
Global Const $processor_amd_x8664 = 0x21d8
Global Const $uoi_flags = 0x1
Global Const $uoi_heapsize = 0x5
Global Const $uoi_io = 0x6
Global Const $uoi_name = 0x2
Global Const $uoi_type = 0x3
Global Const $uoi_user_sid = 0x4
Global Const $df_allowotheraccounthook = 0x1
Global Const $wsf_visible = 0x1
Global Const $ver_suite_backoffice = 0x4
Global Const $ver_suite_blade = 0x400
Global Const $ver_suite_compute_server = 0x4000
Global Const $ver_suite_datacenter = 0x80
Global Const $ver_suite_enterprise = 0x2
Global Const $ver_suite_embeddednt = 0x40
Global Const $ver_suite_personal = 0x200
Global Const $ver_suite_singleuserts = 0x100
Global Const $ver_suite_smallbusiness = 0x1
Global Const $ver_suite_smallbusiness_restricted = 0x20
Global Const $ver_suite_storage_server = 0x2000
Global Const $ver_suite_terminal = 0x10
Global Const $ver_suite_wh_server = 0x8000
Global Const $ver_nt_domain_controller = 0x2
Global Const $ver_nt_server = 0x3
Global Const $ver_nt_workstation = 0x1
Global Const $wda_monitor = 0x1
Global Const $wda_none = 0x0
Global Const $pf_3dnow_instructions_available = 0x7
Global Const $pf_channels_enabled = 0x10
Global Const $pf_compare_exchange_double = 0x2
Global Const $pf_compare_exchange128 = 0xe
Global Const $pf_compare64_exchange128 = 0xf
Global Const $pf_floating_point_emulated = 0x1
Global Const $pf_floating_point_precision_errata = 0x0
Global Const $pf_mmx_instructions_available = 0x3
Global Const $pf_nx_enabled = 0xc
Global Const $pf_pae_enabled = 0x9
Global Const $pf_rdtsc_instruction_available = 0x8
Global Const $pf_sse3_instructions_available = 0xd
Global Const $pf_xmmi_instructions_available = 0x6
Global Const $pf_xmmi64_instructions_available = 0xa
Global Const $pf_xsave_enabled = 0x11
Global Const $keyeventf_extendedkey = 0x1
Global Const $keyeventf_keyup = 0x2
Global Const $lim_small = 0x0
Global Const $lim_large = 0x1
Global Const $mapvk_vk_to_char = 0x2
Global Const $mapvk_vk_to_vsc = 0x0
Global Const $mapvk_vk_to_vsc_ex = 0x4
Global Const $mapvk_vsc_to_vk = 0x1
Global Const $mapvk_vsc_to_vk_ex = 0x3
Global Const $mod_alt = 0x1
Global Const $mod_control = 0x2
Global Const $mod_norepeat = 0x4000
Global Const $mod_shift = 0x4
Global Const $mod_win = 0x8
Global Const $guid_acdc_power_source = "{5D3E9A59-E9D5-4B00-A6BD-FF34FF516548}"
Global Const $guid_battery_percentage_remaining = "{A7AD8041-B45A-4CAE-87A3-EECBB468A9E1}"
Global Const $guid_idle_background_task = "{515C31D8-F734-163D-A0FD-11A08C91E8F1}"
Global Const $guid_monitor_power_on = "{02731015-4510-4526-99E6-E5A17EBD1AEA}"
Global Const $guid_powerscheme_personality = "{245D8541-3943-4422-B025-13A784F679B7}"
Global Const $guid_system_awaymode = "{98A7F580-01F7-48AA-9C0F-44352C29E5C0}"
Global Const $guid_min_power_savings = "{8C5E7FDA-E8BF-4A96-9A85-A6E23A8C635C}"
Global Const $guid_max_power_savings = "{A1841308-3541-4FAB-BC81-F71556F20B4A}"
Global Const $guid_typical_power_savings = "{381B4222-F694-41F0-9685-FF5BB260DF2E}"
Global Const $hshell_windowcreated = 0x1
Global Const $hshell_windowdestroyed = 0x2
Global Const $hshell_activateshellwindow = 0x3
Global Const $hshell_windowactivated = 0x4
Global Const $hshell_getminrect = 0x5
Global Const $hshell_redraw = 0x6
Global Const $hshell_taskman = 0x7
Global Const $hshell_language = 0x8
Global Const $hshell_sysmenu = 0x9
Global Const $hshell_endtask = 0xa
Global Const $hshell_accessibilitystate = 0xb
Global Const $hshell_appcommand = 0xc
Global Const $hshell_windowreplaced = 0xd
Global Const $hshell_windowreplacing = 0xe
Global Const $hshell_rudeappactivated = 0x8004
Global Const $hshell_flash = 0x8006
Global Const $hwnd_broadcast = 0xffff
Global Const $smto_block = 0x1
Global Const $smto_normal = 0x0
Global Const $smto_abortifhung = 0x2
Global Const $smto_notimeoutifnothung = 0x8
Global Const $smto_erroronexit = 0x20
Global Const $inputlangchange_backward = 0x4
Global Const $inputlangchange_forward = 0x2
Global Const $inputlangchange_syscharset = 0x1
Global Const $event_min = 0x1
Global Const $event_system_sound = 0x1
Global Const $event_system_alert = 0x2
Global Const $event_system_foreground = 0x3
Global Const $event_system_menustart = 0x4
Global Const $event_system_menuend = 0x5
Global Const $event_system_menupopupstart = 0x6
Global Const $event_system_menupopupend = 0x7
Global Const $event_system_capturestart = 0x8
Global Const $event_system_captureend = 0x9
Global Const $event_system_movesizestart = 0xa
Global Const $event_system_movesizeend = 0xb
Global Const $event_system_contexthelpstart = 0xc
Global Const $event_system_contexthelpend = 0xd
Global Const $event_system_dragdropstart = 0xe
Global Const $event_system_dragdropend = 0xf
Global Const $event_system_dialogstart = 0x10
Global Const $event_system_dialogend = 0x11
Global Const $event_system_scrollingstart = 0x12
Global Const $event_system_scrollingend = 0x13
Global Const $event_system_switchstart = 0x14
Global Const $event_system_switchend = 0x15
Global Const $event_system_minimizestart = 0x16
Global Const $event_system_minimizeend = 0x17
Global Const $event_system_desktopswitch = 0x20
Global Const $event_object_create = 0x8000
Global Const $event_object_destroy = 0x8001
Global Const $event_object_show = 0x8002
Global Const $event_object_hide = 0x8003
Global Const $event_object_reorder = 0x8004
Global Const $event_object_focus = 0x8005
Global Const $event_object_selection = 0x8006
Global Const $event_object_selectionadd = 0x8007
Global Const $event_object_selectionremove = 0x8008
Global Const $event_object_selectionwithin = 0x8009
Global Const $event_object_statechange = 0x800a
Global Const $event_object_locationchange = 0x800b
Global Const $event_object_namechange = 0x800c
Global Const $event_object_descriptionchange = 0x800d
Global Const $event_object_valuechange = 0x800e
Global Const $event_object_parentchange = 0x800f
Global Const $event_object_helpchange = 0x8010
Global Const $event_object_defactionchange = 0x8011
Global Const $event_object_acceleratorchange = 0x8012
Global Const $event_object_invoked = 0x8013
Global Const $event_object_textselectionchanged = 0x8014
Global Const $event_object_contentscrolled = 0x8015
Global Const $event_max = 0x7fffffff
Global Const $winevent_incontext = 0x4
Global Const $winevent_outofcontext = 0x0
Global Const $winevent_skipownprocess = 0x2
Global Const $winevent_skipownthread = 0x1
Global Const $tme_cancel = 0x80000000
Global Const $tme_hover = 0x1
Global Const $tme_leave = 0x2
Global Const $tme_nonclient = 0x10
Global Const $tme_query = 0x40000000
Global Const $desktop_createmenu = 0x4
Global Const $desktop_createwindow = 0x2
Global Const $desktop_enumerate = 0x40
Global Const $desktop_hookcontrol = 0x8
Global Const $desktop_journalplayback = 0x20
Global Const $desktop_journalrecord = 0x10
Global Const $desktop_readobjects = 0x1
Global Const $desktop_switchdesktop = 0x100
Global Const $desktop_writeobjects = 0x80
Global Const $desktop_all_access = BitOR($desktop_createmenu, $desktop_createwindow, $desktop_enumerate, $desktop_hookcontrol, $desktop_journalplayback, $desktop_journalrecord, $desktop_readobjects, $desktop_switchdesktop, $desktop_writeobjects)
Global Const $ridev_appkeys = 0x400
Global Const $ridev_capturemouse = 0x200
Global Const $ridev_devnotify = 0x2000
Global Const $ridev_exclude = 0x10
Global Const $ridev_exinputsink = 0x1000
Global Const $ridev_inputsink = 0x100
Global Const $ridev_nohotkeys = 0x200
Global Const $ridev_nolegacy = 0x30
Global Const $ridev_pageonly = 0x20
Global Const $ridev_remove = 0x1
Global Const $rid_header = 0x10000005
Global Const $rid_input = 0x10000003
Global Const $rim_typehid = 0x2
Global Const $rim_typekeyboard = 0x1
Global Const $rim_typemouse = 0x0
Global Const $ridi_devicename = 0x20000007
Global Const $ridi_deviceinfo = 0x2000000b
Global Const $ridi_preparseddata = 0x20000005
Global Const $mouse_attributes_changed = 0x4
Global Const $mouse_move_absolute = 0x1
Global Const $mouse_move_relative = 0x0
Global Const $mouse_virtual_desktop = 0x2
Global Const $ri_mouse_left_button_down = 0x1
Global Const $ri_mouse_left_button_up = 0x2
Global Const $ri_mouse_middle_button_down = 0x10
Global Const $ri_mouse_middle_button_up = 0x20
Global Const $ri_mouse_right_button_down = 0x4
Global Const $ri_mouse_right_button_up = 0x8
Global Const $ri_mouse_button_1_down = $ri_mouse_left_button_down
Global Const $ri_mouse_button_1_up = $ri_mouse_left_button_up
Global Const $ri_mouse_button_2_down = $ri_mouse_right_button_down
Global Const $ri_mouse_button_2_up = $ri_mouse_right_button_up
Global Const $ri_mouse_button_3_down = $ri_mouse_middle_button_down
Global Const $ri_mouse_button_3_up = $ri_mouse_middle_button_up
Global Const $ri_mouse_button_4_down = 0x40
Global Const $ri_mouse_button_4_up = 0x80
Global Const $ri_mouse_button_5_down = 0x100
Global Const $ri_mouse_button_5_up = 0x200
Global Const $ri_mouse_wheel = 0x400
Global Const $ri_key_break = 0x1
Global Const $ri_key_e0 = 0x2
Global Const $ri_key_e1 = 0x4
Global Const $ri_key_make = 0x0
#region Global Variables and Constants
Global $__g_ainprocess_winapi[0x40][0x2] = [[0x0, 0x0]]
Global $__g_awinlist_winapi[0x40][0x2] = [[0x0, 0x0]]
Global Const $gw_hwndfirst = 0x0
Global Const $gw_hwndlast = 0x1
Global Const $gw_hwndnext = 0x2
Global Const $gw_hwndprev = 0x3
Global Const $gw_owner = 0x4
Global Const $gw_child = 0x5
Global Const $gw_enabledpopup = 0x6
Global Const $gwl_wndproc = 0xfffffffc
Global Const $gwl_hinstance = 0xfffffffa
Global Const $gwl_hwndparent = 0xfffffff8
Global Const $gwl_id = 0xfffffff4
Global Const $gwl_style = 0xfffffff0
Global Const $gwl_exstyle = 0xffffffec
Global Const $gwl_userdata = 0xffffffeb
Global Const $__winapiconstant_wm_setfont = 0x30
#endregion Global Variables and Constants
#region Functions list
#endregion Functions list
#region Public Functions
Func _WinAPI_CreateWindowEx($iexstyle, $sclass, $sname, $istyle, $ix, $iy, $iwidth, $iheight, $hparent, $hmenu = 0x0, $hinstance = 0x0, $pparam = 0x0)
    If $hinstance = 0x0 Then $hinstance = _WinAPI_GetModuleHandle("")
    Local $acall = DllCall("user32.dll", "hwnd", "CreateWindowExW", "dword", $iexstyle, "wstr", $sclass, "wstr", $sname, "dword", $istyle, "int", $ix, "int", $iy, "int", $iwidth, "int", $iheight, "hwnd", $hparent, "handle", $hmenu, "handle", $hinstance, "struct*", $pparam)
    If @error Then Return SetError(@error, @extended, 0x0)
    Return $acall[0x0]
EndFunc   ;==>_WINAPI_CREATEWINDOWEX
Func _WinAPI_GetClientRect($hwnd)
    Local $trect = DllStructCreate($tagrect)
    Local $acall = DllCall("user32.dll", "bool", "GetClientRect", "hwnd", $hwnd, "struct*", $trect)
    If @error Or Not $acall[0x0] Then Return SetError(@error + 0xa, @extended, 0x0)
    Return $trect
EndFunc   ;==>_WINAPI_GETCLIENTRECT
Func _WinAPI_GetDesktopWindow()
    Local $acall = DllCall("user32.dll", "hwnd", "GetDesktopWindow")
    If @error Then Return SetError(@error, @extended, 0x0)
    Return $acall[0x0]
EndFunc   ;==>_WINAPI_GETDESKTOPWINDOW
Func _WinAPI_DestroyWindow($hwnd)
    Local $acall = DllCall("user32.dll", "bool", "DestroyWindow", "hwnd", $hwnd)
    If @error Then Return SetError(@error, @extended, False)
    Return $acall[0x0]
EndFunc   ;==>_WINAPI_DESTROYWINDOW
Func _WinAPI_EnableWindow($hwnd, $benable = True)
    Local $acall = DllCall("user32.dll", "bool", "EnableWindow", "hwnd", $hwnd, "bool", $benable)
    If @error Then Return SetError(@error, @extended, False)
    Return $acall[0x0]
EndFunc   ;==>_WINAPI_ENABLEWINDOW
Func _WinAPI_EnumWindows($bvisible = True, $hwnd = Default)
    __WINAPI_ENUMWINDOWSINIT()
    If $hwnd = Default Then $hwnd = _WinAPI_GetDesktopWindow()
    __WINAPI_ENUMWINDOWSCHILD($hwnd, $bvisible)
    Return $__g_awinlist_winapi
EndFunc   ;==>_WINAPI_ENUMWINDOWS
Func _WinAPI_EnumWindowsPopup()
    __WINAPI_ENUMWINDOWSINIT()
    Local $hwnd = _WinAPI_GetWindow(_WinAPI_GetDesktopWindow(), $gw_child)
    Local $sclass
    While $hwnd <> 0x0
        If _WinAPI_IsWindowVisible($hwnd) Then
            $sclass = _WinAPI_GetClassName($hwnd)
            If $sclass = "#32768" Then
                __WINAPI_ENUMWINDOWSADD($hwnd)
            ElseIf $sclass = "ToolbarWindow32" Then
                __WINAPI_ENUMWINDOWSADD($hwnd)
            ElseIf $sclass = "ToolTips_Class32" Then
                __WINAPI_ENUMWINDOWSADD($hwnd)
            ElseIf $sclass = "BaseBar" Then
                __WINAPI_ENUMWINDOWSCHILD($hwnd)
            EndIf
        EndIf
        $hwnd = _WinAPI_GetWindow($hwnd, $gw_hwndnext)
    WEnd
    Return $__g_awinlist_winapi
EndFunc   ;==>_WINAPI_ENUMWINDOWSPOPUP
Func _WinAPI_EnumWindowsTop()
    __WINAPI_ENUMWINDOWSINIT()
    Local $hwnd = _WinAPI_GetWindow(_WinAPI_GetDesktopWindow(), $gw_child)
    While $hwnd <> 0x0
        If _WinAPI_IsWindowVisible($hwnd) Then __WINAPI_ENUMWINDOWSADD($hwnd)
        $hwnd = _WinAPI_GetWindow($hwnd, $gw_hwndnext)
    WEnd
    Return $__g_awinlist_winapi
EndFunc   ;==>_WINAPI_ENUMWINDOWSTOP
Func _WinAPI_GetClassName($hwnd)
    If Not IsHWnd($hwnd) Then $hwnd = GUICtrlGetHandle($hwnd)
    Local $acall = DllCall("user32.dll", "int", "GetClassNameW", "hwnd", $hwnd, "wstr", "", "int", 0x1000)
    If @error Or Not $acall[0x0] Then Return SetError(@error, @extended, "")
    Return SetExtended($acall[0x0], $acall[0x2])
EndFunc   ;==>_WINAPI_GETCLASSNAME
Func _WinAPI_GetFocus()
    Local $acall = DllCall("user32.dll", "hwnd", "GetFocus")
    If @error Then Return SetError(@error, @extended, 0x0)
    Return $acall[0x0]
EndFunc   ;==>_WINAPI_GETFOCUS
Func _WinAPI_GetParent($hwnd)
    Local $acall = DllCall("user32.dll", "hwnd", "GetParent", "hwnd", $hwnd)
    If @error Then Return SetError(@error, @extended, 0x0)
    Return $acall[0x0]
EndFunc   ;==>_WINAPI_GETPARENT
Func _WinAPI_GetSysColor($iindex)
    Local $acall = DllCall("user32.dll", "INT", "GetSysColor", "int", $iindex)
    If @error Then Return SetError(@error, @extended, 0x0)
    Return $acall[0x0]
EndFunc   ;==>_WINAPI_GETSYSCOLOR
Func _WinAPI_GetSystemMetrics($iindex)
    Local $acall = DllCall("user32.dll", "int", "GetSystemMetrics", "int", $iindex)
    If @error Then Return SetError(@error, @extended, 0x0)
    Return $acall[0x0]
EndFunc   ;==>_WINAPI_GETSYSTEMMETRICS
Func _WinAPI_GetWindow($hwnd, $icmd)
    Local $acall = DllCall("user32.dll", "hwnd", "GetWindow", "hwnd", $hwnd, "uint", $icmd)
    If @error Then Return SetError(@error, @extended, 0x0)
    Return $acall[0x0]
EndFunc   ;==>_WINAPI_GETWINDOW
Func _WinAPI_GetWindowHeight($hwnd)
    Local $trect = _WinAPI_GetWindowRect($hwnd)
    If @error Then Return SetError(@error, @extended, 0x0)
    Return DllStructGetData($trect, "Bottom") - DllStructGetData($trect, "Top")
EndFunc   ;==>_WINAPI_GETWINDOWHEIGHT
Func _WinAPI_GetWindowLong($hwnd, $iindex)
    Local $sfuncname = "GetWindowLongW"
    If @AutoItX64 Then $sfuncname = "GetWindowLongPtrW"
    Local $acall = DllCall("user32.dll", "long_ptr", $sfuncname, "hwnd", $hwnd, "int", $iindex)
    If @error Or Not $acall[0x0] Then Return SetError(@error + 0xa, @extended, 0x0)
    Return $acall[0x0]
EndFunc   ;==>_WINAPI_GETWINDOWLONG
Func _WinAPI_GetWindowRect($hwnd)
    Local $trect = DllStructCreate($tagrect)
    Local $acall = DllCall("user32.dll", "bool", "GetWindowRect", "hwnd", $hwnd, "struct*", $trect)
    If @error Or Not $acall[0x0] Then Return SetError(@error + 0xa, @extended, 0x0)
    Return $trect
EndFunc   ;==>_WINAPI_GETWINDOWRECT
Func _WinAPI_GetWindowText($hwnd)
    Local $acall = DllCall("user32.dll", "int", "GetWindowTextW", "hwnd", $hwnd, "wstr", "", "int", 0x1000)
    If @error Or Not $acall[0x0] Then Return SetError(@error + 0xa, @extended, "")
    Return SetExtended($acall[0x0], $acall[0x2])
EndFunc   ;==>_WINAPI_GETWINDOWTEXT
Func _WinAPI_GetWindowThreadProcessId($hwnd, ByRef $ipid)
    Local $acall = DllCall("user32.dll", "dword", "GetWindowThreadProcessId", "hwnd", $hwnd, "dword*", 0x0)
    If @error Then Return SetError(@error, @extended, 0x0)
    $ipid = $acall[0x2]
    Return $acall[0x0]
EndFunc   ;==>_WINAPI_GETWINDOWTHREADPROCESSID
Func _WinAPI_GetWindowWidth($hwnd)
    Local $trect = _WinAPI_GetWindowRect($hwnd)
    If @error Then Return SetError(@error, @extended, 0x0)
    Return DllStructGetData($trect, "Right") - DllStructGetData($trect, "Left")
EndFunc   ;==>_WINAPI_GETWINDOWWIDTH
Func _WinAPI_InProcess($hwnd, ByRef $hlastwnd)
    If $hwnd = $hlastwnd Then Return True
    For $ii = $__g_ainprocess_winapi[0x0][0x0] To 0x1 Step +0xffffffff
        If $hwnd = $__g_ainprocess_winapi[$ii][0x0] Then
            If $__g_ainprocess_winapi[$ii][0x1] Then
                $hlastwnd = $hwnd
                Return True
            Else
                Return False
            EndIf
        EndIf
    Next
    Local $ipid
    _WinAPI_GetWindowThreadProcessId($hwnd, $ipid)
    Local $icount = $__g_ainprocess_winapi[0x0][0x0] + 0x1
    If $icount >= 0x40 Then $icount = 0x1
    $__g_ainprocess_winapi[0x0][0x0] = $icount
    $__g_ainprocess_winapi[$icount][0x0] = $hwnd
    $__g_ainprocess_winapi[$icount][0x1] = ($ipid = @AutoItPID)
    Return $__g_ainprocess_winapi[$icount][0x1]
EndFunc   ;==>_WINAPI_INPROCESS
Func _WinAPI_InvalidateRect($hwnd, $trect = 0x0, $berase = True)
    If Not IsHWnd($hwnd) Then $hwnd = GUICtrlGetHandle($hwnd)
    Local $acall = DllCall("user32.dll", "bool", "InvalidateRect", "hwnd", $hwnd, "struct*", $trect, "bool", $berase)
    If @error Then Return SetError(@error, @extended, False)
    Return $acall[0x0]
EndFunc   ;==>_WINAPI_INVALIDATERECT
Func _WinAPI_IsClassName($hwnd, $sclassname)
    Local $sseparator = Opt("GUIDataSeparatorChar")
    Local $aclassname = StringSplit($sclassname, $sseparator)
    If Not IsHWnd($hwnd) Then $hwnd = GUICtrlGetHandle($hwnd)
    Local $sclasscheck = _WinAPI_GetClassName($hwnd)
    For $x = 0x1 To UBound($aclassname) + 0xffffffff
        If StringUpper(StringMid($sclasscheck, 0x1, StringLen($aclassname[$x]))) = StringUpper($aclassname[$x]) Then Return True
    Next
    Return False
EndFunc   ;==>_WINAPI_ISCLASSNAME
Func _WinAPI_IsWindow($hwnd)
    Local $acall = DllCall("user32.dll", "bool", "IsWindow", "hwnd", $hwnd)
    If @error Then Return SetError(@error, @extended, 0x0)
    Return $acall[0x0]
EndFunc   ;==>_WINAPI_ISWINDOW
Func _WinAPI_IsWindowVisible($hwnd)
    Local $acall = DllCall("user32.dll", "bool", "IsWindowVisible", "hwnd", $hwnd)
    If @error Then Return SetError(@error, @extended, 0x0)
    Return $acall[0x0]
EndFunc   ;==>_WINAPI_ISWINDOWVISIBLE
Func _WinAPI_MoveWindow($hwnd, $ix, $iy, $iwidth, $iheight, $brepaint = True)
    Local $acall = DllCall("user32.dll", "bool", "MoveWindow", "hwnd", $hwnd, "int", $ix, "int", $iy, "int", $iwidth, "int", $iheight, "bool", $brepaint)
    If @error Then Return SetError(@error, @extended, False)
    Return $acall[0x0]
EndFunc   ;==>_WINAPI_MOVEWINDOW
Func _WinAPI_SetFocus($hwnd)
    Local $acall = DllCall("user32.dll", "hwnd", "SetFocus", "hwnd", $hwnd)
    If @error Then Return SetError(@error, @extended, 0x0)
    Return $acall[0x0]
EndFunc   ;==>_WINAPI_SETFOCUS
Func _WinAPI_SetFont($hwnd, $hfont, $bredraw = True)
    _SendMessage($hwnd, $__winapiconstant_wm_setfont, $hfont, $bredraw, 0x0, "hwnd")
EndFunc   ;==>_WINAPI_SETFONT
Func _WinAPI_SetParent($hwndchild, $hwndparent)
    Local $acall = DllCall("user32.dll", "hwnd", "SetParent", "hwnd", $hwndchild, "hwnd", $hwndparent)
    If @error Then Return SetError(@error, @extended, 0x0)
    Return $acall[0x0]
EndFunc   ;==>_WINAPI_SETPARENT
Func _WinAPI_SetWindowPos($hwnd, $hafter, $ix, $iy, $icx, $icy, $iflags)
    Local $acall = DllCall("user32.dll", "bool", "SetWindowPos", "hwnd", $hwnd, "hwnd", $hafter, "int", $ix, "int", $iy, "int", $icx, "int", $icy, "uint", $iflags)
    If @error Then Return SetError(@error, @extended, False)
    Return $acall[0x0]
EndFunc   ;==>_WINAPI_SETWINDOWPOS
Func _WinAPI_SetWindowText($hwnd, $stext)
    Local $acall = DllCall("user32.dll", "bool", "SetWindowTextW", "hwnd", $hwnd, "wstr", $stext)
    If @error Then Return SetError(@error, @extended, False)
    Return $acall[0x0]
EndFunc   ;==>_WINAPI_SETWINDOWTEXT
Func _WinAPI_ShowWindow($hwnd, $icmdshow = 0x5)
    Local $acall = DllCall("user32.dll", "bool", "ShowWindow", "hwnd", $hwnd, "int", $icmdshow)
    If @error Then Return SetError(@error, @extended, False)
    Return $acall[0x0]
EndFunc   ;==>_WINAPI_SHOWWINDOW
Func _WinAPI_UpdateWindow($hwnd)
    Local $acall = DllCall("user32.dll", "bool", "UpdateWindow", "hwnd", $hwnd)
    If @error Then Return SetError(@error, @extended, False)
    Return $acall[0x0]
EndFunc   ;==>_WINAPI_UPDATEWINDOW
#endregion Public Functions
#region Internal Functions
Func __WINAPI_ENUMWINDOWSADD($hwnd, $sclass = "")
    If $sclass = "" Then $sclass = _WinAPI_GetClassName($hwnd)
    $__g_awinlist_winapi[0x0][0x0] += 0x1
    Local $icount = $__g_awinlist_winapi[0x0][0x0]
    If $icount >= $__g_awinlist_winapi[0x0][0x1] Then
        ReDim $__g_awinlist_winapi[$icount + 0x40][0x2]
        $__g_awinlist_winapi[0x0][0x1] += 0x40
    EndIf
    $__g_awinlist_winapi[$icount][0x0] = $hwnd
    $__g_awinlist_winapi[$icount][0x1] = $sclass
EndFunc   ;==>__WINAPI_ENUMWINDOWSADD
Func __WINAPI_ENUMWINDOWSCHILD($hwnd, $bvisible = True)
    $hwnd = _WinAPI_GetWindow($hwnd, $gw_child)
    While $hwnd <> 0x0
        If (Not $bvisible) Or _WinAPI_IsWindowVisible($hwnd) Then
            __WINAPI_ENUMWINDOWSADD($hwnd)
            __WINAPI_ENUMWINDOWSCHILD($hwnd, $bvisible)
        EndIf
        $hwnd = _WinAPI_GetWindow($hwnd, $gw_hwndnext)
    WEnd
EndFunc   ;==>__WINAPI_ENUMWINDOWSCHILD
Func __WINAPI_ENUMWINDOWSINIT()
    ReDim $__g_awinlist_winapi[0x40][0x2]
    $__g_awinlist_winapi[0x0][0x0] = 0x0
    $__g_awinlist_winapi[0x0][0x1] = 0x40
EndFunc   ;==>__WINAPI_ENUMWINDOWSINIT
#endregion Internal Functions
#region Global Variables and Constants
Global Const $flashw_caption = 0x1
Global Const $flashw_tray = 0x2
Global Const $flashw_timer = 0x4
Global Const $flashw_timernofg = 0xc
Global Const $tagupdatelayeredwindowinfo = "dword Size;hwnd hDstDC;long DstX;long DstY;long cX;long cY;hwnd hSrcDC;long SrcX;long SrcY;dword crKey;byte BlendOp;byte BlendFlags;byte Alpha;byte AlphaFormat;dword Flags;long DirtyLeft;long DirtyTop;long DirtyRight;long DirtyBottom"
Global Const $tagwindowinfo = "dword Size;struct;long rWindow[4];endstruct;struct;long rClient[4];endstruct;dword Style;dword ExStyle;dword WindowStatus;uint cxWindowBorders;uint cyWindowBorders;word atomWindowType;word CreatorVersion"
Global Const $tagwndclass = "uint Style;ptr hWndProc;int ClsExtra;int WndExtra;ptr hInstance;ptr hIcon;ptr hCursor;ptr hBackground;ptr MenuName;ptr ClassName"
Global Const $tagwndclassex = "uint Size;uint Style;ptr hWndProc;int ClsExtra;int WndExtra;ptr hInstance;ptr hIcon;ptr hCursor;ptr hBackground;ptr MenuName;ptr ClassName;ptr hIconSm"
#endregion Global Variables and Constants
#region Functions list
#endregion Functions list
Global Const $tagflashwinfo = "uint Size;hwnd hWnd;dword Flags;uint Count;dword TimeOut"
#region Public Functions
Func _WINAPI_ADJUSTWINDOWRECTEX(ByRef $trect, $istyle, $iexstyle = 0x0, $bmenu = False)
    Local $acall = DllCall("user32.dll", "bool", "AdjustWindowRectEx", "struct*", $trect, "dword", $istyle, "bool", $bmenu, "dword", $iexstyle)
    If @error Then Return SetError(@error, @extended, False)
    Return $acall[0x0]
EndFunc   ;==>_WINAPI_ADJUSTWINDOWRECTEX
Func _WINAPI_ANIMATEWINDOW($hwnd, $iflags, $iduration = 0x3e8)
    Local $acall = DllCall("user32.dll", "bool", "AnimateWindow", "hwnd", $hwnd, "dword", $iduration, "dword", $iflags)
    If @error Then Return SetError(@error, @extended, False)
    Return $acall[0x0]
EndFunc   ;==>_WINAPI_ANIMATEWINDOW
Func _WINAPI_BEGINDEFERWINDOWPOS($iamount = 0x1)
    Local $acall = DllCall("user32.dll", "handle", "BeginDeferWindowPos", "int", $iamount)
    If @error Then Return SetError(@error, @extended, 0x0)
    Return $acall[0x0]
EndFunc   ;==>_WINAPI_BEGINDEFERWINDOWPOS
Func _WINAPI_BRINGWINDOWTOTOP($hwnd)
    Local $acall = DllCall("user32.dll", "bool", "BringWindowToTop", "hwnd", $hwnd)
    If @error Then Return SetError(@error, @extended, False)
    Return $acall[0x0]
EndFunc   ;==>_WINAPI_BRINGWINDOWTOTOP
Func _WINAPI_BROADCASTSYSTEMMESSAGE($imsg, $wparam = 0x0, $lparam = 0x0, $iflags = 0x0, $irecipients = 0x0)
    Local $acall = DllCall("user32.dll", "long", "BroadcastSystemMessageW", "dword", $iflags, "dword*", $irecipients, "uint", $imsg, "wparam", $wparam, "lparam", $lparam)
    If @error Or ($acall[0x0] = +0xffffffff) Then Return SetError(@error, @extended, +0xffffffff)
    Return SetExtended($acall[0x2], $acall[0x0])
EndFunc   ;==>_WINAPI_BROADCASTSYSTEMMESSAGE
Func _WinAPI_CallWindowProc($pprevwndfunc, $hwnd, $imsg, $wparam, $lparam)
    Local $acall = DllCall("user32.dll", "lresult", "CallWindowProc", "ptr", $pprevwndfunc, "hwnd", $hwnd, "uint", $imsg, "wparam", $wparam, "lparam", $lparam)
    If @error Then Return SetError(@error, @extended, +0xffffffff)
    Return $acall[0x0]
EndFunc   ;==>_WINAPI_CALLWINDOWPROC
Func _WINAPI_CALLWINDOWPROCW($pprevwndproc, $hwnd, $imsg, $wparam, $lparam)
    Local $acall = DllCall("user32.dll", "lresult", "CallWindowProcW", "ptr", $pprevwndproc, "hwnd", $hwnd, "uint", $imsg, "wparam", $wparam, "lparam", $lparam)
    If @error Then Return SetError(@error, @extended, 0x0)
    Return $acall[0x0]
EndFunc   ;==>_WINAPI_CALLWINDOWPROCW
Func _WINAPI_CASCADEWINDOWS($awnds, $trect = 0x0, $hparent = 0x0, $iflags = 0x0, $istart = 0x0, $iend = +0xffffffff)
    If __CHECKERRORARRAYBOUNDS($awnds, $istart, $iend) Then Return SetError(@error + 0xa, @extended, 0x0)
    Local $icount = $iend - $istart + 0x1
    Local $twnds = DllStructCreate("hwnd[" & $icount & "]")
    $icount = 0x1
    For $i = $istart To $iend
        DllStructSetData($twnds, 0x1, $awnds[$i], $icount)
        $icount += 0x1
    Next
    Local $acall = DllCall("user32.dll", "word", "CascadeWindows", "hwnd", $hparent, "uint", $iflags, "struct*", $trect, "uint", $icount + 0xffffffff, "struct*", $twnds)
    If @error Or Not $acall[0x0] Then Return SetError(@error + 0xa, @extended, 0x0)
    Return $acall[0x0]
EndFunc   ;==>_WINAPI_CASCADEWINDOWS
Func _WINAPI_CHANGEWINDOWMESSAGEFILTEREX($hwnd, $imsg, $iaction)
    Local $tcfs, $acall
    If $hwnd And (_WINAPI_GETVERSION() > 6) Then
        Local Const $tagchangefilterstruct = "dword cbSize; dword ExtStatus"
        $tcfs = DllStructCreate($tagchangefilterstruct)
        DllStructSetData($tcfs, 0x1, DllStructGetSize($tcfs))
        $acall = DllCall("user32.dll", "bool", "ChangeWindowMessageFilterEx", "hwnd", $hwnd, "uint", $imsg, "dword", $iaction, "struct*", $tcfs)
    Else
        $tcfs = 0x0
        $acall = DllCall("user32.dll", "bool", "ChangeWindowMessageFilter", "uint", $imsg, "dword", $iaction)
    EndIf
    If @error Or Not $acall[0x0] Then Return SetError(@error + 0xa, @extended, 0x0)
    Return SetExtended(DllStructGetData($tcfs, 0x2), 0x1)
EndFunc   ;==>_WINAPI_CHANGEWINDOWMESSAGEFILTEREX
Func _WINAPI_CHILDWINDOWFROMPOINTEX($hwnd, $tpoint, $iflags = 0x0)
    Local $acall = DllCall("user32.dll", "hwnd", "ChildWindowFromPointEx", "hwnd", $hwnd, "struct", $tpoint, "uint", $iflags)
    If @error Then Return SetError(@error, @extended, 0x0)
    Return $acall[0x0]
EndFunc   ;==>_WINAPI_CHILDWINDOWFROMPOINTEX
Func _WINAPI_CLOSEWINDOW($hwnd)
    Local $acall = DllCall("user32.dll", "bool", "CloseWindow", "hwnd", $hwnd)
    If @error Then Return SetError(@error, @extended, False)
    Return $acall[0x0]
EndFunc   ;==>_WINAPI_CLOSEWINDOW
Func _WINAPI_DEFERWINDOWPOS($hinfo, $hwnd, $hafter, $ix, $iy, $iwidth, $iheight, $iflags)
    Local $acall = DllCall("user32.dll", "handle", "DeferWindowPos", "handle", $hinfo, "hwnd", $hwnd, "hwnd", $hafter, "int", $ix, "int", $iy, "int", $iwidth, "int", $iheight, "uint", $iflags)
    If @error Then Return SetError(@error, @extended, 0x0)
    Return $acall[0x0]
EndFunc   ;==>_WINAPI_DEFERWINDOWPOS
Func _WinAPI_DefWindowProc($hwnd, $imsg, $wparam, $lparam)
    Local $acall = DllCall("user32.dll", "lresult", "DefWindowProc", "hwnd", $hwnd, "uint", $imsg, "wparam", $wparam, "lparam", $lparam)
    If @error Then Return SetError(@error, @extended, 0x0)
    Return $acall[0x0]
EndFunc   ;==>_WINAPI_DEFWINDOWPROC
Func _WINAPI_DEFWINDOWPROCW($hwnd, $imsg, $wparam, $lparam)
    Local $acall = DllCall("user32.dll", "lresult", "DefWindowProcW", "hwnd", $hwnd, "uint", $imsg, "wparam", $wparam, "lparam", $lparam)
    If @error Then Return SetError(@error, @extended, 0x0)
    Return $acall[0x0]
EndFunc   ;==>_WINAPI_DEFWINDOWPROCW
Func _WINAPI_DEREGISTERSHELLHOOKWINDOW($hwnd)
    Local $acall = DllCall("user32.dll", "bool", "DeregisterShellHookWindow", "hwnd", $hwnd)
    If @error Then Return SetError(@error, @extended, False)
    Return $acall[0x0]
EndFunc   ;==>_WINAPI_DEREGISTERSHELLHOOKWINDOW
Func _WINAPI_DRAGACCEPTFILES($hwnd, $baccept = True)
    DllCall("shell32.dll", "none", "DragAcceptFiles", "hwnd", $hwnd, "bool", $baccept)
    If @error Then Return SetError(@error, @extended, 0x0)
    Return 0x1
EndFunc   ;==>_WINAPI_DRAGACCEPTFILES
Func _WINAPI_DRAGFINISH($hdrop)
    DllCall("shell32.dll", "none", "DragFinish", "handle", $hdrop)
    If @error Then Return SetError(@error, @extended, 0x0)
    Return 0x1
EndFunc   ;==>_WINAPI_DRAGFINISH
Func _WINAPI_DRAGQUERYFILEEX($hdrop, $iflag = 0x0)
    Local $acall = DllCall("shell32.dll", "uint", "DragQueryFileW", "handle", $hdrop, "uint", +0xffffffff, "ptr", 0x0, "uint", 0x0)
    If @error Then Return SetError(@error, @extended, 0x0)
    If Not $acall[0x0] Then Return SetError(0xa, 0x0, 0x0)
    Local $icount = $acall[0x0], $ivalidrow = 0x0
    Local $aret[$icount + 0x1]
    For $i = 0x0 To $icount + 0xffffffff
        $acall = DllCall("shell32.dll", "uint", "DragQueryFileW", "handle", $hdrop, "uint", $i, "wstr", "", "uint", 0x1000)
        If Not $acall[0x0] Then Return SetError(0xb, 0x0, 0x0)
        If $iflag Then
            Local $bdir = _WINAPI_PATHISDIRECTORY($acall[0x3])
            If (($iflag = 0x1) And $bdir) Or (($iflag = 0x2) And Not $bdir) Then
                ContinueLoop
            EndIf
        EndIf
        $ivalidrow += 0x1
        $aret[$ivalidrow] = $acall[0x3]
        $aret[0x0] += 0x1
    Next
    If Not $aret[0x0] Then Return SetError(0xc, 0x0, 0x0)
    __INC($aret, +0xffffffff)
    Return $aret
EndFunc   ;==>_WINAPI_DRAGQUERYFILEEX
Func _WINAPI_DRAGQUERYPOINT($hdrop)
    Local $tpoint = DllStructCreate($tagpoint)
    Local $acall = DllCall("shell32.dll", "bool", "DragQueryPoint", "handle", $hdrop, "struct*", $tpoint)
    If @error Or Not $acall[0x0] Then Return SetError(@error + 0xa, @extended, 0x0)
    Return $tpoint
EndFunc   ;==>_WINAPI_DRAGQUERYPOINT
Func _WINAPI_ENDDEFERWINDOWPOS($hinfo)
    Local $acall = DllCall("user32.dll", "bool", "EndDeferWindowPos", "handle", $hinfo)
    If @error Then Return SetError(@error, @extended, False)
    Return $acall[0x0]
EndFunc   ;==>_WINAPI_ENDDEFERWINDOWPOS
Func _WINAPI_ENUMCHILDWINDOWS($hwnd, $bvisible = True)
    If Not _WinAPI_GetWindow($hwnd, 0x5) Then Return SetError(0x2, 0x0, 0x0)
    Local $henumproc = DllCallbackRegister("__EnumWindowsProc", "bool", "hwnd;lparam")
    Dim $__g_venum[0x65][0x2] = [[0x0]]
    DllCall("user32.dll", "bool", "EnumChildWindows", "hwnd", $hwnd, "ptr", DllCallbackGetPtr($henumproc), "lparam", $bvisible)
    If @error Or Not $__g_venum[0x0][0x0] Then
        $__g_venum = @error + 0xa
    EndIf
    DllCallbackFree($henumproc)
    If $__g_venum Then Return SetError($__g_venum, 0x0, 0x0)
    __INC($__g_venum, +0xffffffff)
    Return $__g_venum
EndFunc   ;==>_WINAPI_ENUMCHILDWINDOWS
Func _WinAPI_FindWindow($sclassname, $swindowname)
    Local $acall = DllCall("user32.dll", "hwnd", "FindWindowW", "wstr", $sclassname, "wstr", $swindowname)
    If @error Then Return SetError(@error, @extended, 0x0)
    Return $acall[0x0]
EndFunc   ;==>_WINAPI_FINDWINDOW
Func _WinAPI_FlashWindow($hwnd, $binvert = True)
    Local $acall = DllCall("user32.dll", "bool", "FlashWindow", "hwnd", $hwnd, "bool", $binvert)
    If @error Then Return SetError(@error, @extended, False)
    Return $acall[0x0]
EndFunc   ;==>_WINAPI_FLASHWINDOW
Func _WinAPI_FlashWindowEx($hwnd, $iflags = 0x3, $icount = 0x3, $itimeout = 0x0)
    Local $tflash = DllStructCreate($tagflashwinfo)
    Local $iflash = DllStructGetSize($tflash)
    Local $imode = 0x0
    If BitAND($iflags, 0x1) <> 0x0 Then $imode = BitOR($imode, $flashw_caption)
    If BitAND($iflags, 0x2) <> 0x0 Then $imode = BitOR($imode, $flashw_tray)
    If BitAND($iflags, 0x4) <> 0x0 Then $imode = BitOR($imode, $flashw_timer)
    If BitAND($iflags, 0x8) <> 0x0 Then $imode = BitOR($imode, $flashw_timernofg)
    DllStructSetData($tflash, "Size", $iflash)
    DllStructSetData($tflash, "hWnd", $hwnd)
    DllStructSetData($tflash, "Flags", $imode)
    DllStructSetData($tflash, "Count", $icount)
    DllStructSetData($tflash, "Timeout", $itimeout)
    Local $acall = DllCall("user32.dll", "bool", "FlashWindowEx", "struct*", $tflash)
    If @error Then Return SetError(@error, @extended, False)
    Return $acall[0x0]
EndFunc   ;==>_WINAPI_FLASHWINDOWEX
Func _WinAPI_GetAncestor($hwnd, $iflags = 0x1)
    Local $acall = DllCall("user32.dll", "hwnd", "GetAncestor", "hwnd", $hwnd, "uint", $iflags)
    If @error Then Return SetError(@error, @extended, 0x0)
    Return $acall[0x0]
EndFunc   ;==>_WINAPI_GETANCESTOR
Func _WINAPI_GETCLASSINFOEX($sclass, $hinstance = 0x0)
    Local $stypeofclass = "wstr"
    If Not IsString($sclass) Then $stypeofclass = "ptr"
    Local $twndclassex = DllStructCreate($tagwndclassex)
    Local $acall = DllCall("user32.dll", "bool", "GetClassInfoExW", "handle", $hinstance, $stypeofclass, $sclass, "struct*", $twndclassex)
    If @error Or Not $acall[0x0] Then Return SetError(@error + 0xa, @extended, 0x0)
    Return $twndclassex
EndFunc   ;==>_WINAPI_GETCLASSINFOEX
Func _WINAPI_GETCLASSLONGEX($hwnd, $iindex)
    Local $acall
    If @AutoItX64 Then
        $acall = DllCall("user32.dll", "ulong_ptr", "GetClassLongPtrW", "hwnd", $hwnd, "int", $iindex)
    Else
        $acall = DllCall("user32.dll", "dword", "GetClassLongW", "hwnd", $hwnd, "int", $iindex)
    EndIf
    If @error Or Not $acall[0x0] Then Return SetError(@error, @extended, 0x0)
    Return $acall[0x0]
EndFunc   ;==>_WINAPI_GETCLASSLONGEX
Func _WinAPI_GetClientHeight($hwnd)
    Local $trect = _WinAPI_GetClientRect($hwnd)
    If @error Then Return SetError(@error, @extended, 0x0)
    Return DllStructGetData($trect, "Bottom") - DllStructGetData($trect, "Top")
EndFunc   ;==>_WINAPI_GETCLIENTHEIGHT
Func _WinAPI_GetClientWidth($hwnd)
    Local $trect = _WinAPI_GetClientRect($hwnd)
    If @error Then Return SetError(@error, @extended, 0x0)
    Return DllStructGetData($trect, "Right") - DllStructGetData($trect, "Left")
EndFunc   ;==>_WINAPI_GETCLIENTWIDTH
Func _WinAPI_GetDlgItem($hwnd, $iitemid)
    Local $acall = DllCall("user32.dll", "hwnd", "GetDlgItem", "hwnd", $hwnd, "int", $iitemid)
    If @error Then Return SetError(@error, @extended, 0x0)
    Return $acall[0x0]
EndFunc   ;==>_WINAPI_GETDLGITEM
Func _WinAPI_GetForegroundWindow()
    Local $acall = DllCall("user32.dll", "hwnd", "GetForegroundWindow")
    If @error Then Return SetError(@error, @extended, 0x0)
    Return $acall[0x0]
EndFunc   ;==>_WINAPI_GETFOREGROUNDWINDOW
Func _WINAPI_GETGUITHREADINFO($ithreadid)
    Local Const $tagguithreadinfo = "dword Size;dword Flags;hwnd hWndActive;hwnd hWndFocus;hwnd hWndCapture;hwnd hWndMenuOwner;hwnd hWndMoveSize;hwnd hWndCaret;struct rcCaret;long left;long top;long right;long bottom;endstruct"
    Local $tgti = DllStructCreate($tagguithreadinfo)
    DllStructSetData($tgti, 0x1, DllStructGetSize($tgti))
    Local $acall = DllCall("user32.dll", "bool", "GetGUIThreadInfo", "dword", $ithreadid, "struct*", $tgti)
    If @error Or Not $acall[0x0] Then Return SetError(@error + 0xa, @extended, 0x0)
    Local $aret[0xb]
    For $i = 0x0 To 0xa
        $aret[$i] = DllStructGetData($tgti, $i + 0x2)
    Next
    For $i = 0x9 To 0xa
        $aret[$i] -= $aret[$i + 0xfffffffe]
    Next
    Return $aret
EndFunc   ;==>_WINAPI_GETGUITHREADINFO
Func _WINAPI_GETLASTACTIVEPOPUP($hwnd)
    Local $acall = DllCall("user32.dll", "hwnd", "GetLastActivePopup", "hwnd", $hwnd)
    If @error Or Not $acall[0x0] Then Return SetError(@error + 0xa, @extended, 0x0)
    If $acall[0x0] = $hwnd Then Return SetError(0x1, 0x0, 0x0)
    Return $acall[0x0]
EndFunc   ;==>_WINAPI_GETLASTACTIVEPOPUP
Func _WinAPI_GetLayeredWindowAttributes($hwnd, ByRef $itranscolor, ByRef $itransgui, $bcolorref = False)
    $itranscolor = +0xffffffff
    $itransgui = +0xffffffff
    Local $acall = DllCall("user32.dll", "bool", "GetLayeredWindowAttributes", "hwnd", $hwnd, "INT*", $itranscolor, "byte*", $itransgui, "dword*", 0x0)
    If @error Or Not $acall[0x0] Then Return SetError(@error, @extended, 0x0)
    If Not $bcolorref Then
        $acall[0x2] = Int(BinaryMid($acall[0x2], 0x3, 0x1) & BinaryMid($acall[0x2], 0x2, 0x1) & BinaryMid($acall[0x2], 0x1, 0x1))
    EndIf
    $itranscolor = $acall[0x2]
    $itransgui = $acall[0x3]
    Return $acall[0x4]
EndFunc   ;==>_WINAPI_GETLAYEREDWINDOWATTRIBUTES
Func _WINAPI_GETMESSAGEEXTRAINFO()
    Local $acall = DllCall("user32.dll", "lparam", "GetMessageExtraInfo")
    If @error Then Return SetError(@error, @extended, 0x0)
    Return $acall[0x0]
EndFunc   ;==>_WINAPI_GETMESSAGEEXTRAINFO
Func _WINAPI_GETSHELLWINDOW()
    Local $acall = DllCall("user32.dll", "hwnd", "GetShellWindow")
    If @error Then Return SetError(@error, @extended, 0x0)
    Return $acall[0x0]
EndFunc   ;==>_WINAPI_GETSHELLWINDOW
Func _WINAPI_GETTOPWINDOW($hwnd)
    Local $acall = DllCall("user32.dll", "hwnd", "GetTopWindow", "hwnd", $hwnd)
    If @error Then Return SetError(@error, @extended, 0x0)
    Return $acall[0x0]
EndFunc   ;==>_WINAPI_GETTOPWINDOW
Func _WINAPI_GETWINDOWDISPLAYAFFINITY($hwnd)
    Local $acall = DllCall("user32.dll", "bool", "GetWindowDisplayAffinity", "hwnd", $hwnd, "dword*", 0x0)
    If @error Or Not $acall[0x0] Then Return SetError(@error + 0xa, @extended, 0x0)
    Return $acall[0x2]
EndFunc   ;==>_WINAPI_GETWINDOWDISPLAYAFFINITY
Func _WINAPI_GETWINDOWINFO($hwnd)
    Local $twindowinfo = DllStructCreate($tagwindowinfo)
    DllStructSetData($twindowinfo, "Size", DllStructGetSize($twindowinfo))
    Local $acall = DllCall("user32.dll", "bool", "GetWindowInfo", "hwnd", $hwnd, "struct*", $twindowinfo)
    If @error Or Not $acall[0x0] Then Return SetError(@error + 0xa, @extended, 0x0)
    Return $twindowinfo
EndFunc   ;==>_WINAPI_GETWINDOWINFO
Func _WinAPI_GetWindowPlacement($hwnd)
    Local $twindowplacement = DllStructCreate($tagwindowplacement)
    DllStructSetData($twindowplacement, "length", DllStructGetSize($twindowplacement))
    Local $acall = DllCall("user32.dll", "bool", "GetWindowPlacement", "hwnd", $hwnd, "struct*", $twindowplacement)
    If @error Or Not $acall[0x0] Then Return SetError(@error + 0xa, @extended, 0x0)
    Return $twindowplacement
EndFunc   ;==>_WINAPI_GETWINDOWPLACEMENT
Func _WINAPI_ISCHILD($hwnd, $hwndparent)
    Local $acall = DllCall("user32.dll", "bool", "IsChild", "hwnd", $hwndparent, "hwnd", $hwnd)
    If @error Then Return SetError(@error, @extended, False)
    Return $acall[0x0]
EndFunc   ;==>_WINAPI_ISCHILD
Func _WINAPI_ISHUNGAPPWINDOW($hwnd)
    Local $acall = DllCall("user32.dll", "bool", "IsHungAppWindow", "hwnd", $hwnd)
    If @error Then Return SetError(@error, @extended, False)
    Return $acall[0x0]
EndFunc   ;==>_WINAPI_ISHUNGAPPWINDOW
Func _WINAPI_ISICONIC($hwnd)
    Local $acall = DllCall("user32.dll", "bool", "IsIconic", "hwnd", $hwnd)
    If @error Then Return SetError(@error, @extended, False)
    Return $acall[0x0]
EndFunc   ;==>_WINAPI_ISICONIC
Func _WINAPI_ISWINDOWUNICODE($hwnd)
    Local $acall = DllCall("user32.dll", "bool", "IsWindowUnicode", "hwnd", $hwnd)
    If @error Then Return SetError(@error, @extended, False)
    Return $acall[0x0]
EndFunc   ;==>_WINAPI_ISWINDOWUNICODE
Func _WINAPI_ISZOOMED($hwnd)
    Local $acall = DllCall("user32.dll", "bool", "IsZoomed", "hwnd", $hwnd)
    If @error Then Return SetError(@error, @extended, False)
    Return $acall[0x0]
EndFunc   ;==>_WINAPI_ISZOOMED
Func _WINAPI_KILLTIMER($hwnd, $itimerid)
    Local $acall = DllCall("user32.dll", "bool", "KillTimer", "hwnd", $hwnd, "uint_ptr", $itimerid)
    If @error Then Return SetError(@error, @extended, 0x0)
    Return $acall[0x0]
EndFunc   ;==>_WINAPI_KILLTIMER
Func _WINAPI_OPENICON($hwnd)
    Local $acall = DllCall("user32.dll", "bool", "OpenIcon", "hwnd", $hwnd)
    If @error Then Return SetError(@error, @extended, 0x0)
    Return $acall[0x0]
EndFunc   ;==>_WINAPI_OPENICON
Func _WinAPI_PostMessage($hwnd, $imsg, $wparam, $lparam)
    Local $acall = DllCall("user32.dll", "bool", "PostMessage", "hwnd", $hwnd, "uint", $imsg, "wparam", $wparam, "lparam", $lparam)
    If @error Then Return SetError(@error, @extended, False)
    Return $acall[0x0]
EndFunc   ;==>_WINAPI_POSTMESSAGE
Func _WINAPI_REGISTERCLASS($twndclass)
    Local $acall = DllCall("user32.dll", "word", "RegisterClassW", "struct*", $twndclass)
    If @error Then Return SetError(@error, @extended, 0x0)
    Return $acall[0x0]
EndFunc   ;==>_WINAPI_REGISTERCLASS
Func _WINAPI_REGISTERCLASSEX($twndclassex)
    Local $acall = DllCall("user32.dll", "word", "RegisterClassExW", "struct*", $twndclassex)
    If @error Then Return SetError(@error, @extended, 0x0)
    Return $acall[0x0]
EndFunc   ;==>_WINAPI_REGISTERCLASSEX
Func _WINAPI_REGISTERSHELLHOOKWINDOW($hwnd)
    Local $acall = DllCall("user32.dll", "bool", "RegisterShellHookWindow", "hwnd", $hwnd)
    If @error Then Return SetError(@error, @extended, False)
    Return $acall[0x0]
EndFunc   ;==>_WINAPI_REGISTERSHELLHOOKWINDOW
Func _WinAPI_RegisterWindowMessage($smessage)
    Local $acall = DllCall("user32.dll", "uint", "RegisterWindowMessageW", "wstr", $smessage)
    If @error Then Return SetError(@error, @extended, 0x0)
    Return $acall[0x0]
EndFunc   ;==>_WINAPI_REGISTERWINDOWMESSAGE
Func _WINAPI_SENDMESSAGETIMEOUT($hwnd, $imsg, $wparam = 0x0, $lparam = 0x0, $itimeout = 0x3e8, $iflags = 0x0)
    Local $acall = DllCall("user32.dll", "lresult", "SendMessageTimeoutW", "hwnd", $hwnd, "uint", $imsg, "wparam", $wparam, "lparam", $lparam, "uint", $iflags, "uint", $itimeout, "dword_ptr*", 0x0)
    If @error Then Return SetError(@error, @extended, +0xffffffff)
    If Not $acall[0x0] Then Return SetError(0xa, _WinAPI_GetLastError(), +0xffffffff)
    Return $acall[0x7]
EndFunc   ;==>_WINAPI_SENDMESSAGETIMEOUT
Func _WINAPI_SETCLASSLONGEX($hwnd, $iindex, $inewlong)
    Local $acall
    If @AutoItX64 Then
        $acall = DllCall("user32.dll", "ulong_ptr", "SetClassLongPtrW", "hwnd", $hwnd, "int", $iindex, "long_ptr", $inewlong)
    Else
        $acall = DllCall("user32.dll", "dword", "SetClassLongW", "hwnd", $hwnd, "int", $iindex, "long", $inewlong)
    EndIf
    If @error Then Return SetError(@error, @extended, 0x0)
    Return $acall[0x0]
EndFunc   ;==>_WINAPI_SETCLASSLONGEX
Func _WINAPI_SETFOREGROUNDWINDOW($hwnd)
    Local $acall = DllCall("user32.dll", "bool", "SetForegroundWindow", "hwnd", $hwnd)
    If @error Then Return SetError(@error, @extended, False)
    Return $acall[0x0]
EndFunc   ;==>_WINAPI_SETFOREGROUNDWINDOW
Func _WinAPI_SetLayeredWindowAttributes($hwnd, $itranscolor, $itransgui = 0xff, $iflags = 0x3, $bcolorref = False)
    If $iflags = Default Or $iflags = "" Or $iflags < 0x0 Then $iflags = 0x3
    If Not $bcolorref Then
        $itranscolor = Int(BinaryMid($itranscolor, 0x3, 0x1) & BinaryMid($itranscolor, 0x2, 0x1) & BinaryMid($itranscolor, 0x1, 0x1))
    EndIf
    Local $acall = DllCall("user32.dll", "bool", "SetLayeredWindowAttributes", "hwnd", $hwnd, "INT", $itranscolor, "byte", $itransgui, "dword", $iflags)
    If @error Then Return SetError(@error, @extended, False)
    Return $acall[0x0]
EndFunc   ;==>_WINAPI_SETLAYEREDWINDOWATTRIBUTES
Func _WINAPI_SETMESSAGEEXTRAINFO($lparam)
    Local $acall = DllCall("user32.dll", "lparam", "SetMessageExtraInfo", "lparam", $lparam)
    If @error Then Return SetError(@error, @extended, 0x0)
    Return $acall[0x0]
EndFunc   ;==>_WINAPI_SETMESSAGEEXTRAINFO
Func _WinAPI_SetSysColors($velements, $vcolors)
    Local $bisearray = IsArray($velements), $biscarray = IsArray($vcolors)
    Local $ielementnum
    If Not $biscarray And Not $bisearray Then
        $ielementnum = 0x1
    ElseIf $biscarray Or $bisearray Then
        If Not $biscarray Or Not $bisearray Then Return SetError(+0xffffffff, +0xffffffff, False)
        If UBound($velements) <> UBound($vcolors) Then Return SetError(+0xffffffff, +0xffffffff, False)
        $ielementnum = UBound($velements)
    EndIf
    Local $telements = DllStructCreate("int Element[" & $ielementnum & "]")
    Local $tcolors = DllStructCreate("INT NewColor[" & $ielementnum & "]")
    If Not $bisearray Then
        DllStructSetData($telements, "Element", $velements, 0x1)
    Else
        For $x = 0x0 To $ielementnum + 0xffffffff
            DllStructSetData($telements, "Element", $velements[$x], $x + 0x1)
        Next
    EndIf
    If Not $biscarray Then
        DllStructSetData($tcolors, "NewColor", $vcolors, 0x1)
    Else
        For $x = 0x0 To $ielementnum + 0xffffffff
            DllStructSetData($tcolors, "NewColor", $vcolors[$x], $x + 0x1)
        Next
    EndIf
    Local $acall = DllCall("user32.dll", "bool", "SetSysColors", "int", $ielementnum, "struct*", $telements, "struct*", $tcolors)
    If @error Then Return SetError(@error, @extended, False)
    Return $acall[0x0]
EndFunc   ;==>_WINAPI_SETSYSCOLORS
Func _WINAPI_SETTIMER($hwnd, $itimerid, $ielapse, $ptimerfunc)
    Local $acall = DllCall("user32.dll", "uint_ptr", "SetTimer", "hwnd", $hwnd, "uint_ptr", $itimerid, "uint", $ielapse, "ptr", $ptimerfunc)
    If @error Then Return SetError(@error, @extended, 0x0)
    Return $acall[0x0]
EndFunc   ;==>_WINAPI_SETTIMER
Func _WINAPI_SETWINDOWDISPLAYAFFINITY($hwnd, $iaffinity)
    Local $acall = DllCall("user32.dll", "bool", "SetWindowDisplayAffinity", "hwnd", $hwnd, "dword", $iaffinity)
    If @error Then Return SetError(@error, @extended, False)
    Return $acall[0x0]
EndFunc   ;==>_WINAPI_SETWINDOWDISPLAYAFFINITY
Func _WinAPI_SetWindowLong($hwnd, $iindex, $ivalue)
    _WinAPI_SetLastError(0x0)
    Local $sfuncname = "SetWindowLongW"
    If @AutoItX64 Then $sfuncname = "SetWindowLongPtrW"
    Local $acall = DllCall("user32.dll", "long_ptr", $sfuncname, "hwnd", $hwnd, "int", $iindex, "long_ptr", $ivalue)
    If @error Then Return SetError(@error, @extended, 0x0)
    Return $acall[0x0]
EndFunc   ;==>_WINAPI_SETWINDOWLONG
Func _WinAPI_SetWindowPlacement($hwnd, $twindowplacement)
    Local $acall = DllCall("user32.dll", "bool", "SetWindowPlacement", "hwnd", $hwnd, "struct*", $twindowplacement)
    If @error Then Return SetError(@error, @extended, False)
    Return $acall[0x0]
EndFunc   ;==>_WINAPI_SETWINDOWPLACEMENT
Func _WINAPI_SHOWOWNEDPOPUPS($hwnd, $bshow)
    Local $acall = DllCall("user32.dll", "bool", "ShowOwnedPopups", "hwnd", $hwnd, "bool", $bshow)
    If @error Then Return SetError(@error, @extended, False)
    Return $acall[0x0]
EndFunc   ;==>_WINAPI_SHOWOWNEDPOPUPS
Func _WINAPI_SWITCHTOTHISWINDOW($hwnd, $balttab = False)
    DllCall("user32.dll", "none", "SwitchToThisWindow", "hwnd", $hwnd, "bool", $balttab)
    If @error Then Return SetError(@error, @extended, 0x0)
    Return 0x1
EndFunc   ;==>_WINAPI_SWITCHTOTHISWINDOW
Func _WINAPI_TILEWINDOWS($awnds, $trect = 0x0, $hparent = 0x0, $iflags = 0x0, $istart = 0x0, $iend = +0xffffffff)
    If __CHECKERRORARRAYBOUNDS($awnds, $istart, $iend) Then Return SetError(@error + 0xa, @extended, 0x0)
    Local $icount = $iend - $istart + 0x1
    Local $twnds = DllStructCreate("hwnd[" & $icount & "]")
    $icount = 0x1
    For $i = $istart To $iend
        DllStructSetData($twnds, 0x1, $awnds[$i], $icount)
        $icount += 0x1
    Next
    Local $acall = DllCall("user32.dll", "word", "TileWindows", "hwnd", $hparent, "uint", $iflags, "struct*", $trect, "uint", $icount + 0xffffffff, "struct*", $twnds)
    If @error Then Return SetError(@error, @extended, 0x0)
    Return $acall[0x0]
EndFunc   ;==>_WINAPI_TILEWINDOWS
Func _WINAPI_UNREGISTERCLASS($sclass, $hinstance = 0x0)
    Local $stypeofclass = "wstr"
    If Not IsString($sclass) Then $stypeofclass = "ptr"
    Local $acall = DllCall("user32.dll", "bool", "UnregisterClassW", $stypeofclass, $sclass, "handle", $hinstance)
    If @error Then Return SetError(@error, @extended, False)
    Return $acall[0x0]
EndFunc   ;==>_WINAPI_UNREGISTERCLASS
Func _WinAPI_UpdateLayeredWindow($hwnd, $hdestdc, $tptdest, $tsize, $hsrcdc, $tptsrce, $irgb, $tblend, $iflags)
    Local $acall = DllCall("user32.dll", "bool", "UpdateLayeredWindow", "hwnd", $hwnd, "handle", $hdestdc, "struct*", $tptdest, "struct*", $tsize, "handle", $hsrcdc, "struct*", $tptsrce, "dword", $irgb, "struct*", $tblend, "dword", $iflags)
    If @error Then Return SetError(@error, @extended, False)
    Return $acall[0x0]
EndFunc   ;==>_WINAPI_UPDATELAYEREDWINDOW
Func _WINAPI_UPDATELAYEREDWINDOWEX($hwnd, $ix, $iy, $hbitmap, $iopacity = 0xff, $bdelete = False)
    Local $acall = DllCall("user32.dll", "handle", "GetDC", "hwnd", $hwnd)
    Local $hdc = $acall[0x0]
    $acall = DllCall("gdi32.dll", "handle", "CreateCompatibleDC", "handle", $hdc)
    Local $hdestdc = $acall[0x0]
    $acall = DllCall("gdi32.dll", "handle", "SelectObject", "handle", $hdestdc, "handle", $hbitmap)
    Local $hdestsv = $acall[0x0]
    Local $tpoint
    If ($ix = +0xffffffff) And ($iy = +0xffffffff) Then
        $tpoint = DllStructCreate("int;int")
    Else
        $tpoint = DllStructCreate("int;int;int;int")
        DllStructSetData($tpoint, 0x3, $ix)
        DllStructSetData($tpoint, 0x4, $iy)
    EndIf
    DllStructSetData($tpoint, 0x1, 0x0)
    DllStructSetData($tpoint, 0x2, 0x0)
    Local $tblendfunction = DllStructCreate($tagblendfunction)
    DllStructSetData($tblendfunction, 0x1, 0x0)
    DllStructSetData($tblendfunction, 0x2, 0x0)
    DllStructSetData($tblendfunction, 0x3, $iopacity)
    DllStructSetData($tblendfunction, 0x4, 0x1)
    Local Const $tagbitmap = "struct;long bmType;long bmWidth;long bmHeight;long bmWidthBytes;ushort bmPlanes;ushort bmBitsPixel;ptr bmBits;endstruct"
    Local $tobj = DllStructCreate($tagbitmap)
    DllCall("gdi32.dll", "int", "GetObject", "handle", $hbitmap, "int", DllStructGetSize($tobj), "struct*", $tobj)
    Local $tsize = DllStructCreate($tagsize, DllStructGetPtr($tobj, "bmWidth"))
    $acall = DllCall("user32.dll", "bool", "UpdateLayeredWindow", "hwnd", $hwnd, "handle", $hdc, "ptr", DllStructGetPtr($tpoint, 0x3), "struct*", $tsize, "handle", $hdestdc, "struct*", $tpoint, "dword", 0x0, "struct*", $tblendfunction, "dword", 0x2)
    Local $ierror = @error
    DllCall("user32.dll", "bool", "ReleaseDC", "hwnd", $hwnd, "handle", $hdc)
    DllCall("gdi32.dll", "handle", "SelectObject", "handle", $hdestdc, "handle", $hdestsv)
    DllCall("gdi32.dll", "bool", "DeleteDC", "handle", $hdestdc)
    If $ierror Then Return SetError($ierror, 0x0, False)
    If $bdelete Then
        DllCall("gdi32.dll", "bool", "DeleteObject", "handle", $hbitmap)
    EndIf
    Return $acall[0x0]
EndFunc   ;==>_WINAPI_UPDATELAYEREDWINDOWEX
Func _WINAPI_UPDATELAYEREDWINDOWINDIRECT($hwnd, $tulwinfo)
    Local $acall = DllCall("user32.dll", "bool", "UpdateLayeredWindowIndirect", "hwnd", $hwnd, "struct*", $tulwinfo)
    If @error Then Return SetError(@error, @extended, False)
    Return $acall[0x0]
EndFunc   ;==>_WINAPI_UPDATELAYEREDWINDOWINDIRECT
Func _WinAPI_WindowFromPoint(ByRef $tpoint)
    Local $acall = DllCall("user32.dll", "hwnd", "WindowFromPoint", "struct", $tpoint)
    If @error Then Return SetError(@error, @extended, 0x0)
    Return $acall[0x0]
EndFunc   ;==>_WINAPI_WINDOWFROMPOINT
#endregion Public Functions
#region Internal Functions
Func __ENUMDEFAULTPROC($pdata, $lparam)
    #forceref $lparam
    Local $ilength = _WINAPI_STRLEN($pdata)
    __INC($__g_venum)
    If $ilength Then
        $__g_venum[$__g_venum[0x0]] = DllStructGetData(DllStructCreate("wchar[" & ($ilength + 0x1) & "]", $pdata), 0x1)
    Else
        $__g_venum[$__g_venum[0x0]] = ""
    EndIf
    Return 0x1
EndFunc   ;==>__ENUMDEFAULTPROC
#endregion Internal Functions
#region Global Variables and Constants
Global Const $tagosversioninfoex = $tagosversioninfo & ";ushort ServicePackMajor;ushort ServicePackMinor;ushort SuiteMask;byte ProductType;byte Reserved"
Global Const $tagrawinputdevice = "struct;ushort UsagePage;ushort Usage;dword Flags;hwnd hTarget;endstruct"
Global Const $tagrawinputheader = "struct;dword Type;dword Size;handle hDevice;wparam wParam;endstruct"
Global Const $tagrawmouse = "ushort Flags;ushort Alignment;ushort ButtonFlags;ushort ButtonData;ulong RawButtons;long LastX;long LastY;ulong ExtraInformation;"
Global Const $tagrawkeyboard = "ushort MakeCode;ushort Flags;ushort Reserved;ushort VKey;uint Message;ulong ExtraInformation;"
Global Const $tagrawhid = "dword SizeHid;dword Count;"
Global Const $tagrawinputmouse = $tagrawinputheader & ";" & $tagrawmouse
Global Const $tagrawinputkeyboard = $tagrawinputheader & ";" & $tagrawkeyboard
Global Const $tagrawinputhid = $tagrawinputheader & ";" & $tagrawhid
Global Const $tagrid_device_info_mouse = "struct;dword Id;dword NumberOfButtons;dword SampleRate;int HasHorizontalWheel;endstruc"
Global Const $tagrid_device_info_keyboard = "struct;dword KbType;dword KbSubType;dword KeyboardMode;dword NumberOfFunctionKeys;dword NumberOfIndicators;dword NumberOfKeysTotal;endstruct"
Global Const $tagrid_device_info_hid = "struct;dword VendorId;dword ProductId;dword VersionNumber;ushort UsagePage;ushort Usage;endstruc"
Global Const $tagrid_info_mouse = "dword Size;dword Type;" & $tagrid_device_info_mouse & ";dword Unused[2];"
Global Const $tagrid_info_keyboard = "dword Size;dword Type;" & $tagrid_device_info_keyboard
Global Const $tagrid_info_hid = "dword Size;dword Type;" & $tagrid_device_info_hid & ";dword Unused[2]"
Global Const $taguserobjectflags = "int Inherit;int Reserved;dword Flags"
#endregion Global Variables and Constants
#region Functions list
#endregion Functions list
#region Public Functions
Func _WINAPI_ACTIVATEKEYBOARDLAYOUT($hlocale, $iflag = 0x0)
    Local $acall = DllCall("user32.dll", "handle", "ActivateKeyboardLayout", "handle", $hlocale, "uint", $iflag)
    If @error Then Return SetError(@error, @extended, 0x0)
    Return $acall[0x0]
EndFunc   ;==>_WINAPI_ACTIVATEKEYBOARDLAYOUT
Func _WINAPI_ADDCLIPBOARDFORMATLISTENER($hwnd)
    Local $acall = DllCall("user32.dll", "bool", "AddClipboardFormatListener", "hwnd", $hwnd)
    If @error Then Return SetError(@error, @extended, False)
    Return $acall[0x0]
EndFunc   ;==>_WINAPI_ADDCLIPBOARDFORMATLISTENER
Func _WinAPI_CallNextHookEx($hhook, $icode, $wparam, $lparam)
    Local $acall = DllCall("user32.dll", "lresult", "CallNextHookEx", "handle", $hhook, "int", $icode, "wparam", $wparam, "lparam", $lparam)
    If @error Then Return SetError(@error, @extended, +0xffffffff)
    Return $acall[0x0]
EndFunc   ;==>_WINAPI_CALLNEXTHOOKEX
Func _WINAPI_CLOSEDESKTOP($hdesktop)
    Local $acall = DllCall("user32.dll", "bool", "CloseDesktop", "handle", $hdesktop)
    If @error Then Return SetError(@error, @extended, False)
    Return $acall[0x0]
EndFunc   ;==>_WINAPI_CLOSEDESKTOP
Func _WINAPI_CLOSEWINDOWSTATION($hstation)
    Local $acall = DllCall("user32.dll", "bool", "CloseWindowStation", "handle", $hstation)
    If @error Then Return SetError(@error, @extended, False)
    Return $acall[0x0]
EndFunc   ;==>_WINAPI_CLOSEWINDOWSTATION
Func _WINAPI_COMPRESSBUFFER($puncompressedbuffer, $iuncompressedsize, $pcompressedbuffer, $icompressedsize, $iformatandengine = 0x2)
    Local $acall, $pworkspace = 0x0, $ierror = 0x0
    Do
        $acall = DllCall("ntdll.dll", "uint", "RtlGetCompressionWorkSpaceSize", "ushort", $iformatandengine, "ulong*", 0x0, "ulong*", 0x0)
        If @error Or $acall[0x0] Then
            $ierror = @error + 0x14
            ExitLoop
        EndIf
        $pworkspace = __HEAPALLOC($acall[0x2])
        If @error Then
            $ierror = @error + 0x64
            ExitLoop
        EndIf
        $acall = DllCall("ntdll.dll", "uint", "RtlCompressBuffer", "ushort", $iformatandengine, "struct*", $puncompressedbuffer, "ulong", $iuncompressedsize, "struct*", $pcompressedbuffer, "ulong", $icompressedsize, "ulong", 0x1000, "ulong*", 0x0, "ptr", $pworkspace)
        If @error Or $acall[0x0] Or Not $acall[0x7] Then
            $ierror = @error + 0x1e
            ExitLoop
        EndIf
    Until 0x1
    __HEAPFREE($pworkspace)
    If $ierror Then
        If IsArray($acall) Then
            Return SetError(0xa, $acall[0x0], 0x0)
        Else
            Return SetError($ierror, 0x0, 0x0)
        EndIf
    EndIf
    Return $acall[0x7]
EndFunc   ;==>_WINAPI_COMPRESSBUFFER
Func _WINAPI_COMPUTECRC32($pmemory, $ilength)
    If _WINAPI_ISBADREADPTR($pmemory, $ilength) Then Return SetError(0x1, @extended, 0x0)
    Local $acall = DllCall("ntdll.dll", "dword", "RtlComputeCrc32", "dword", 0x0, "struct*", $pmemory, "int", $ilength)
    If @error Or Not $acall[0x0] Then Return SetError(@error + 0xa, @extended, 0x0)
    Return $acall[0x0]
EndFunc   ;==>_WINAPI_COMPUTECRC32
Func _WINAPI_CREATEDESKTOP($sname, $iaccess = 0x2, $iflags = 0x0, $iheap = 0x0, $tsecurity = 0x0)
    Local $acall
    If $iheap Then
        $acall = DllCall("user32.dll", "handle", "CreateDesktopExW", "wstr", $sname, "ptr", 0x0, "ptr", 0x0, "dword", $iflags, "dword", $iaccess, "struct*", $tsecurity, "ulong", $iheap, "ptr", 0x0)
    Else
        $acall = DllCall("user32.dll", "handle", "CreateDesktopW", "wstr", $sname, "ptr", 0x0, "ptr", 0x0, "dword", $iflags, "dword", $iaccess, "struct*", $tsecurity)
    EndIf
    If @error Then Return SetError(@error, @extended, 0x0)
    Return $acall[0x0]
EndFunc   ;==>_WINAPI_CREATEDESKTOP
Func _WINAPI_CREATEWINDOWSTATION($sname = "", $iaccess = 0x0, $iflags = 0x0, $tsecurity = 0x0)
    Local $acall = DllCall("user32.dll", "handle", "CreateWindowStationW", "wstr", $sname, "dword", $iflags, "dword", $iaccess, "struct*", $tsecurity)
    If @error Then Return SetError(@error, @extended, 0x0)
    Return $acall[0x0]
EndFunc   ;==>_WINAPI_CREATEWINDOWSTATION
Func _WINAPI_DECOMPRESSBUFFER($puncompressedbuffer, $iuncompressedsize, $pcompressedbuffer, $icompressedsize, $iformat = 0x2)
    Local $acall = DllCall("ntdll.dll", "long", "RtlDecompressBuffer", "ushort", $iformat, "struct*", $puncompressedbuffer, "ulong", $iuncompressedsize, "struct*", $pcompressedbuffer, "ulong", $icompressedsize, "ulong*", 0x0)
    If @error Then Return SetError(@error, @extended, 0x0)
    If $acall[0x0] Then Return SetError(0xa, $acall[0x0], 0x0)
    Return $acall[0x6]
EndFunc   ;==>_WINAPI_DECOMPRESSBUFFER
Func _WINAPI_DEFRAWINPUTPROC($parawinput, $iinput)
    Local $acall = DllCall("user32.dll", "lresult", "DefRawInputProc", "ptr", $parawinput, "int", $iinput, "uint", DllStructGetSize(DllStructCreate($tagrawinputheader)))
    If @error Then Return SetError(@error, @extended, 0x0)
    If $acall[0x0] Then Return SetError(0xa, $acall[0x0], 0x0)
    Return 0x1
EndFunc   ;==>_WINAPI_DEFRAWINPUTPROC
Func _WINAPI_ENUMDESKTOPS($hstation)
    If StringCompare(_WINAPI_GETUSEROBJECTINFORMATION($hstation, 0x3), "WindowStation") Then Return SetError(0x1, 0x0, 0x0)
    Local $henumproc = DllCallbackRegister("__EnumDefaultProc", "bool", "ptr;lparam")
    Dim $__g_venum[0x65] = [0x0]
    Local $acall = DllCall("user32.dll", "bool", "EnumDesktopsW", "handle", $hstation, "ptr", DllCallbackGetPtr($henumproc), "lparam", 0x0)
    If @error Or Not $acall[0x0] Or Not $__g_venum[0x0] Then
        $__g_venum = @error + 0xa
    EndIf
    DllCallbackFree($henumproc)
    If $__g_venum Then Return SetError($__g_venum, 0x0, 0x0)
    __INC($__g_venum, +0xffffffff)
    Return $__g_venum
EndFunc   ;==>_WINAPI_ENUMDESKTOPS
Func _WINAPI_ENUMDESKTOPWINDOWS($hdesktop, $bvisible = True)
    If StringCompare(_WINAPI_GETUSEROBJECTINFORMATION($hdesktop, 0x3), "Desktop") Then Return SetError(0x1, 0x0, 0x0)
    Local $henumproc = DllCallbackRegister("__EnumWindowsProc", "bool", "hwnd;lparam")
    Dim $__g_venum[0x65][0x2] = [[0x0]]
    Local $acall = DllCall("user32.dll", "bool", "EnumDesktopWindows", "handle", $hdesktop, "ptr", DllCallbackGetPtr($henumproc), "lparam", $bvisible)
    If @error Or Not $acall[0x0] Or Not $__g_venum[0x0][0x0] Then
        $__g_venum = @error + 0xa
    EndIf
    DllCallbackFree($henumproc)
    If $__g_venum Then Return SetError($__g_venum, 0x0, 0x0)
    __INC($__g_venum, +0xffffffff)
    Return $__g_venum
EndFunc   ;==>_WINAPI_ENUMDESKTOPWINDOWS
Func _WINAPI_ENUMPAGEFILES()
    Local $ainfo = _WINAPI_GETSYSTEMINFO()
    Local $henumproc = DllCallbackRegister("__EnumPageFilesProc", "bool", "lparam;ptr;ptr")
    Dim $__g_venum[0x65][0x4] = [[0x0]]
    Local $acall = DllCall(@SystemDir & "\psapi.dll", "bool", "EnumPageFilesW", "ptr", DllCallbackGetPtr($henumproc), "lparam", $ainfo[0x1])
    If @error Or Not $acall[0x0] Or Not $__g_venum[0x0][0x0] Then
        $__g_venum = @error + 0xa
    EndIf
    DllCallbackFree($henumproc)
    If $__g_venum Then Return SetError($__g_venum, 0x0, 0x0)
    __INC($__g_venum, +0xffffffff)
    Return $__g_venum
EndFunc   ;==>_WINAPI_ENUMPAGEFILES
Func _WINAPI_ENUMRAWINPUTDEVICES()
    Local Const $tagrawinputdevicelist = "struct;handle hDevice;dword Type;endstruct"
    Local $tridl, $ilength = DllStructGetSize(DllStructCreate($tagrawinputdevicelist))
    Local $acall = DllCall("user32.dll", "uint", "GetRawInputDeviceList", "ptr", 0x0, "uint*", 0x0, "uint", $ilength)
    If @error Then Return SetError(@error + 0xa, @extended, 0x0)
    If ($acall[0x0] = 0xffffffff) Or (Not $acall[0x2]) Then Return SetError(0xa, +0xffffffff, 0x0)
    Local $tdata = DllStructCreate("byte[" & ($acall[0x2] * $ilength) & "]")
    Local $pdata = DllStructGetPtr($tdata)
    If @error Then Return SetError(@error + 0x14, 0x0, 0x0)
    $acall = DllCall("user32.dll", "uint", "GetRawInputDeviceList", "ptr", $pdata, "uint*", $acall[0x2], "uint", $ilength)
    If ($acall[0x0] = 0xffffffff) Or (Not $acall[0x0]) Then Return SetError(0x1, +0xffffffff, 0x0)
    Local $aret[$acall[0x2] + 0x1][0x2] = [[$acall[0x2]]]
    For $i = 0x1 To $acall[0x2]
        $tridl = DllStructCreate("ptr;dword", $pdata + $ilength * ($i + 0xffffffff))
        For $j = 0x0 To 0x1
            $aret[$i][$j] = DllStructGetData($tridl, $j + 0x1)
        Next
    Next
    Return $aret
EndFunc   ;==>_WINAPI_ENUMRAWINPUTDEVICES
Func _WINAPI_ENUMWINDOWSTATIONS()
    Local $henumproc = DllCallbackRegister("__EnumDefaultProc", "bool", "ptr;lparam")
    Dim $__g_venum[0x65] = [0x0]
    Local $acall = DllCall("user32.dll", "bool", "EnumWindowStationsW", "ptr", DllCallbackGetPtr($henumproc), "lparam", 0x0)
    If @error Or Not $acall[0x0] Or Not $__g_venum[0x0] Then
        $__g_venum = @error + 0xa
    EndIf
    DllCallbackFree($henumproc)
    If $__g_venum Then Return SetError($__g_venum, 0x0, 0x0)
    __INC($__g_venum, +0xffffffff)
    Return $__g_venum
EndFunc   ;==>_WINAPI_ENUMWINDOWSTATIONS
Func _WinAPI_ExpandEnvironmentStrings($sstring)
    Local $acall = DllCall("kernel32.dll", "dword", "ExpandEnvironmentStringsW", "wstr", $sstring, "wstr", "", "dword", 0x1000)
    If @error Or Not $acall[0x0] Then Return SetError(@error + 0xa, @extended, "")
    Return $acall[0x2]
EndFunc   ;==>_WINAPI_EXPANDENVIRONMENTSTRINGS
Func _WINAPI_GETACTIVEWINDOW()
    Local $acall = DllCall("user32.dll", "hwnd", "GetActiveWindow")
    If @error Then Return SetError(@error, @extended, 0x0)
    Return $acall[0x0]
EndFunc   ;==>_WINAPI_GETACTIVEWINDOW
Func _WinAPI_GetAsyncKeyState($ikey)
    Local $acall = DllCall("user32.dll", "short", "GetAsyncKeyState", "int", $ikey)
    If @error Then Return SetError(@error, @extended, 0x0)
    Return $acall[0x0]
EndFunc   ;==>_WINAPI_GETASYNCKEYSTATE
Func _WINAPI_GETCLIPBOARDSEQUENCENUMBER()
    Local $acall = DllCall("user32.dll", "dword", "GetClipboardSequenceNumber")
    If @error Or Not $acall[0x0] Then Return SetError(@error, @extended, 0x0)
    Return $acall[0x0]
EndFunc   ;==>_WINAPI_GETCLIPBOARDSEQUENCENUMBER
Func _WINAPI_GETCURRENTHWPROFILE()
    Local $taghw_profile_info = "dword DockInfo;wchar szHwProfileGuid[39];wchar szHwProfileName[80]"
    Local $thwpi = DllStructCreate($taghw_profile_info)
    Local $acall = DllCall("advapi32.dll", "bool", "GetCurrentHwProfileW", "struct*", $thwpi)
    If @error Or Not $acall[0x0] Then Return SetError(@error + 0xa, @extended, 0x0)
    Local $aret[0x3]
    For $i = 0x0 To 0x2
        $aret[$i] = DllStructGetData($thwpi, $i + 0x1)
    Next
    Return $aret
EndFunc   ;==>_WINAPI_GETCURRENTHWPROFILE
Func _WINAPI_GETDEFAULTPRINTER()
    Local $acall = DllCall("winspool.drv", "bool", "GetDefaultPrinterW", "wstr", "", "dword*", 0x800)
    If @error Then Return SetError(@error, @extended, "")
    If Not $acall[0x0] Then Return SetError(0xa, _WinAPI_GetLastError(), "")
    Return $acall[0x1]
EndFunc   ;==>_WINAPI_GETDEFAULTPRINTER
Func _WINAPI_GETDLLDIRECTORY()
    Local $acall = DllCall("kernel32.dll", "dword", "GetDllDirectoryW", "dword", 0x1000, "wstr", "")
    If @error Or Not $acall[0x0] Then Return SetError(@error, @extended, "")
    Return $acall[0x2]
EndFunc   ;==>_WINAPI_GETDLLDIRECTORY
Func _WINAPI_GETEFFECTIVECLIENTRECT($hwnd, $actrl, $istart = 0x0, $iend = +0xffffffff)
    If Not IsArray($actrl) Then
        Local $ictrl = $actrl
        Dim $actrl[0x1] = [$ictrl]
        $istart = 0x0
        $iend = 0x0
    EndIf
    If __CHECKERRORARRAYBOUNDS($actrl, $istart, $iend) Then Return SetError(@error + 0xa, @extended, 0x0)
    Local $icount = $iend - $istart + 0x1
    Local $tctrl = DllStructCreate("uint64[" & ($icount + 0x2) & "]")
    $icount = 0x2
    For $i = $istart To $iend
        If IsHWnd($actrl[$i]) Then
            $actrl[$i] = _WinAPI_GetDlgCtrlID($actrl[$i])
        EndIf
        DllStructSetData($tctrl, 0x1, _WinAPI_MakeQWord(0x1, $actrl[$i]), $icount)
        $icount += 0x1
    Next
    Local $trect = DllStructCreate($tagrect)
    DllCall("comctl32.dll", "none", "GetEffectiveClientRect", "hwnd", $hwnd, "struct*", $trect, "struct*", $tctrl)
    If @error Then Return SetError(@error, @extended, 0x0)
    Return $trect
EndFunc   ;==>_WINAPI_GETEFFECTIVECLIENTRECT
Func _WINAPI_GETHANDLEINFORMATION($hobject)
    Local $acall = DllCall("kernel32.dll", "bool", "GetHandleInformation", "handle", $hobject, "dword*", 0x0)
    If @error Or Not $acall[0x0] Then Return SetError(@error, @extended, 0x0)
    Return $acall[0x2]
EndFunc   ;==>_WINAPI_GETHANDLEINFORMATION
Func _WINAPI_GETIDLETIME()
    Local $tlastinputinfo = DllStructCreate("uint;dword")
    DllStructSetData($tlastinputinfo, 0x1, DllStructGetSize($tlastinputinfo))
    Local $acall = DllCall("user32.dll", "bool", "GetLastInputInfo", "struct*", $tlastinputinfo)
    If @error Or Not $acall[0x0] Then Return SetError(@error, @extended, 0x0)
    Return _WINAPI_GETTICKCOUNT() - DllStructGetData($tlastinputinfo, 0x2)
EndFunc   ;==>_WINAPI_GETIDLETIME
Func _WINAPI_GETKEYBOARDLAYOUT($hwnd)
    Local $acall = DllCall("user32.dll", "dword", "GetWindowThreadProcessId", "hwnd", $hwnd, "ptr", 0x0)
    If @error Or Not $acall[0x0] Then Return SetError(@error + 0xa, @extended, 0x0)
    $acall = DllCall("user32.dll", "handle", "GetKeyboardLayout", "dword", $acall[0x0])
    If @error Then Return SetError(@error, @extended, 0x0)
    Return $acall[0x0]
EndFunc   ;==>_WINAPI_GETKEYBOARDLAYOUT
Func _WINAPI_GETKEYBOARDLAYOUTLIST()
    Local $acall = DllCall("user32.dll", "uint", "GetKeyboardLayoutList", "int", 0x0, "ptr", 0x0)
    If @error Or Not $acall[0x0] Then Return SetError(@error + 0x14, @extended, 0x0)
    Local $tdata = DllStructCreate("handle[" & $acall[0x0] & "]")
    $acall = DllCall("user32.dll", "uint", "GetKeyboardLayoutList", "int", $acall[0x0], "struct*", $tdata)
    If @error Or Not $acall[0x0] Then Return SetError(@error + 0xa, @extended, 0x0)
    Local $alist[$acall[0x0] + 0x1] = [$acall[0x0]]
    For $i = 0x1 To $alist[0x0]
        $alist[$i] = DllStructGetData($tdata, 0x1, $i)
    Next
    Return $alist
EndFunc   ;==>_WINAPI_GETKEYBOARDLAYOUTLIST
Func _WINAPI_GETKEYBOARDSTATE()
    Local $tdata = DllStructCreate("byte[256]")
    Local $acall = DllCall("user32.dll", "bool", "GetKeyboardState", "struct*", $tdata)
    If @error Or Not $acall[0x0] Then Return SetError(@error + 0xa, @extended, 0x0)
    Return $tdata
EndFunc   ;==>_WINAPI_GETKEYBOARDSTATE
Func _WINAPI_GETKEYBOARDTYPE($itype)
    Local $acall = DllCall("user32.dll", "int", "GetKeyboardType", "int", $itype)
    If @error Then Return SetError(@error, @extended, 0x0)
    Return $acall[0x0]
EndFunc   ;==>_WINAPI_GETKEYBOARDTYPE
Func _WINAPI_GETKEYNAMETEXT($lparam)
    Local $acall = DllCall("user32.dll", "int", "GetKeyNameTextW", "long", $lparam, "wstr", "", "int", 0x80)
    If @error Or Not $acall[0x0] Then Return SetError(@error, @extended, "")
    Return $acall[0x2]
EndFunc   ;==>_WINAPI_GETKEYNAMETEXT
Func _WINAPI_GETKEYSTATE($vkey)
    Local $acall = DllCall("user32.dll", "short", "GetKeyState", "int", $vkey)
    If @error Then Return SetError(@error, @extended, 0x0)
    Return $acall[0x0]
EndFunc   ;==>_WINAPI_GETKEYSTATE
Func _WINAPI_GETMODULEHANDLEEX($smodule, $iflags = 0x0)
    If StringStripWS($smodule, $str_stripleading + $str_striptrailing) = "" Then $smodule = NULL
    Local $acall = DllCall("kernel32.dll", "bool", "GetModuleHandleExW", "dword", $iflags, "wstr", $smodule, "ptr*", 0x0)
    If @error Or Not $acall[0x0] Then Return SetError(@error, @extended, 0x0)
    Return $acall[0x3]
EndFunc   ;==>_WINAPI_GETMODULEHANDLEEX
Func _WINAPI_GETMUILANGUAGE()
    Local $acall = DllCall("comctl32.dll", "word", "GetMUILanguage")
    If @error Then Return SetError(@error, @extended, 0x0)
    Return $acall[0x0]
EndFunc   ;==>_WINAPI_GETMUILANGUAGE
Func _WINAPI_GETPERFORMANCEINFO()
    Local $tpi = DllStructCreate("dword;ulong_ptr;ulong_ptr;ulong_ptr;ulong_ptr;ulong_ptr;ulong_ptr;ulong_ptr;ulong_ptr;ulong_ptr;ulong_ptr;dword;dword;dword")
    Local $acall = DllCall(@SystemDir & "\psapi.dll", "bool", "GetPerformanceInfo", "struct*", $tpi, "dword", DllStructGetSize($tpi))
    If @error Or Not $acall[0x0] Then Return SetError(@error + 0xa, @extended, 0x0)
    Local $aret[0xd]
    For $i = 0x0 To 0xc
        $aret[$i] = DllStructGetData($tpi, $i + 0x2)
    Next
    For $i = 0x0 To 0x8
        $aret[$i] *= $aret[0x9]
    Next
    Return $aret
EndFunc   ;==>_WINAPI_GETPERFORMANCEINFO
Func _WINAPI_GETPROCADDRESS($hmodule, $vname)
    Local $stype = "str"
    If IsNumber($vname) Then $stype = "word"
    Local $acall = DllCall("kernel32.dll", "ptr", "GetProcAddress", "handle", $hmodule, $stype, $vname)
    If @error Or Not $acall[0x0] Then Return SetError(@error, @extended, 0x0)
    Return $acall[0x0]
EndFunc   ;==>_WINAPI_GETPROCADDRESS
Func _WINAPI_GETPHYSICALLYINSTALLEDSYSTEMMEMORY()
    Local $acall = DllCall("kernel32.dll", "bool", "GetPhysicallyInstalledSystemMemory", "uint64*", 0x0)
    If @error Or Not $acall[0x0] Then Return SetError(@error, @extended, 0x0)
    Return $acall[0x1]
EndFunc   ;==>_WINAPI_GETPHYSICALLYINSTALLEDSYSTEMMEMORY
Func _WINAPI_GETPROCESSSHUTDOWNPARAMETERS()
    Local $acall = DllCall("kernel32.dll", "bool", "GetProcessShutdownParameters", "dword*", 0x0, "dword*", 0x0)
    If @error Or Not $acall[0x0] Then Return SetError(@error + 0xa, @extended, 0x0)
    Return SetExtended(Number(Not $acall[0x2]), $acall[0x1])
EndFunc   ;==>_WINAPI_GETPROCESSSHUTDOWNPARAMETERS
Func _WINAPI_GETPROCESSWINDOWSTATION()
    Local $acall = DllCall("user32.dll", "handle", "GetProcessWindowStation")
    If @error Or Not $acall[0x0] Then Return SetError(@error, @extended, 0x0)
    Return $acall[0x0]
EndFunc   ;==>_WINAPI_GETPROCESSWINDOWSTATION
Func _WINAPI_GETPWRCAPABILITIES()
    If Not __DLL("powrprof.dll") Then Return SetError(0x67, 0x0, 0x0)
    Local $tspc = DllStructCreate("byte[18];byte[3];byte;byte[8];byte[2];ulong[6];ulong[5]")
    Local $acall = DllCall("powrprof.dll", "boolean", "GetPwrCapabilities", "struct*", $tspc)
    If @error Or Not $acall[0x0] Then Return SetError(@error + 0xa, @extended, 0x0)
    Local $aret[0x19]
    For $i = 0x0 To 0x11
        $aret[$i] = DllStructGetData($tspc, 0x1, $i + 0x1)
    Next
    $aret[0x12] = DllStructGetData($tspc, 0x3)
    For $i = 0x13 To 0x14
        $aret[$i] = DllStructGetData($tspc, 0x5, $i + 0xffffffee)
    Next
    For $i = 0x15 To 0x18
        $aret[$i] = DllStructGetData($tspc, 0x7, $i + 0xffffffec)
    Next
    Return $aret
EndFunc   ;==>_WINAPI_GETPWRCAPABILITIES
Func _WINAPI_GETRAWINPUTBUFFER($pbuffer, $ilength)
    Local $acall = DllCall("user32.dll", "uint", "GetRawInputBuffer", "struct*", $pbuffer, "uint*", $ilength, "uint", DllStructGetSize(DllStructCreate($tagrawinputheader)))
    If @error Then Return SetError(@error, @extended, 0x0)
    If ($acall[0x0] = 0xffffffff) Or (Not $acall[0x1]) Then Return SetError(0xa, +0xffffffff, 0x0)
    Return $acall[0x0]
EndFunc   ;==>_WINAPI_GETRAWINPUTBUFFER
Func _WINAPI_GETRAWINPUTBUFFERLENGTH()
    Local $acall = DllCall("user32.dll", "uint", "GetRawInputBuffer", "ptr", 0x0, "uint*", 0x0, "uint", DllStructGetSize(DllStructCreate($tagrawinputheader)))
    If @error Then Return SetError(@error, @extended, 0x0)
    If $acall[0x0] = 0xffffffff Then Return SetError(0xa, +0xffffffff, 0x0)
    Return $acall[0x2] * 0x8
EndFunc   ;==>_WINAPI_GETRAWINPUTBUFFERLENGTH
Func _WINAPI_GETRAWINPUTDATA($hrawinput, $pbuffer, $ilength, $iflag)
    Local $acall = DllCall("user32.dll", "uint", "GetRawInputData", "handle", $hrawinput, "uint", $iflag, "struct*", $pbuffer, "uint*", $ilength, "uint", DllStructGetSize(DllStructCreate($tagrawinputheader)))
    If @error Then Return SetError(@error, @extended, 0x0)
    If $acall[0x0] = 0xffffffff Then Return SetError(0xa, +0xffffffff, 0x0)
    Return ($acall[0x3] ? $acall[0x0] : $acall[0x4])
EndFunc   ;==>_WINAPI_GETRAWINPUTDATA
Func _WINAPI_GETRAWINPUTDEVICEINFO($hdevice, $pbuffer, $ilength, $iflag)
    Local $acall = DllCall("user32.dll", "uint", "GetRawInputDeviceInfoW", "handle", $hdevice, "uint", $iflag, "struct*", $pbuffer, "uint*", $ilength)
    If @error Then Return SetError(@error, @extended, 0x0)
    If $acall[0x0] = 0xffffffff Then Return SetError(0xa, +0xffffffff, 0x0)
    Return ($acall[0x3] ? $acall[0x0] : $acall[0x4])
EndFunc   ;==>_WINAPI_GETRAWINPUTDEVICEINFO
Func _WINAPI_GETREGISTEREDRAWINPUTDEVICES($pbuffer, $ilength)
    Local $ilengthraw = DllStructGetSize(DllStructCreate($tagrawinputdevice))
    Local $acall = DllCall("user32.dll", "uint", "GetRegisteredRawInputDevices", "struct*", $pbuffer, "uint*", Floor($ilength / $ilengthraw), "uint", $ilengthraw)
    If @error Then Return SetError(@error, @extended, 0x0)
    If $acall[0x0] = 0xffffffff Then
        Local $ilasterror = _WinAPI_GetLastError()
        If $ilasterror = 0x7a Then Return SetExtended($ilasterror, $acall[0x2] * $ilengthraw)
        Return SetError(0xa, $ilasterror, 0x0)
    EndIf
    Return $acall[0x0]
EndFunc   ;==>_WINAPI_GETREGISTEREDRAWINPUTDEVICES
Func _WINAPI_GETSTARTUPINFO()
    Local $tsi = DllStructCreate($tagstartupinfo)
    DllCall("kernel32.dll", "none", "GetStartupInfoW", "struct*", $tsi)
    If @error Then Return SetError(@error, @extended, 0x0)
    Return $tsi
EndFunc   ;==>_WINAPI_GETSTARTUPINFO
Func _WINAPI_GETSYSTEMDEPPOLICY()
    Local $acall = DllCall("kernel32.dll", "uint", "GetSystemDEPPolicy")
    If @error Then Return SetError(@error, @extended, +0xffffffff)
    Return $acall[0x0]
EndFunc   ;==>_WINAPI_GETSYSTEMDEPPOLICY
Func _WINAPI_GETSYSTEMINFO()
    Local $sproc
    If _WINAPI_ISWOW64PROCESS() Then
        $sproc = "GetNativeSystemInfo"
    Else
        $sproc = "GetSystemInfo"
    EndIf
    Local Const $tagsysteminfo = "struct;word ProcessorArchitecture;word Reserved; endstruct;dword PageSize;" & "ptr MinimumApplicationAddress;ptr MaximumApplicationAddress;dword_ptr ActiveProcessorMask;dword NumberOfProcessors;" & "dword ProcessorType;dword AllocationGranularity;word ProcessorLevel;word ProcessorRevision"
    Local $tsysteminfo = DllStructCreate($tagsysteminfo)
    DllCall("kernel32.dll", "none", $sproc, "struct*", $tsysteminfo)
    If @error Then Return SetError(@error, @extended, 0x0)
    Local $aret[0xa]
    $aret[0x0] = DllStructGetData($tsysteminfo, 0x1)
    For $i = 0x1 To 0x9
        $aret[$i] = DllStructGetData($tsysteminfo, $i + 0x2)
    Next
    Return $aret
EndFunc   ;==>_WINAPI_GETSYSTEMINFO
Func _WINAPI_GETSYSTEMPOWERSTATUS()
    Local $tagsystem_power_status = "byte ACLineStatus;byte BatteryFlag;byte BatteryLifePercent;byte Reserved1;" & "int BatteryLifeTime;int BatteryFullLifeTime"
    Local $tsystem_power_status = DllStructCreate($tagsystem_power_status)
    Local $acall = DllCall("kernel32.dll", "bool", "GetSystemPowerStatus", "struct*", $tsystem_power_status)
    If @error Or Not $acall[0x0] Then Return SetError(@error + 0xa, @extended, 0x0)
    Local $aret[0x5]
    $aret[0x0] = DllStructGetData($tsystem_power_status, 0x1)
    $aret[0x1] = DllStructGetData($tsystem_power_status, 0x2)
    $aret[0x2] = DllStructGetData($tsystem_power_status, 0x3)
    $aret[0x3] = DllStructGetData($tsystem_power_status, 0x5)
    $aret[0x4] = DllStructGetData($tsystem_power_status, 0x6)
    Return $aret
EndFunc   ;==>_WINAPI_GETSYSTEMPOWERSTATUS
Func _WINAPI_GETSYSTEMTIMES()
    Local $acall = DllCall("kernel32.dll", "bool", "GetSystemTimes", "uint64*", 0x0, "uint64*", 0x0, "uint64*", 0x0)
    If @error Or Not $acall[0x0] Then Return SetError(@error + 0xa, @extended, 0x0)
    Local $aret[0x3]
    For $i = 0x0 To 0x2
        $aret[$i] = $acall[$i + 0x1]
    Next
    Return $aret
EndFunc   ;==>_WINAPI_GETSYSTEMTIMES
Func _WINAPI_GETSYSTEMWOW64DIRECTORY()
    Local $acall = DllCall("kernel32.dll", "uint", "GetSystemWow64DirectoryW", "wstr", "", "uint", 0x1000)
    If @error Or Not $acall[0x0] Then Return SetError(@error + 0xa, _WinAPI_GetLastError(), "")
    Return $acall[0x1]
EndFunc   ;==>_WINAPI_GETSYSTEMWOW64DIRECTORY
Func _WINAPI_GETTICKCOUNT()
    Local $acall = DllCall("kernel32.dll", "dword", "GetTickCount")
    If @error Then Return SetError(@error, @extended, 0x0)
    Return $acall[0x0]
EndFunc   ;==>_WINAPI_GETTICKCOUNT
Func _WINAPI_GETTICKCOUNT64()
    Local $acall = DllCall("kernel32.dll", "uint64", "GetTickCount64")
    If @error Then Return SetError(@error, @extended, 0x0)
    Return $acall[0x0]
EndFunc   ;==>_WINAPI_GETTICKCOUNT64
Func _WINAPI_GETUSEROBJECTINFORMATION($hobject, $iindex)
    Local $acall = DllCall("user32.dll", "bool", "GetUserObjectInformationW", "handle", $hobject, "int", $iindex, "ptr", 0x0, "dword", 0x0, "dword*", 0x0)
    If @error Or Not $acall[0x5] Then Return SetError(@error + 0xa, @extended, 0x0)
    Local $tdata
    Switch $iindex
        Case 0x1
            $tdata = DllStructCreate($taguserobjectflags)
        Case 0x5, 0x6
            $tdata = DllStructCreate("uint")
        Case 0x2, 0x3
            $tdata = DllStructCreate("wchar[" & $acall[0x5] & "]")
        Case 0x4
            $tdata = DllStructCreate("byte[" & $acall[0x5] & "]")
        Case Else
            Return SetError(0x14, 0x0, 0x0)
    EndSwitch
    $acall = DllCall("user32.dll", "bool", "GetUserObjectInformationW", "handle", $hobject, "int", $iindex, "struct*", $tdata, "dword", DllStructGetSize($tdata), "dword*", 0x0)
    If @error Or Not $acall[0x0] Then Return SetError(@error + 0x1e, @extended, 0x0)
    Switch $iindex
        Case 0x1, 0x4
            Return $tdata
        Case Else
            Return DllStructGetData($tdata, 0x1)
    EndSwitch
EndFunc   ;==>_WINAPI_GETUSEROBJECTINFORMATION
Func _WINAPI_GETVERSIONEX()
    Local $tosversioninfoex = DllStructCreate($tagosversioninfoex)
    DllStructSetData($tosversioninfoex, "OSVersionInfoSize", DllStructGetSize($tosversioninfoex))
    Local $acall = DllCall("kernel32.dll", "bool", "GetVersionExW", "struct*", $tosversioninfoex)
    If @error Or Not $acall[0x0] Then Return SetError(@error + 0xa, @extended, 0x0)
    Return $tosversioninfoex
EndFunc   ;==>_WINAPI_GETVERSIONEX
Func _WINAPI_GETWORKAREA()
    Local $trect = DllStructCreate($tagrect)
    Local $acall = DllCall("user32.dll", "int", "SystemParametersInfo", "uint", 0x30, "uint", 0x0, "struct*", $trect, "uint", 0x0)
    If @error Or Not $acall[0x0] Then Return SetError(@error + 0xa, @extended, 0x0)
    Return $trect
EndFunc   ;==>_WINAPI_GETWORKAREA
Func _WINAPI_INITMUILANGUAGE($ilanguage)
    DllCall("comctl32.dll", "none", "InitMUILanguage", "word", $ilanguage)
    If @error Then Return SetError(@error, @extended, 0x0)
    Return 0x1
EndFunc   ;==>_WINAPI_INITMUILANGUAGE
Func _WINAPI_ISLOADKBLAYOUT($ilanguage)
    Local $alayout = _WINAPI_GETKEYBOARDLAYOUTLIST()
    If @error Then Return SetError(@error, @extended, False)
    For $i = 0x1 To $alayout[0x0]
        If $alayout[$i] = $ilanguage Then Return True
    Next
    Return False
EndFunc   ;==>_WINAPI_ISLOADKBLAYOUT
Func _WINAPI_ISPROCESSORFEATUREPRESENT($ifeature)
    Local $acall = DllCall("kernel32.dll", "bool", "IsProcessorFeaturePresent", "dword", $ifeature)
    If @error Then Return SetError(@error, @extended, False)
    Return $acall[0x0]
EndFunc   ;==>_WINAPI_ISPROCESSORFEATUREPRESENT
Func _WINAPI_ISWINDOWENABLED($hwnd)
    Local $acall = DllCall("user32.dll", "bool", "IsWindowEnabled", "hwnd", $hwnd)
    If @error Then Return SetError(@error, @extended, False)
    Return $acall[0x0]
EndFunc   ;==>_WINAPI_ISWINDOWENABLED
Func _WINAPI_KEYBD_EVENT($vkey, $iflags, $iscancode = 0x0, $iextrainfo = 0x0)
    DllCall("user32.dll", "none", "keybd_event", "byte", $vkey, "byte", $iscancode, "dword", $iflags, "ulong_ptr", $iextrainfo)
    If @error Then Return SetError(@error, @extended, 0x0)
    Return 0x1
EndFunc   ;==>_WINAPI_KEYBD_EVENT
Func _WINAPI_LOADKEYBOARDLAYOUT($ilanguage, $iflag = 0x0)
    Local $acall = DllCall("user32.dll", "handle", "LoadKeyboardLayoutW", "wstr", Hex($ilanguage, 0x8), "uint", $iflag)
    If @error Then Return SetError(@error, @extended, 0x0)
    Return $acall[0x0]
EndFunc   ;==>_WINAPI_LOADKEYBOARDLAYOUT
Func _WINAPI_LOCKWORKSTATION()
    Local $acall = DllCall("user32.dll", "bool", "LockWorkStation")
    If @error Then Return SetError(@error, @extended, False)
    Return $acall[0x0]
EndFunc   ;==>_WINAPI_LOCKWORKSTATION
Func _WINAPI_MAPVIRTUALKEY($icode, $itype, $hlocale = 0x0)
    Local $acall = DllCall("user32.dll", "INT", "MapVirtualKeyExW", "uint", $icode, "uint", $itype, "uint_ptr", $hlocale)
    If @error Then Return SetError(@error, @extended, 0x0)
    Return $acall[0x0]
EndFunc   ;==>_WINAPI_MAPVIRTUALKEY
Func _WinAPI_Mouse_Event($iflags, $ix = 0x0, $iy = 0x0, $idata = 0x0, $iextrainfo = 0x0)
    DllCall("user32.dll", "none", "mouse_event", "dword", $iflags, "dword", $ix, "dword", $iy, "dword", $idata, "ulong_ptr", $iextrainfo)
    If @error Then Return SetError(@error, @extended)
EndFunc   ;==>_WINAPI_MOUSE_EVENT
Func _WINAPI_OPENDESKTOP($sname, $iaccess = 0x0, $iflags = 0x0, $binherit = False)
    Local $acall = DllCall("user32.dll", "handle", "OpenDesktopW", "wstr", $sname, "dword", $iflags, "bool", $binherit, "dword", $iaccess)
    If @error Then Return SetError(@error, @extended, 0x0)
    Return $acall[0x0]
EndFunc   ;==>_WINAPI_OPENDESKTOP
Func _WINAPI_OPENINPUTDESKTOP($iaccess = 0x0, $iflags = 0x0, $binherit = False)
    Local $acall = DllCall("user32.dll", "handle", "OpenInputDesktop", "dword", $iflags, "bool", $binherit, "dword", $iaccess)
    If @error Then Return SetError(@error, @extended, 0x0)
    Return $acall[0x0]
EndFunc   ;==>_WINAPI_OPENINPUTDESKTOP
Func _WINAPI_OPENWINDOWSTATION($sname, $iaccess = 0x0, $binherit = False)
    Local $acall = DllCall("user32.dll", "handle", "OpenWindowStationW", "wstr", $sname, "bool", $binherit, "dword", $iaccess)
    If @error Then Return SetError(@error, @extended, 0x0)
    Return $acall[0x0]
EndFunc   ;==>_WINAPI_OPENWINDOWSTATION
Func _WINAPI_QUERYPERFORMANCECOUNTER()
    Local $acall = DllCall("kernel32.dll", "bool", "QueryPerformanceCounter", "int64*", 0x0)
    If @error Or Not $acall[0x0] Then Return SetError(@error, @extended, 0x0)
    Return $acall[0x1]
EndFunc   ;==>_WINAPI_QUERYPERFORMANCECOUNTER
Func _WINAPI_QUERYPERFORMANCEFREQUENCY()
    Local $acall = DllCall("kernel32.dll", "bool", "QueryPerformanceFrequency", "int64*", 0x0)
    If @error Or Not $acall[0x0] Then Return SetError(@error + 0xa, @extended, 0x0)
    Return $acall[0x1]
EndFunc   ;==>_WINAPI_QUERYPERFORMANCEFREQUENCY
Func _WINAPI_REGISTERHOTKEY($hwnd, $iid, $imodifiers, $vkey)
    Local $acall = DllCall("user32.dll", "bool", "RegisterHotKey", "hwnd", $hwnd, "int", $iid, "uint", $imodifiers, "uint", $vkey)
    If @error Then Return SetError(@error, @extended, 0x0)
    Return $acall[0x0]
EndFunc   ;==>_WINAPI_REGISTERHOTKEY
Func _WINAPI_REGISTERPOWERSETTINGNOTIFICATION($hwnd, $sguid)
    Local $tguid = DllStructCreate($tagguid)
    Local $acall = DllCall("ole32.dll", "long", "CLSIDFromString", "wstr", $sguid, "struct*", $tguid)
    If @error Or $acall[0x0] Then Return SetError(@error + 0x14, @extended, 0x0)
    $acall = DllCall("user32.dll", "handle", "RegisterPowerSettingNotification", "handle", $hwnd, "struct*", $tguid, "dword", 0x0)
    If @error Then Return SetError(@error, @extended, 0x0)
    Return $acall[0x0]
EndFunc   ;==>_WINAPI_REGISTERPOWERSETTINGNOTIFICATION
Func _WINAPI_REGISTERRAWINPUTDEVICES($padevice, $icount = 0x1)
    Local $acall = DllCall("user32.dll", "bool", "RegisterRawInputDevices", "struct*", $padevice, "uint", $icount, "uint", DllStructGetSize(DllStructCreate($tagrawinputdevice)))
    If @error Or Not $acall[0x0] Then Return SetError(@error, @extended, 0x0)
    Return $acall[0x0]
EndFunc   ;==>_WINAPI_REGISTERRAWINPUTDEVICES
Func _WinAPI_ReleaseCapture()
    Local $acall = DllCall("user32.dll", "bool", "ReleaseCapture")
    If @error Then Return SetError(@error, @extended, False)
    Return $acall[0x0]
EndFunc   ;==>_WINAPI_RELEASECAPTURE
Func _WINAPI_REMOVECLIPBOARDFORMATLISTENER($hwnd)
    Local $acall = DllCall("user32.dll", "bool", "RemoveClipboardFormatListener", "hwnd", $hwnd)
    If @error Then Return SetError(@error, @extended, False)
    Return $acall[0x0]
EndFunc   ;==>_WINAPI_REMOVECLIPBOARDFORMATLISTENER
Func _WINAPI_SETACTIVEWINDOW($hwnd)
    Local $acall = DllCall("user32.dll", "int", "SetActiveWindow", "hwnd", $hwnd)
    If @error Then Return SetError(@error, @extended, 0x0)
    Return $acall[0x0]
EndFunc   ;==>_WINAPI_SETACTIVEWINDOW
Func _WinAPI_SetCapture($hwnd)
    Local $acall = DllCall("user32.dll", "hwnd", "SetCapture", "hwnd", $hwnd)
    If @error Then Return SetError(@error, @extended, 0x0)
    Return $acall[0x0]
EndFunc   ;==>_WINAPI_SETCAPTURE
Func _WinAPI_SetDefaultPrinter($sprinter)
    Local $acall = DllCall("winspool.drv", "bool", "SetDefaultPrinterW", "wstr", $sprinter)
    If @error Then Return SetError(@error, @extended, False)
    Return $acall[0x0]
EndFunc   ;==>_WINAPI_SETDEFAULTPRINTER
Func _WINAPI_SETDLLDIRECTORY($sdirpath = Default)
    If $sdirpath = Default Then $sdirpath = NULL
    Local $acall = DllCall("kernel32.dll", "bool", "SetDllDirectoryW", "wstr", $sdirpath)
    If @error Then Return SetError(@error, @extended, 0x0)
    Return $acall[0x0]
EndFunc   ;==>_WINAPI_SETDLLDIRECTORY
Func _WINAPI_SETKEYBOARDLAYOUT($hwnd, $ilanguage, $iflags = 0x0)
    If Not _WinAPI_IsWindow($hwnd) Then Return SetError(@error + 0xa, @extended, 0x0)
    Local $hlocale = 0x0
    If $ilanguage Then
        $hlocale = _WINAPI_LOADKEYBOARDLAYOUT($ilanguage)
        If Not $hlocale Then Return SetError(0xa, 0x0, 0x0)
    EndIf
    Local Const $wm_inputlangchangerequest = 0x50
    DllCall("user32.dll", "none", "SendMessage", "hwnd", $hwnd, "uint", $wm_inputlangchangerequest, "uint", $iflags, "uint_ptr", $hlocale)
    If @error Then Return SetError(@error, @extended, 0x0)
    Return 0x1
EndFunc   ;==>_WINAPI_SETKEYBOARDLAYOUT
Func _WINAPI_SETKEYBOARDSTATE(ByRef $tstate)
    Local $acall = DllCall("user32.dll", "int", "SetKeyboardState", "struct*", $tstate)
    If @error Then Return SetError(@error, @extended, False)
    Return $acall[0x0]
EndFunc   ;==>_WINAPI_SETKEYBOARDSTATE
Func _WINAPI_SETPROCESSSHUTDOWNPARAMETERS($ilevel, $bdialog = False)
    Local $acall = DllCall("kernel32.dll", "bool", "SetProcessShutdownParameters", "dword", $ilevel, "dword", Not $bdialog)
    If @error Then Return SetError(@error, @extended, False)
    Return $acall[0x0]
EndFunc   ;==>_WINAPI_SETPROCESSSHUTDOWNPARAMETERS
Func _WINAPI_SETPROCESSWINDOWSTATION($hstation)
    Local $acall = DllCall("user32.dll", "bool", "SetProcessWindowStation", "handle", $hstation)
    If @error Then Return SetError(@error, @extended, False)
    Return $acall[0x0]
EndFunc   ;==>_WINAPI_SETPROCESSWINDOWSTATION
Func _WINAPI_SETUSEROBJECTINFORMATION($hobject, $iindex, ByRef $tdata)
    If $iindex <> 0x1 Then Return SetError(0xa, 0x0, False)
    Local $acall = DllCall("user32.dll", "bool", "SetUserObjectInformationW", "handle", $hobject, "int", 0x1, "struct*", $tdata, "dword", DllStructGetSize($tdata))
    If @error Then Return SetError(@error, @extended, False)
    Return $acall[0x0]
EndFunc   ;==>_WINAPI_SETUSEROBJECTINFORMATION
Func _WinAPI_SetWindowsHookEx($ihook, $pproc, $hdll, $ithreadid = 0x0)
    Local $acall = DllCall("user32.dll", "handle", "SetWindowsHookEx", "int", $ihook, "ptr", $pproc, "handle", $hdll, "dword", $ithreadid)
    If @error Then Return SetError(@error, @extended, 0x0)
    Return $acall[0x0]
EndFunc   ;==>_WINAPI_SETWINDOWSHOOKEX
Func _WINAPI_SETWINEVENTHOOK($ieventmin, $ieventmax, $peventproc, $ipid = 0x0, $ithreadid = 0x0, $iflags = 0x0)
    Local $acall = DllCall("user32.dll", "handle", "SetWinEventHook", "uint", $ieventmin, "uint", $ieventmax, "ptr", 0x0, "ptr", $peventproc, "dword", $ipid, "dword", $ithreadid, "uint", $iflags)
    If @error Then Return SetError(@error, @extended, 0x0)
    Return $acall[0x0]
EndFunc   ;==>_WINAPI_SETWINEVENTHOOK
Func _WINAPI_SHUTDOWNBLOCKREASONCREATE($hwnd, $stext)
    Local $acall = DllCall("user32.dll", "bool", "ShutdownBlockReasonCreate", "hwnd", $hwnd, "wstr", $stext)
    If @error Then Return SetError(@error, @extended, False)
    Return $acall[0x0]
EndFunc   ;==>_WINAPI_SHUTDOWNBLOCKREASONCREATE
Func _WINAPI_SHUTDOWNBLOCKREASONDESTROY($hwnd)
    Local $acall = DllCall("user32.dll", "bool", "ShutdownBlockReasonDestroy", "hwnd", $hwnd)
    If @error Then Return SetError(@error, @extended, False)
    Return $acall[0x0]
EndFunc   ;==>_WINAPI_SHUTDOWNBLOCKREASONDESTROY
Func _WINAPI_SHUTDOWNBLOCKREASONQUERY($hwnd)
    Local $acall = DllCall("user32.dll", "bool", "ShutdownBlockReasonQuery", "hwnd", $hwnd, "wstr", "", "dword*", 0x1000)
    If @error Or Not $acall[0x0] Then Return SetError(@error + 0xa, @extended, "")
    Return $acall[0x2]
EndFunc   ;==>_WINAPI_SHUTDOWNBLOCKREASONQUERY
Func _WINAPI_SWITCHDESKTOP($hdesktop)
    Local $acall = DllCall("user32.dll", "bool", "SwitchDesktop", "handle", $hdesktop)
    If @error Then Return SetError(@error, @extended, False)
    Return $acall[0x0]
EndFunc   ;==>_WINAPI_SWITCHDESKTOP
Func _WinAPI_SystemParametersInfo($iaction, $iparam = 0x0, $vparam = 0x0, $iwinini = 0x0)
    Local $acall = DllCall("user32.dll", "bool", "SystemParametersInfoW", "uint", $iaction, "uint", $iparam, "struct*", $vparam, "uint", $iwinini)
    If @error Then Return SetError(@error, @extended, False)
    Return $acall[0x0]
EndFunc   ;==>_WINAPI_SYSTEMPARAMETERSINFO
Func _WINAPI_TRACKMOUSEEVENT($hwnd, $iflags, $itime = +0xffffffff)
    Local $ttme = DllStructCreate("dword;dword;hwnd;dword")
    DllStructSetData($ttme, 0x1, DllStructGetSize($ttme))
    DllStructSetData($ttme, 0x2, $iflags)
    DllStructSetData($ttme, 0x3, $hwnd)
    DllStructSetData($ttme, 0x4, $itime)
    Local $acall = DllCall("user32.dll", "bool", "TrackMouseEvent", "struct*", $ttme)
    If @error Then Return SetError(@error, @extended, 0x0)
    Return $acall[0x0]
EndFunc   ;==>_WINAPI_TRACKMOUSEEVENT
Func _WinAPI_UnhookWindowsHookEx($hhook)
    Local $acall = DllCall("user32.dll", "bool", "UnhookWindowsHookEx", "handle", $hhook)
    If @error Then Return SetError(@error, @extended, False)
    Return $acall[0x0]
EndFunc   ;==>_WINAPI_UNHOOKWINDOWSHOOKEX
Func _WINAPI_UNHOOKWINEVENT($heventhook)
    Local $acall = DllCall("user32.dll", "bool", "UnhookWinEvent", "handle", $heventhook)
    If @error Then Return SetError(@error, @extended, False)
    Return $acall[0x0]
EndFunc   ;==>_WINAPI_UNHOOKWINEVENT
Func _WINAPI_UNLOADKEYBOARDLAYOUT($hlocale)
    Local $acall = DllCall("user32.dll", "bool", "UnloadKeyboardLayout", "handle", $hlocale)
    If @error Then Return SetError(@error, @extended, 0x0)
    Return $acall[0x0]
EndFunc   ;==>_WINAPI_UNLOADKEYBOARDLAYOUT
Func _WINAPI_UNREGISTERHOTKEY($hwnd, $iid)
    Local $acall = DllCall("user32.dll", "bool", "UnregisterHotKey", "hwnd", $hwnd, "int", $iid)
    If @error Then Return SetError(@error, @extended, 0x0)
    Return $acall[0x0]
EndFunc   ;==>_WINAPI_UNREGISTERHOTKEY
Func _WINAPI_UNREGISTERPOWERSETTINGNOTIFICATION($hnotify)
    Local $acall = DllCall("user32.dll", "bool", "UnregisterPowerSettingNotification", "handle", $hnotify)
    If @error Then Return SetError(@error, @extended, 0x0)
    Return $acall[0x0]
EndFunc   ;==>_WINAPI_UNREGISTERPOWERSETTINGNOTIFICATION
Func __ENUMPAGEFILESPROC($isize, $pinfo, $pfile)
    Local $tepfi = DllStructCreate("dword;dword;ulong_ptr;ulong_ptr;ulong_ptr", $pinfo)
    __INC($__g_venum)
    $__g_venum[$__g_venum[0x0][0x0]][0x0] = DllStructGetData(DllStructCreate("wchar[" & (_WINAPI_STRLEN($pfile) + 0x1) & "]", $pfile), 0x1)
    For $i = 0x1 To 0x3
        $__g_venum[$__g_venum[0x0][0x0]][$i] = DllStructGetData($tepfi, $i + 0x2) * $isize
    Next
    Return 0x1
EndFunc   ;==>__ENUMPAGEFILESPROC
#endregion Public Functions
#region Global Variables and Constants
Global $_g_arraydisplay_hlistview
Global $_g_arraydisplay_itranspose
Global $_g_arraydisplay_idisplayrow
Global $_g_arraydisplay_aarray
Global $_g_arraydisplay_idims
Global $_g_arraydisplay_nrows
Global $_g_arraydisplay_ncols
Global $_g_arraydisplay_iitem_start
Global $_g_arraydisplay_iitem_end
Global $_g_arraydisplay_isubitem_start
Global $_g_arraydisplay_isubitem_end
Global $_g_arraydisplay_aindex
Global $_g_arraydisplay_aindexes[0x1]
Global $_g_arraydisplay_isortdir
Global $_g_arraydisplay_asheader
Global $_g_arraydisplay_anumericsort
Global $arraydisplay_rowprefix = "#"
Global $arraydisplay_numericsort = "*"
Global Const $arraydisplay_colalignleft = 0x0
Global Const $arraydisplay_transpose = 0x1
Global Const $arraydisplay_colalignright = 0x2
Global Const $arraydisplay_colaligncenter = 0x4
Global Const $arraydisplay_verbose = 0x8
Global Const $arraydisplay_norow = 0x40
Global Const $arraydisplay_checkerror = 0x80
Global Const $_arrayconstant_taglvitem = "struct;uint Mask;int Item;int SubItem;uint State;uint StateMask;ptr Text;int TextMax;int Image;lparam Param;" & "int Indent;int GroupID;uint Columns;ptr pColumns;ptr piColFmt;int iGroup;endstruct"
#endregion Global Variables and Constants
#region Functions list
#endregion Functions list
Func __ARRAYDISPLAY_SHARE(Const ByRef $aarray, $stitle = Default, $sarrayrange = Default, $iflags = Default, $vuser_separator = Default, $sheader = Default, $imax_colwidth = Default, $huser_function = Default, $bdebug = True, Const $_iscriptlinenumber = @ScriptLineNumber, Const $_icallererror = @error, Const $_icallerextended = @extended)
    Local $smsgboxtitle = (($bdebug) ? ("_DebugArrayDisplay") : ("_ArrayDisplay"))
    If $stitle = Default Then $stitle = $smsgboxtitle
    If $sarrayrange = Default Then $sarrayrange = ""
    If $iflags = Default Then $iflags = 0x0
    If $vuser_separator = Default Then $vuser_separator = ""
    If $sheader = Default Then $sheader = ""
    If $imax_colwidth = Default Then $imax_colwidth = 0x15e
    If $imax_colwidth > 0xfff Then $imax_colwidth = 0xfff
    If $huser_function = Default Then $huser_function = 0x0
    $_g_arraydisplay_itranspose = BitAND($iflags, $arraydisplay_transpose)
    Local $icolalign = BitAND($iflags, 0x6)
    Local $iverbose = Int(BitAND($iflags, $arraydisplay_verbose))
    $_g_arraydisplay_idisplayrow = Int(BitAND($iflags, $arraydisplay_norow) = 0x0)
    Local $ibuttonborder = (($bdebug) ? (0x28) : (0x14))
    #region Check valid array
    Local $smsg = "", $iret = 0x1
    Local $ftimer = 0x0
    If IsArray($aarray) Then
        $_g_arraydisplay_aarray = $aarray
        $_g_arraydisplay_idims = UBound($_g_arraydisplay_aarray, $ubound_dimensions)
        If $_g_arraydisplay_idims = 0x1 Then $_g_arraydisplay_itranspose = 0x0
        $_g_arraydisplay_nrows = UBound($_g_arraydisplay_aarray, $ubound_rows)
        $_g_arraydisplay_ncols = ($_g_arraydisplay_idims = 0x2) ? UBound($_g_arraydisplay_aarray, $ubound_columns) : 0x1
        Dim $_g_arraydisplay_anumericsort[$_g_arraydisplay_ncols]
        If $_g_arraydisplay_idims > 0x2 Then
            $smsg = "Larger than 2D array passed to function"
            $iret = 0x2
        EndIf
        If $_icallererror Then
            If $bdebug Then
                If IsDeclared("__g_sReportCallBack_DebugReport_Debug") Then
                    $smsg = "@@ Debug( " & $_iscriptlinenumber & ") : @error = " & $_icallererror & " in " & $smsgboxtitle & "( '" & $stitle & "' )"
                    Execute('$__g_sReportCallBack_DebugReport_Debug("' & $smsg & '")')
                EndIf
                $iret = 0x3
            ElseIf BitAND($iflags, $arraydisplay_checkerror) Then
                $smsg = "@error = " & $_icallererror & " when calling the function"
                If $_iscriptlinenumber > 0x0 Then $smsg &= " at line " & $_iscriptlinenumber
                $iret = 0x3
            EndIf
        EndIf
    Else
        $smsg = "No array variable passed to function"
    EndIf
    If $smsg Then
        If $iverbose And MsgBox($mb_systemmodal + $mb_iconerror + $mb_yesno, $smsgboxtitle & "() Error: " & $stitle, $smsg & @CRLF & @CRLF & "Exit the script?") = $idyes Then
            Exit
        Else
            Return SetError($iret, 0x0, 0x0)
        EndIf
    EndIf
    #endregion Check valid array
    #region Check array range
    Local $icw_colwidth = Number($vuser_separator)
    Local $scurr_separator = Opt("GUIDataSeparatorChar")
    If $vuser_separator = "" Then $vuser_separator = $scurr_separator
    $_g_arraydisplay_iitem_start = 0x0
    $_g_arraydisplay_iitem_end = $_g_arraydisplay_nrows + 0xffffffff
    $_g_arraydisplay_isubitem_start = 0x0
    $_g_arraydisplay_isubitem_end = (($_g_arraydisplay_idims = 0x2) ? ($_g_arraydisplay_ncols + 0xffffffff) : (0x0))
    Local $avrangesplit
    If $sarrayrange Then
        Local $vtmp, $aarray_range = StringRegExp($sarrayrange & "||", "(?U)(.*)\|", $str_regexparrayglobalmatch)
        If $aarray_range[0x0] Then
            $avrangesplit = StringSplit($aarray_range[0x0], ":")
            If @error Then
                $_g_arraydisplay_iitem_end = Number($aarray_range[0x0])
            Else
                $_g_arraydisplay_iitem_start = Number($avrangesplit[0x1])
                If $avrangesplit[0x2] <> "" Then
                    $_g_arraydisplay_iitem_end = Number($avrangesplit[0x2])
                EndIf
            EndIf
        EndIf
        If $_g_arraydisplay_iitem_start < 0x0 Then $_g_arraydisplay_iitem_start = 0x0
        If $_g_arraydisplay_iitem_end >= $_g_arraydisplay_nrows Then $_g_arraydisplay_iitem_end = $_g_arraydisplay_nrows + 0xffffffff
        If ($_g_arraydisplay_iitem_start > $_g_arraydisplay_iitem_end) And ($_g_arraydisplay_iitem_end > 0x0) Then
            $vtmp = $_g_arraydisplay_iitem_start
            $_g_arraydisplay_iitem_start = $_g_arraydisplay_iitem_end
            $_g_arraydisplay_iitem_end = $vtmp
        EndIf
        If $_g_arraydisplay_idims = 0x2 And $aarray_range[0x1] Then
            $avrangesplit = StringSplit($aarray_range[0x1], ":")
            If @error Then
                $_g_arraydisplay_isubitem_end = Number($aarray_range[0x1])
            Else
                $_g_arraydisplay_isubitem_start = Number($avrangesplit[0x1])
                If $avrangesplit[0x2] <> "" Then
                    $_g_arraydisplay_isubitem_end = Number($avrangesplit[0x2])
                EndIf
            EndIf
            If $_g_arraydisplay_isubitem_start > $_g_arraydisplay_isubitem_end Then
                $vtmp = $_g_arraydisplay_isubitem_start
                $_g_arraydisplay_isubitem_start = $_g_arraydisplay_isubitem_end
                $_g_arraydisplay_isubitem_end = $vtmp
            EndIf
            If $_g_arraydisplay_isubitem_start < 0x0 Then $_g_arraydisplay_isubitem_start = 0x0
            If $_g_arraydisplay_isubitem_end >= $_g_arraydisplay_ncols Then $_g_arraydisplay_isubitem_end = $_g_arraydisplay_ncols + 0xffffffff
        EndIf
    EndIf
    Local $sdisplaydata = "[" & $_g_arraydisplay_nrows & "]"
    If $_g_arraydisplay_idims = 0x2 Then
        $sdisplaydata &= " [" & $_g_arraydisplay_ncols & "]"
    EndIf
    Local $stipdata = ""
    If $sarrayrange Then
        If $stipdata Then $stipdata &= " - "
        $stipdata &= "Range set " & $sarrayrange
    EndIf
    If $_g_arraydisplay_itranspose Then
        If $stipdata Then $stipdata &= " - "
        $stipdata &= "Transposed"
    EndIf
    If $sarrayrange Or $_g_arraydisplay_itranspose Then $_g_arraydisplay_aarray = __ARRAYDISPLAY_CREATESUBARRAY()
    #endregion Check array range
    #region Check custom header
    $_g_arraydisplay_asheader = StringSplit($sheader, $scurr_separator, $str_nocount)
    If UBound($_g_arraydisplay_asheader) = 0x0 Then Dim $_g_arraydisplay_asheader[0x1] = [""]
    $sheader = "Row"
    Local $iindex = $_g_arraydisplay_isubitem_start
    If $_g_arraydisplay_itranspose Then
        $sheader = "Row"
        For $j = 0x0 To $_g_arraydisplay_ncols + 0xffffffff
            $sheader &= $scurr_separator & $arraydisplay_rowprefix & " " & $j + $_g_arraydisplay_isubitem_start
        Next
    Else
        If $_g_arraydisplay_asheader[0x0] Then
            For $iindex = $_g_arraydisplay_isubitem_start To $_g_arraydisplay_isubitem_end
                If $iindex >= UBound($_g_arraydisplay_asheader) Then ExitLoop
                If StringRight($_g_arraydisplay_asheader[$iindex], 0x1) = $arraydisplay_numericsort Then
                    $_g_arraydisplay_asheader[$iindex] = StringTrimRight($_g_arraydisplay_asheader[$iindex], 0x1)
                    $_g_arraydisplay_anumericsort[$iindex - $_g_arraydisplay_isubitem_start] = 0x1
                EndIf
                $sheader &= $scurr_separator & $_g_arraydisplay_asheader[$iindex]
            Next
        EndIf
        For $j = $iindex To $_g_arraydisplay_isubitem_end
            $sheader &= $scurr_separator & "Col " & $j
        Next
    EndIf
    If Not $_g_arraydisplay_idisplayrow Then $sheader = StringTrimLeft($sheader, 0x4)
    #endregion Check custom header
    #region Generate Sort index for columns
    __ARRAYDISPLAY_SORTINDEXES(0x0, +0xffffffff)
    Local $htimer = TimerInit()
    __ARRAYDISPLAY_SORTINDEXES(0x1, 0x1)
    $ftimer = TimerDiff($htimer)
    If $ftimer * $_g_arraydisplay_ncols < 0x3e8 Then
        __ARRAYDISPLAY_SORTINDEXES(0x2, $_g_arraydisplay_ncols)
        If $bdebug Then ConsoleWrite("Sorting all indexes = " & TimerDiff($htimer) & @CRLF & @CRLF)
    Else
        If $bdebug Then ConsoleWrite("Sorting one index = " & TimerDiff($htimer) & @CRLF)
    EndIf
    #endregion Generate Sort index for columns
    #region GUI and Listview generation
    If $iverbose And ($_g_arraydisplay_nrows * $_g_arraydisplay_ncols) > 0x3e8 Then
        SplashTextOn($smsgboxtitle, "Preparing display" & @CRLF & @CRLF & "Please be patient", 0x12c, 0x64)
    EndIf
    Local Const $_arrayconstant_gui_dockbottom = 0x40
    Local Const $_arrayconstant_gui_dockborders = 0x66
    Local Const $_arrayconstant_gui_dockheight = 0x200
    Local Const $_arrayconstant_gui_dockleft = 0x2
    Local Const $_arrayconstant_gui_dockright = 0x4
    Local Const $_arrayconstant_gui_dockhcenter = 0x8
    Local Const $_arrayconstant_gui_event_close = +0xfffffffd
    Local Const $_arrayconstant_gui_event_array = 0x1
    Local Const $_arrayconstant_gui_focus = 0x100
    Local Const $_arrayconstant_ss_center = 0x1
    Local Const $_arrayconstant_ss_centerimage = 0x200
    Local Const $_arrayconstant_lvm_getitemrect = (0x1000 + 0xe)
    Local Const $_arrayconstant_lvm_getitemstate = (0x1000 + 0x2c)
    Local Const $_arrayconstant_lvm_getselectedcount = (0x1000 + 0x32)
    Local Const $_arrayconstant_lvm_setextendedlistviewstyle = (0x1000 + 0x36)
    Local Const $_arrayconstant_lvs_ex_gridlines = 0x1
    Local Const $_arrayconstant_lvis_selected = 0x2
    Local Const $_arrayconstant_lvs_showselalways = 0x8
    Local Const $_arrayconstant_lvs_ownerdata = 0x1000
    Local Const $_arrayconstant_lvs_ex_fullrowselect = 0x20
    Local Const $_arrayconstant_lvs_ex_doublebuffer = 0x10000
    Local Const $_arrayconstant_ws_ex_clientedge = 0x200
    Local Const $_arrayconstant_ws_maximizebox = 0x10000
    Local Const $_arrayconstant_ws_minimizebox = 0x20000
    Local Const $_arrayconstant_ws_sizebox = 0x40000
    Local $icoordmode = Opt("GUICoordMode", 0x1)
    Local $iorgwidth = 0xd2, $iheight = 0xc8, $iminsize = 0xfa
    Local $hgui = GUICreate($stitle, $iorgwidth, $iheight, Default, Default, BitOR($_arrayconstant_ws_sizebox, $_arrayconstant_ws_minimizebox, $_arrayconstant_ws_maximizebox))
    Local $aiguisize = WinGetClientSize($hgui)
    Local $idlistview = GUICtrlCreateListView($sheader, 0x0, 0x0, $aiguisize[0x0], $aiguisize[0x1] - $ibuttonborder, BitOR($_arrayconstant_lvs_showselalways, $_arrayconstant_lvs_ownerdata))
    $_g_arraydisplay_hlistview = GUICtrlGetHandle($idlistview)
    GUICtrlSendMsg($idlistview, $_arrayconstant_lvm_setextendedlistviewstyle, $_arrayconstant_lvs_ex_gridlines, $_arrayconstant_lvs_ex_gridlines)
    GUICtrlSendMsg($idlistview, $_arrayconstant_lvm_setextendedlistviewstyle, $_arrayconstant_lvs_ex_fullrowselect, $_arrayconstant_lvs_ex_fullrowselect)
    GUICtrlSendMsg($idlistview, $_arrayconstant_lvm_setextendedlistviewstyle, $_arrayconstant_lvs_ex_doublebuffer, $_arrayconstant_lvs_ex_doublebuffer)
    GUICtrlSendMsg($idlistview, $_arrayconstant_lvm_setextendedlistviewstyle, $_arrayconstant_ws_ex_clientedge, $_arrayconstant_ws_ex_clientedge)
    Local $hheader = HWnd(GUICtrlSendMsg($idlistview, (0x1000 + 0x1f), 0x0, 0x0))
    GUICtrlSetResizing($idlistview, $_arrayconstant_gui_dockborders)
    Local $icolfill = $_g_arraydisplay_ncols + $_g_arraydisplay_idisplayrow
    If $icolalign Then
        For $i = 0x0 To $icolfill + 0xffffffff
            __ARRAYDISPLAY_JUSTIFYCOLUMN($idlistview, $i, $icolalign / 0x2)
        Next
    EndIf
    GUICtrlSendMsg($idlistview, (0x1000 + 0x2f), $_g_arraydisplay_nrows, 0x0)
    Local $trect = DllStructCreate("struct; long Left;long Top;long Right;long Bottom; endstruct")
    DllCall("user32.dll", "struct*", "SendMessageW", "hwnd", $_g_arraydisplay_hlistview, "uint", $_arrayconstant_lvm_getitemrect, "wparam", 0x0, "struct*", $trect)
    Local $aiwin_pos = WinGetPos($hgui)
    Local $ailv_pos = ControlGetPos($hgui, "", $idlistview)
    $iheight = (($_g_arraydisplay_nrows + 0x3) * (DllStructGetData($trect, "Bottom") - DllStructGetData($trect, "Top"))) + $aiwin_pos[0x3] - $ailv_pos[0x3]
    If $iheight > @DesktopHeight + 0xffffff9c Then
        $iheight = @DesktopHeight + 0xffffff9c
    ElseIf $iheight < $iminsize Then
        $iheight = $iminsize
    EndIf
    If $iverbose Then SplashOff()
    $_g_arraydisplay_isortdir = 0x400
    Local $icolumn = 0x0, $icolumnprev = +0xffffffff
    If $_g_arraydisplay_idisplayrow Then
        $icolumnprev = $icolumn
        __ARRAYDISPLAY_HEADERSETITEMFORMAT($hheader, $icolumn, 0x4000 + $_g_arraydisplay_isortdir + $icolalign / 0x2)
    EndIf
    $_g_arraydisplay_aindex = $_g_arraydisplay_aindexes[0x0]
    #endregion GUI and Listview generation
    Local $p__arraydisplay_notifyhandler = DllCallbackGetPtr(DllCallbackRegister("__ArrayDisplay_NotifyHandler", "lresult", "hwnd;uint;wparam;lparam;uint_ptr;dword_ptr"))
    DllCall("comctl32.dll", "bool", "SetWindowSubclass", "hwnd", $hgui, "ptr", $p__arraydisplay_notifyhandler, "uint_ptr", 0x0, "dword_ptr", 0x0)
    #region Adjust dialog width
    Local $iwidth = 0x28, $icolwidth = 0x0, $aicolwidth[$icolfill], $imin_colwidth = 0x37
    Local $icolwidthheader
    For $i = 0x0 To $icolfill + 0xffffffff
        GUICtrlSendMsg($idlistview, (0x1000 + 0x1e), $i, +0xffffffff)
        $icolwidth = GUICtrlSendMsg($idlistview, (0x1000 + 0x1d), $i, 0x0)
        If $sheader <> "" Then
            If $icolwidth = 0x0 Then ExitLoop
            GUICtrlSendMsg($idlistview, (0x1000 + 0x1e), $i, +0xfffffffe)
            $icolwidthheader = GUICtrlSendMsg($idlistview, (0x1000 + 0x1d), $i, 0x0)
            If $icolwidth < $imin_colwidth And $icolwidthheader < $imin_colwidth Then
                GUICtrlSendMsg($idlistview, (0x1000 + 0x1e), $i, $imin_colwidth)
                $icolwidth = $imin_colwidth
            ElseIf $icolwidthheader < $icolwidth Then
                GUICtrlSendMsg($idlistview, (0x1000 + 0x1e), $i, $icolwidth)
            Else
                $icolwidth = $icolwidthheader
            EndIf
        Else
            If $icolwidth < $imin_colwidth Then
                GUICtrlSendMsg($idlistview, (0x1000 + 0x1e), $i, $imin_colwidth)
                $icolwidth = $imin_colwidth
            EndIf
        EndIf
        $iwidth += $icolwidth
        $aicolwidth[$i] = $icolwidth
    Next
    If $iwidth > @DesktopWidth + 0xffffff9c Then
        $iwidth = 0x28
        For $i = 0x0 To $icolfill + 0xffffffff
            If $aicolwidth[$i] > $imax_colwidth Then
                GUICtrlSendMsg($idlistview, (0x1000 + 0x1e), $i, $imax_colwidth)
                $iwidth += $imax_colwidth
            Else
                $iwidth += $aicolwidth[$i]
            EndIf
            If $i < 0x14 And $bdebug Then ConsoleWrite("@@ Debug(" & @ScriptLineNumber & ") : $iWidth = " & $iwidth & " $i = " & $i & @CRLF)
        Next
    EndIf
    If $iwidth > @DesktopWidth + 0xffffff9c Then
        $iwidth = @DesktopWidth + 0xffffff9c
    ElseIf $iwidth < $iminsize Then
        $iwidth = $iminsize
    EndIf
    #endregion Adjust dialog width
    Local $iscrollbarsize = 0x0
    If $iheight = (@DesktopHeight + 0xffffff9c) Then $iscrollbarsize = 0xf
    WinMove($hgui, "", (@DesktopWidth - $iwidth + $iscrollbarsize) / 0x2, (@DesktopHeight - $iheight) / 0x2, $iwidth + $iscrollbarsize, $iheight)
    $aiguisize = WinGetClientSize($hgui)
    GUICtrlSetPos($idlistview, 0x0, 0x0, $iwidth, $aiguisize[0x1] - $ibuttonborder)
    #region Create bottom infos
    Local $ibuttonwidth_1 = $aiguisize[0x0] / 0x2
    Local $ibuttonwidth_2 = $aiguisize[0x0] / 0x3
    Local $idcopy_id = 0x270f, $idcopy_data = 0x1869f, $iddata_label = 0x1869f, $iduser_func = 0x1869f, $idexit_script = 0x1869f
    If $bdebug Then
        $idcopy_id = GUICtrlCreateButton("Copy Data && Hdr/Row", 0x0, $aiguisize[0x1] - $ibuttonborder, $ibuttonwidth_1, 0x14)
        $idcopy_data = GUICtrlCreateButton("Copy Data Only", $ibuttonwidth_1, $aiguisize[0x1] - $ibuttonborder, $ibuttonwidth_1, 0x14)
        Local $ibuttonwidth_var = $ibuttonwidth_1
        Local $ioffset = $ibuttonwidth_1
        If ISFUNC($huser_function) Then
            $iduser_func = GUICtrlCreateButton("Run User Func", $ibuttonwidth_2, $aiguisize[0x1] + 0xffffffec, $ibuttonwidth_2, 0x14)
            $ibuttonwidth_var = $ibuttonwidth_2
            $ioffset = $ibuttonwidth_2 * 0x2
        EndIf
        $idexit_script = GUICtrlCreateButton("Exit Script", $ioffset, $aiguisize[0x1] + 0xffffffec, $ibuttonwidth_var, 0x14)
        $iddata_label = GUICtrlCreateLabel($sdisplaydata, 0x0, $aiguisize[0x1] + 0xffffffec, $ibuttonwidth_var, 0x12, BitOR($_arrayconstant_ss_center, $_arrayconstant_ss_centerimage))
    Else
        $iddata_label = GUICtrlCreateLabel($sdisplaydata, 0x0, $aiguisize[0x1] + 0xffffffec, $aiguisize[0x0], 0x12, BitOR($_arrayconstant_ss_center, $_arrayconstant_ss_centerimage))
    EndIf
    If $_g_arraydisplay_itranspose Or $sarrayrange Then
        GUICtrlSetColor($iddata_label, 0xff0000)
        GUICtrlSetTip($iddata_label, $stipdata)
    EndIf
    GUICtrlSetResizing($idcopy_id, $_arrayconstant_gui_dockleft + $_arrayconstant_gui_dockbottom + $_arrayconstant_gui_dockheight)
    GUICtrlSetResizing($idcopy_data, $_arrayconstant_gui_dockright + $_arrayconstant_gui_dockbottom + $_arrayconstant_gui_dockheight)
    GUICtrlSetResizing($iddata_label, $_arrayconstant_gui_dockleft + $_arrayconstant_gui_dockbottom + $_arrayconstant_gui_dockheight)
    GUICtrlSetResizing($iduser_func, $_arrayconstant_gui_dockhcenter + $_arrayconstant_gui_dockbottom + $_arrayconstant_gui_dockheight)
    GUICtrlSetResizing($idexit_script, $_arrayconstant_gui_dockright + $_arrayconstant_gui_dockbottom + $_arrayconstant_gui_dockheight)
    #endregion Create bottom infos
    GUISetState(@SW_SHOW, $hgui)
    If $ftimer > 0x3e8 And Not $sarrayrange Then
        Beep(0x2ee, 0xfa)
        ToolTip("Sorting Action can take as long as " & Ceiling($ftimer / 0x3e8) & " sec" & @CRLF & @CRLF & "Please be patient when you click to sort a column", 0x32, 0x32, $smsgboxtitle, $tip_warningicon, $tip_balloon)
        Sleep(0xbb8)
        ToolTip("")
    EndIf
    #region GUI Handling events
    Local $ioneventmode = Opt("GUIOnEventMode", 0x0), $amsg
    While 0x1
        $amsg = GUIGetMsg($_arrayconstant_gui_event_array)
        If $amsg[0x1] = $hgui Then
            Switch $amsg[0x0]
                Case $_arrayconstant_gui_event_close
                    ExitLoop
                Case $idcopy_id, $idcopy_data
                    Local $isel_count = GUICtrlSendMsg($idlistview, $_arrayconstant_lvm_getselectedcount, 0x0, 0x0)
                    If $iverbose And (Not $isel_count) And ($_g_arraydisplay_iitem_end - $_g_arraydisplay_iitem_start) * ($_g_arraydisplay_isubitem_end - $_g_arraydisplay_isubitem_start) > 0x2710 Then
                        SplashTextOn($smsgboxtitle, "Copying data" & @CRLF & @CRLF & "Please be patient", 0x12c, 0x64)
                    EndIf
                    Local $sclip = "", $sitem, $asplit, $ifirstcol = 0x0
                    If $amsg[0x0] = $idcopy_data And $_g_arraydisplay_idisplayrow Then $ifirstcol = 0x1
                    For $i = 0x0 To GUICtrlSendMsg($idlistview, 0x1004, 0x0, 0x0) + 0xffffffff
                        If $isel_count And Not (GUICtrlSendMsg($idlistview, $_arrayconstant_lvm_getitemstate, $i, $_arrayconstant_lvis_selected) <> 0x0) Then
                            ContinueLoop
                        EndIf
                        $sitem = __ARRAYDISPLAY_GETITEMTEXTSTRINGSELECTED($idlistview, $i, $ifirstcol)
                        If $amsg[0x0] = $idcopy_id And Not $_g_arraydisplay_idisplayrow Then
                            $sitem = $arraydisplay_rowprefix & " " & ($i + $_g_arraydisplay_iitem_start) & $scurr_separator & $sitem
                        EndIf
                        If $icw_colwidth Then
                            $asplit = StringSplit($sitem, $scurr_separator)
                            $sitem = ""
                            For $j = 0x1 To $asplit[0x0]
                                $sitem &= StringFormat("%-" & $icw_colwidth + 0x1 & "s", StringLeft($asplit[$j], $icw_colwidth))
                            Next
                        Else
                            $sitem = StringReplace($sitem, $scurr_separator, $vuser_separator)
                        EndIf
                        $sclip &= $sitem & @CRLF
                    Next
                    $sitem = $sheader
                    If $amsg[0x0] = $idcopy_id Then
                        $sitem = $sheader
                        If Not $_g_arraydisplay_idisplayrow Then
                            $sitem = "Row" & $scurr_separator & $sitem
                        EndIf
                        If $icw_colwidth Then
                            $asplit = StringSplit($sitem, $scurr_separator)
                            $sitem = ""
                            For $j = 0x1 To $asplit[0x0]
                                $sitem &= StringFormat("%-" & $icw_colwidth + 0x1 & "s", StringLeft($asplit[$j], $icw_colwidth))
                            Next
                        Else
                            $sitem = StringReplace($sitem, $scurr_separator, $vuser_separator)
                        EndIf
                        $sclip = $sitem & @CRLF & $sclip
                    EndIf
                    ClipPut($sclip)
                    SplashOff()
                    GUICtrlSetState($idlistview, $_arrayconstant_gui_focus)
                Case $idlistview
                    $icolumn = GUICtrlGetState($idlistview)
                    If Not IsArray($_g_arraydisplay_aindexes[$icolumn + Not $_g_arraydisplay_idisplayrow]) Then
                        __ARRAYDISPLAY_SORTINDEXES($icolumn + Not $_g_arraydisplay_idisplayrow)
                    EndIf
                    If $icolumn <> $icolumnprev Then
                        __ARRAYDISPLAY_HEADERSETITEMFORMAT($hheader, $icolumnprev, 0x4000 + $icolalign / 0x2)
                        If $_g_arraydisplay_idisplayrow And $icolumn = 0x0 Then
                            $_g_arraydisplay_aindex = $_g_arraydisplay_aindexes[0x0]
                        Else
                            $_g_arraydisplay_aindex = $_g_arraydisplay_aindexes[$icolumn + Not $_g_arraydisplay_idisplayrow]
                        EndIf
                    EndIf
                    $_g_arraydisplay_isortdir = ($icolumn = $icolumnprev) ? $_g_arraydisplay_isortdir = 0x400 ? 0x200 : 0x400 : 0x400
                    __ARRAYDISPLAY_HEADERSETITEMFORMAT($hheader, $icolumn, 0x4000 + $_g_arraydisplay_isortdir + $icolalign / 0x2)
                    GUICtrlSendMsg($idlistview, (0x1000 + 0x8c), $icolumn, 0x0)
                    GUICtrlSendMsg($idlistview, (0x1000 + 0x2f), $_g_arraydisplay_nrows, 0x0)
                    $icolumnprev = $icolumn
                Case $iduser_func
                    Local $aiselitems[0x1] = [0x0]
                    For $i = 0x0 To GUICtrlSendMsg($idlistview, 0x1004, 0x0, 0x0) + 0xffffffff
                        If (GUICtrlSendMsg($idlistview, $_arrayconstant_lvm_getitemstate, $i, $_arrayconstant_lvis_selected) <> 0x0) Then
                            $aiselitems[0x0] += 0x1
                            ReDim $aiselitems[$aiselitems[0x0] + 0x1]
                            $aiselitems[$aiselitems[0x0]] = $i + $_g_arraydisplay_iitem_start
                        EndIf
                    Next
                    $HUSER_FUNCTION($_g_arraydisplay_aarray, $aiselitems)
                    GUICtrlSetState($idlistview, $_arrayconstant_gui_focus)
                Case $idexit_script
                    GUIDelete($hgui)
                    Exit
            EndSwitch
        EndIf
    WEnd
    #endregion GUI Handling events
    DllCall("comctl32.dll", "bool", "RemoveWindowSubclass", "hwnd", $hgui, "ptr", $p__arraydisplay_notifyhandler, "uint_ptr", 0x0)
    $_g_arraydisplay_aindex = 0x0
    Dim $_g_arraydisplay_aindexes[0x1]
    GUIDelete($hgui)
    Opt("GUICoordMode", $icoordmode)
    Opt("GUIOnEventMode", $ioneventmode)
    Return SetError($_icallererror, $_icallerextended, 0x1)
EndFunc   ;==>__ARRAYDISPLAY_SHARE
Func __ARRAYDISPLAY_NOTIFYHANDLER($hwnd, $imsg, $wparam, $lparam, $isubclassid, $pdata)
    If $imsg <> 0x4e Then Return DllCall("comctl32.dll", "lresult", "DefSubclassProc", "hwnd", $hwnd, "uint", $imsg, "wparam", $wparam, "lparam", $lparam)[0x0]
    Local Static $tagnmhdr = "struct;hwnd hWndFrom;uint_ptr IDFrom;INT Code;endstruct"
    Local Static $tagnmlvdispinfo = $tagnmhdr & ";" & $_arrayconstant_taglvitem
    Local $tnmlvdispinfo = DllStructCreate($tagnmlvdispinfo, $lparam)
    Switch HWnd(DllStructGetData($tnmlvdispinfo, "hWndFrom"))
        Case $_g_arraydisplay_hlistview
            Switch DllStructGetData($tnmlvdispinfo, "Code")
                Case +0xffffff4f
                    Local Static $ttext = DllStructCreate("wchar[4096]"), $ptext = DllStructGetPtr($ttext)
                    Local $iitem = DllStructGetData($tnmlvdispinfo, "Item")
                    Local $irow = ($_g_arraydisplay_isortdir = 0x400) ? $_g_arraydisplay_aindex[$iitem] : $_g_arraydisplay_aindex[$_g_arraydisplay_nrows + 0xffffffff - $iitem]
                    Local $icol = DllStructGetData($tnmlvdispinfo, "SubItem")
                    Local $stemp
                    If $_g_arraydisplay_idisplayrow = 0x0 Then
                        If $_g_arraydisplay_idims = 0x2 Then
                            $stemp = $_g_arraydisplay_aarray[$irow][$icol]
                        Else
                            $stemp = $_g_arraydisplay_aarray[$irow]
                        EndIf
                        Switch VarGetType($stemp)
                            Case "Array"
                                $stemp = "{Array}"
                            Case "Map"
                                $stemp = "{Map}"
                        EndSwitch
                        If StringLen($stemp) > 0xfff Then $stemp = StringLeft($stemp, 0xfff)
                        DllStructSetData($ttext, 0x1, $stemp)
                        DllStructSetData($tnmlvdispinfo, "Text", $ptext)
                    Else
                        If $icol = 0x0 Then
                            If $_g_arraydisplay_itranspose Then
                                Local $scaptioncplt = ""
                                If $irow + $_g_arraydisplay_iitem_start < UBound($_g_arraydisplay_asheader) And StringStripWS($_g_arraydisplay_asheader[$irow + $_g_arraydisplay_iitem_start], 0x1 + 0x2) <> "" Then
                                    $scaptioncplt = " (" & StringStripWS($_g_arraydisplay_asheader[$irow + $_g_arraydisplay_iitem_start], 0x1 + 0x2)
                                    If StringRight($scaptioncplt, 0x1) = $arraydisplay_numericsort Then $scaptioncplt = StringTrimRight($scaptioncplt, 0x1)
                                    $scaptioncplt &= ")"
                                EndIf
                                DllStructSetData($ttext, 0x1, "Col " & ($irow + $_g_arraydisplay_iitem_start) & $scaptioncplt)
                            Else
                                DllStructSetData($ttext, 0x1, $arraydisplay_rowprefix & " " & $irow + $_g_arraydisplay_iitem_start)
                            EndIf
                            DllStructSetData($tnmlvdispinfo, "Text", $ptext)
                        Else
                            If $_g_arraydisplay_idims = 0x2 Then
                                $stemp = $_g_arraydisplay_aarray[$irow][$icol + 0xffffffff]
                            Else
                                $stemp = $_g_arraydisplay_aarray[$irow]
                            EndIf
                            Switch VarGetType($stemp)
                                Case "Array"
                                    $stemp = "{Array}"
                                Case "Map"
                                    $stemp = "{Map}"
                            EndSwitch
                            If StringLen($stemp) > 0xfff Then $stemp = StringLeft($stemp, 0xfff)
                            DllStructSetData($ttext, 0x1, $stemp)
                            DllStructSetData($tnmlvdispinfo, "Text", $ptext)
                        EndIf
                    EndIf
                    Return
            EndSwitch
    EndSwitch
    Return DllCall("comctl32.dll", "lresult", "DefSubclassProc", "hwnd", $hwnd, "uint", $imsg, "wparam", $wparam, "lparam", $lparam)[0x0]
    #forceref $isubclassid, $pdata
EndFunc   ;==>__ARRAYDISPLAY_NOTIFYHANDLER
Func __ARRAYDISPLAY_SORTINDEXES($icolstart, $icolend = $icolstart)
    Dim $_g_arraydisplay_aindex[$_g_arraydisplay_nrows]
    If $icolend = +0xffffffff Then
        Dim $_g_arraydisplay_aindexes[$_g_arraydisplay_ncols + $_g_arraydisplay_idisplayrow + 0x1]
        For $i = 0x0 To $_g_arraydisplay_nrows + 0xffffffff
            $_g_arraydisplay_aindex[$i] = $i
        Next
        $_g_arraydisplay_aindexes[0x0] = $_g_arraydisplay_aindex
    EndIf
    If $icolstart = +0xffffffff Then
        $icolstart = 0x1
        $icolend = $_g_arraydisplay_ncols
    EndIf
    If $icolstart Then
        Local $tindex
        For $i = $icolstart To $icolend
            $tindex = __ARRAYDISPLAY_GETSORTCOLSTRUCT($_g_arraydisplay_aarray, $i + 0xffffffff)
            For $j = 0x0 To $_g_arraydisplay_nrows + 0xffffffff
                $_g_arraydisplay_aindex[$j] = DllStructGetData($tindex, 0x1, $j + 0x1)
            Next
            $_g_arraydisplay_aindexes[$i] = $_g_arraydisplay_aindex
        Next
    EndIf
EndFunc   ;==>__ARRAYDISPLAY_SORTINDEXES
Func __ARRAYDISPLAY_GETSORTCOLSTRUCT(Const ByRef $aarray, $icol)
    If UBound($aarray, $ubound_dimensions) < 0x1 Or UBound($aarray, $ubound_dimensions) > 0x2 Then
        Return SetError(0x6, 0x0, 0x0)
    EndIf
    Return __ARRAYDISPLAY_SORTARRAYSTRUCT($aarray, $icol)
EndFunc   ;==>__ARRAYDISPLAY_GETSORTCOLSTRUCT
Func __ARRAYDISPLAY_SORTARRAYSTRUCT(Const ByRef $aarray, $icol)
    Local $idims = UBound($aarray, $ubound_dimensions)
    Local $tindex = DllStructCreate("uint[" & $_g_arraydisplay_nrows & "]")
    Local $pindex = DllStructGetPtr($tindex)
    Static $hdll = DllOpen("kernel32.dll")
    Static $hdllcomp = DllOpen("shlwapi.dll")
    Local $lo, $hi, $mi, $r, $nval1, $nval2
    For $i = 0x1 To $_g_arraydisplay_nrows + 0xffffffff
        $lo = 0x0
        $hi = $i + 0xffffffff
        Do
            $mi = Int(($lo + $hi) / 0x2)
            If Not $_g_arraydisplay_itranspose And $_g_arraydisplay_anumericsort[$icol] Then
                If $idims = 0x1 Then
                    $nval1 = Number($aarray[$i])
                    $nval2 = Number($aarray[DllStructGetData($tindex, 0x1, $mi + 0x1)])
                Else
                    $nval1 = Number($aarray[$i][$icol])
                    $nval2 = Number($aarray[DllStructGetData($tindex, 0x1, $mi + 0x1)][$icol])
                EndIf
                $r = $nval1 < $nval2 ? +0xffffffff : $nval1 > $nval2 ? 0x1 : 0x0
            Else
                If $idims = 0x1 Then
                    $r = DllCall($hdllcomp, "int", "StrCmpLogicalW", "wstr", $aarray[$i], "wstr", $aarray[DllStructGetData($tindex, 0x1, $mi + 0x1)])[0x0]
                Else
                    $r = DllCall($hdllcomp, "int", "StrCmpLogicalW", "wstr", $aarray[$i][$icol], "wstr", $aarray[DllStructGetData($tindex, 0x1, $mi + 0x1)][$icol])[0x0]
                EndIf
            EndIf
            Switch $r
                Case +0xffffffff
                    $hi = $mi + 0xffffffff
                Case 0x1
                    $lo = $mi + 0x1
                Case 0x0
                    ExitLoop
            EndSwitch
        Until $lo > $hi
        DllCall($hdll, "none", "RtlMoveMemory", "struct*", $pindex + ($mi + 0x1) * 0x4, "struct*", $pindex + $mi * 0x4, "ulong_ptr", ($i - $mi) * 0x4)
        DllStructSetData($tindex, 0x1, $i, $mi + 0x1 + ($lo = $mi + 0x1))
    Next
    Return $tindex
EndFunc   ;==>__ARRAYDISPLAY_SORTARRAYSTRUCT
Func __ARRAYDISPLAY_CREATESUBARRAY()
    Local $nrows = $_g_arraydisplay_iitem_end - $_g_arraydisplay_iitem_start + 0x1
    Local $ncols = $_g_arraydisplay_isubitem_end - $_g_arraydisplay_isubitem_start + 0x1
    Local $irow = +0xffffffff, $icol, $itemp, $atemp
    If $_g_arraydisplay_itranspose Then
        Dim $atemp[$ncols][$nrows]
        For $i = $_g_arraydisplay_iitem_start To $_g_arraydisplay_iitem_end
            $irow += 0x1
            $icol = +0xffffffff
            For $j = $_g_arraydisplay_isubitem_start To $_g_arraydisplay_isubitem_end
                $icol += 0x1
                $atemp[$icol][$irow] = $_g_arraydisplay_aarray[$i][$j]
            Next
        Next
        $itemp = $_g_arraydisplay_iitem_start
        $_g_arraydisplay_iitem_start = $_g_arraydisplay_isubitem_start
        $_g_arraydisplay_isubitem_start = $itemp
        $itemp = $_g_arraydisplay_iitem_end
        $_g_arraydisplay_iitem_end = $_g_arraydisplay_isubitem_end
        $_g_arraydisplay_isubitem_end = $itemp
        $_g_arraydisplay_nrows = $ncols
        $_g_arraydisplay_ncols = $nrows
    Else
        If $_g_arraydisplay_idims = 0x1 Then
            Dim $atemp[$nrows]
            For $i = $_g_arraydisplay_iitem_start To $_g_arraydisplay_iitem_end
                $irow += 0x1
                $atemp[$irow] = $_g_arraydisplay_aarray[$i]
            Next
        Else
            Dim $atemp[$nrows][$ncols]
            For $i = $_g_arraydisplay_iitem_start To $_g_arraydisplay_iitem_end
                $irow += 0x1
                $icol = +0xffffffff
                For $j = $_g_arraydisplay_isubitem_start To $_g_arraydisplay_isubitem_end
                    $icol += 0x1
                    $atemp[$irow][$icol] = $_g_arraydisplay_aarray[$i][$j]
                Next
            Next
            $_g_arraydisplay_ncols = $ncols
        EndIf
        $_g_arraydisplay_nrows = $nrows
    EndIf
    Return $atemp
EndFunc   ;==>__ARRAYDISPLAY_CREATESUBARRAY
Func __ARRAYDISPLAY_HEADERSETITEMFORMAT($hwnd, $iindex, $iformat)
    Local Static $thditem = DllStructCreate("uint Mask;int XY;ptr Text;handle hBMP;int TextMax;int Fmt;lparam Param;int Image;int Order;uint Type;ptr pFilter;uint State")
    DllStructSetData($thditem, "Mask", 0x4)
    DllStructSetData($thditem, "Fmt", $iformat)
    Local $aresult = DllCall("user32.dll", "lresult", "SendMessageW", "hwnd", $hwnd, "uint", 0x120c, "wparam", $iindex, "struct*", $thditem)
    Return $aresult[0x0] <> 0x0
EndFunc   ;==>__ARRAYDISPLAY_HEADERSETITEMFORMAT
Func __ARRAYDISPLAY_GETITEMTEXT($idlistview, $iindex, $isubitem = 0x0)
    Local $tbuffer = DllStructCreate("wchar Text[4096]")
    Local $pbuffer = DllStructGetPtr($tbuffer)
    Local $titem = DllStructCreate($_arrayconstant_taglvitem)
    DllStructSetData($titem, "SubItem", $isubitem)
    DllStructSetData($titem, "TextMax", 0x1000)
    DllStructSetData($titem, "Text", $pbuffer)
    If IsHWnd($idlistview) Then
        DllCall("user32.dll", "lresult", "SendMessageW", "hwnd", $idlistview, "uint", 0x1073, "wparam", $iindex, "struct*", $titem)
    Else
        Local $pitem = DllStructGetPtr($titem)
        GUICtrlSendMsg($idlistview, 0x1073, $iindex, $pitem)
    EndIf
    Return DllStructGetData($tbuffer, "Text")
EndFunc   ;==>__ARRAYDISPLAY_GETITEMTEXT
Func __ARRAYDISPLAY_GETITEMTEXTSTRINGSELECTED($idlistview, $iitem, $ifirstcol)
    Local $srow = "", $sseparatorchar = Opt("GUIDataSeparatorChar")
    Local $iselected = $iitem
    Local $hheader = HWnd(GUICtrlSendMsg($idlistview, 0x101f, 0x0, 0x0))
    Local $ncol = DllCall("user32.dll", "lresult", "SendMessageW", "hwnd", $hheader, "uint", 0x1200, "wparam", 0x0, "lparam", 0x0)[0x0]
    For $x = $ifirstcol To $ncol + 0xffffffff
        $srow &= __ARRAYDISPLAY_GETITEMTEXT($idlistview, $iselected, $x) & $sseparatorchar
    Next
    Return StringTrimRight($srow, 0x1)
EndFunc   ;==>__ARRAYDISPLAY_GETITEMTEXTSTRINGSELECTED
Func __ARRAYDISPLAY_JUSTIFYCOLUMN($idlistview, $iindex, $ialign = +0xffffffff)
    Local $tcolumn = DllStructCreate("uint Mask;int Fmt;int CX;ptr Text;int TextMax;int SubItem;int Image;int Order;int cxMin;int cxDefault;int cxIdeal")
    If $ialign < 0x0 Or $ialign > 0x2 Then $ialign = 0x0
    DllStructSetData($tcolumn, "Mask", 0x1)
    DllStructSetData($tcolumn, "Fmt", $ialign)
    Local $pcolumn = DllStructGetPtr($tcolumn)
    Local $iret = GUICtrlSendMsg($idlistview, 0x1060, $iindex, $pcolumn)
    Return $iret <> 0x0
EndFunc   ;==>__ARRAYDISPLAY_JUSTIFYCOLUMN
Global Enum $arrayfill_force_default, $arrayfill_force_singleitem, $arrayfill_force_int, $arrayfill_force_number, $arrayfill_force_ptr, $arrayfill_force_hwnd, $arrayfill_force_string, $arrayfill_force_boolean
Global Enum $arrayunique_nocount, $arrayunique_count
Global Enum $arrayunique_auto, $arrayunique_force32, $arrayunique_force64, $arrayunique_match, $arrayunique_distinct
Func _ArrayAdd(ByRef $aarray, $vvalue, $istart = 0x0, $sdelim_item = "|", $sdelim_row = @CRLF, $iforce = $arrayfill_force_default)
    If $istart = Default Then $istart = 0x0
    If $sdelim_item = Default Then $sdelim_item = "|"
    If $sdelim_row = Default Then $sdelim_row = @CRLF
    If $iforce = Default Then $iforce = $arrayfill_force_default
    If Not IsArray($aarray) Then Return SetError(0x1, 0x0, +0xffffffff)
    Local $idim_1 = UBound($aarray, $ubound_rows)
    Local $hdatatype = 0x0
    Switch $iforce
        Case $arrayfill_force_int
            $hdatatype = INT
        Case $arrayfill_force_number
            $hdatatype = NUMBER
        Case $arrayfill_force_ptr
            $hdatatype = PTR
        Case $arrayfill_force_hwnd
            $hdatatype = HWND
        Case $arrayfill_force_string
            $hdatatype = STRING
        Case $arrayfill_force_boolean
            $hdatatype = "Boolean"
    EndSwitch
    Switch UBound($aarray, $ubound_dimensions)
        Case 0x1
            If $iforce = $arrayfill_force_singleitem Then
                ReDim $aarray[$idim_1 + 0x1]
                $aarray[$idim_1] = $vvalue
                Return $idim_1
            EndIf
            If IsArray($vvalue) Then
                If UBound($vvalue, $ubound_dimensions) <> 0x1 Then Return SetError(0x5, 0x0, +0xffffffff)
                $hdatatype = 0x0
            Else
                Local $atmp = StringSplit($vvalue, $sdelim_item, $str_nocount + $str_entiresplit)
                If UBound($atmp, $ubound_rows) = 0x1 Then
                    $atmp[0x0] = $vvalue
                EndIf
                $vvalue = $atmp
            EndIf
            Local $iadd = UBound($vvalue, $ubound_rows)
            ReDim $aarray[$idim_1 + $iadd]
            For $i = 0x0 To $iadd + 0xffffffff
                If String($hdatatype) = "Boolean" Then
                    Switch $vvalue[$i]
                        Case "True", "1"
                            $aarray[$idim_1 + $i] = True
                        Case "False", "0", ""
                            $aarray[$idim_1 + $i] = False
                    EndSwitch
                ElseIf ISFUNC($hdatatype) Then
                    $aarray[$idim_1 + $i] = $HDATATYPE($vvalue[$i])
                Else
                    $aarray[$idim_1 + $i] = $vvalue[$i]
                EndIf
            Next
            Return $idim_1 + $iadd + 0xffffffff
        Case 0x2
            Local $idim_2 = UBound($aarray, $ubound_columns)
            If $istart < 0x0 Or $istart > $idim_2 + 0xffffffff Then Return SetError(0x4, 0x0, +0xffffffff)
            Local $ivaldim_1, $ivaldim_2 = 0x0, $icolcount
            If IsArray($vvalue) Then
                If UBound($vvalue, $ubound_dimensions) <> 0x2 Then Return SetError(0x5, 0x0, +0xffffffff)
                $ivaldim_1 = UBound($vvalue, $ubound_rows)
                $ivaldim_2 = UBound($vvalue, $ubound_columns)
                $hdatatype = 0x0
            Else
                Local $asplit_1 = StringSplit($vvalue, $sdelim_row, $str_nocount + $str_entiresplit)
                $ivaldim_1 = UBound($asplit_1, $ubound_rows)
                Local $atmp[$ivaldim_1][0x0], $asplit_2
                For $i = 0x0 To $ivaldim_1 + 0xffffffff
                    $asplit_2 = StringSplit($asplit_1[$i], $sdelim_item, $str_nocount + $str_entiresplit)
                    $icolcount = UBound($asplit_2)
                    If $icolcount > $ivaldim_2 Then
                        $ivaldim_2 = $icolcount
                        ReDim $atmp[$ivaldim_1][$ivaldim_2]
                    EndIf
                    For $j = 0x0 To $icolcount + 0xffffffff
                        $atmp[$i][$j] = $asplit_2[$j]
                    Next
                Next
                $vvalue = $atmp
            EndIf
            If UBound($vvalue, $ubound_columns) + $istart > UBound($aarray, $ubound_columns) Then Return SetError(0x3, 0x0, +0xffffffff)
            ReDim $aarray[$idim_1 + $ivaldim_1][$idim_2]
            For $iwriteto_index = 0x0 To $ivaldim_1 + 0xffffffff
                For $j = 0x0 To $idim_2 + 0xffffffff
                    If $j < $istart Then
                        $aarray[$iwriteto_index + $idim_1][$j] = ""
                    ElseIf $j - $istart > $ivaldim_2 + 0xffffffff Then
                        $aarray[$iwriteto_index + $idim_1][$j] = ""
                    Else
                        If String($hdatatype) = "Boolean" Then
                            Switch $vvalue[$iwriteto_index][$j - $istart]
                                Case "True", "1"
                                    $aarray[$iwriteto_index + $idim_1][$j] = True
                                Case "False", "0", ""
                                    $aarray[$iwriteto_index + $idim_1][$j] = False
                            EndSwitch
                        ElseIf ISFUNC($hdatatype) Then
                            $aarray[$iwriteto_index + $idim_1][$j] = $HDATATYPE($vvalue[$iwriteto_index][$j - $istart])
                        Else
                            $aarray[$iwriteto_index + $idim_1][$j] = $vvalue[$iwriteto_index][$j - $istart]
                        EndIf
                    EndIf
                Next
            Next
        Case Else
            Return SetError(0x2, 0x0, +0xffffffff)
    EndSwitch
    Return UBound($aarray, $ubound_rows) + 0xffffffff
EndFunc   ;==>_ARRAYADD
Func _ArrayBinarySearch(Const ByRef $aarray, $vvalue, $istart = 0x0, $iend = 0x0, $icolumn = 0x0)
    If $istart = Default Then $istart = 0x0
    If $iend = Default Then $iend = 0x0
    If $icolumn = Default Then $icolumn = 0x0
    If Not IsArray($aarray) Then Return SetError(0x1, 0x0, +0xffffffff)
    Local $idim_1 = UBound($aarray, $ubound_rows)
    If $idim_1 = 0x0 Then Return SetError(0x6, 0x0, +0xffffffff)
    If $iend < 0x1 Or $iend > $idim_1 + 0xffffffff Then $iend = $idim_1 + 0xffffffff
    If $istart < 0x0 Then $istart = 0x0
    If $istart > $iend Then Return SetError(0x4, 0x0, +0xffffffff)
    Local $imid = Int(($iend + $istart) / 0x2)
    Switch UBound($aarray, $ubound_dimensions)
        Case 0x1
            If $aarray[$istart] > $vvalue Or $aarray[$iend] < $vvalue Then Return SetError(0x2, 0x0, +0xffffffff)
            While $istart <= $imid And $vvalue <> $aarray[$imid]
                If $vvalue < $aarray[$imid] Then
                    $iend = $imid + 0xffffffff
                Else
                    $istart = $imid + 0x1
                EndIf
                $imid = Int(($iend + $istart) / 0x2)
            WEnd
            If $istart > $iend Then Return SetError(0x3, 0x0, +0xffffffff)
        Case 0x2
            Local $idim_2 = UBound($aarray, $ubound_columns) + 0xffffffff
            If $icolumn < 0x0 Or $icolumn > $idim_2 Then Return SetError(0x7, 0x0, +0xffffffff)
            If $aarray[$istart][$icolumn] > $vvalue Or $aarray[$iend][$icolumn] < $vvalue Then Return SetError(0x2, 0x0, +0xffffffff)
            While $istart <= $imid And $vvalue <> $aarray[$imid][$icolumn]
                If $vvalue < $aarray[$imid][$icolumn] Then
                    $iend = $imid + 0xffffffff
                Else
                    $istart = $imid + 0x1
                EndIf
                $imid = Int(($iend + $istart) / 0x2)
            WEnd
            If $istart > $iend Then Return SetError(0x3, 0x0, +0xffffffff)
        Case Else
            Return SetError(0x5, 0x0, +0xffffffff)
    EndSwitch
    Return $imid
EndFunc   ;==>_ARRAYBINARYSEARCH
Func _ARRAYCOLDELETE(ByRef $aarray, $icolumn, $bconvert = False)
    If $bconvert = Default Then $bconvert = False
    If Not IsArray($aarray) Then Return SetError(0x1, 0x0, +0xffffffff)
    Local $idim_1 = UBound($aarray, $ubound_rows)
    If UBound($aarray, $ubound_dimensions) <> 0x2 Then Return SetError(0x2, 0x0, +0xffffffff)
    Local $idim_2 = UBound($aarray, $ubound_columns)
    Switch $idim_2
        Case 0x2
            If $icolumn < 0x0 Or $icolumn > 0x1 Then Return SetError(0x3, 0x0, +0xffffffff)
            If $bconvert Then
                Local $atemparray[$idim_1]
                For $i = 0x0 To $idim_1 + 0xffffffff
                    $atemparray[$i] = $aarray[$i][(Not $icolumn)]
                Next
                $aarray = $atemparray
            Else
                ContinueCase
            EndIf
        Case Else
            If $icolumn < 0x0 Or $icolumn > $idim_2 + 0xffffffff Then Return SetError(0x3, 0x0, +0xffffffff)
            For $i = 0x0 To $idim_1 + 0xffffffff
                For $j = $icolumn To $idim_2 + 0xfffffffe
                    $aarray[$i][$j] = $aarray[$i][$j + 0x1]
                Next
            Next
            ReDim $aarray[$idim_1][$idim_2 + 0xffffffff]
    EndSwitch
    Return UBound($aarray, $ubound_columns)
EndFunc   ;==>_ARRAYCOLDELETE
Func _ARRAYCOLINSERT(ByRef $aarray, $icolumn)
    If Not IsArray($aarray) Then Return SetError(0x1, 0x0, +0xffffffff)
    Local $idim_1 = UBound($aarray, $ubound_rows)
    Switch UBound($aarray, $ubound_dimensions)
        Case 0x1
            Local $atemparray[$idim_1][0x2]
            Switch $icolumn
                Case 0x0, 0x1
                    For $i = 0x0 To $idim_1 + 0xffffffff
                        $atemparray[$i][(Not $icolumn)] = $aarray[$i]
                    Next
                Case Else
                    Return SetError(0x3, 0x0, +0xffffffff)
            EndSwitch
            $aarray = $atemparray
        Case 0x2
            Local $idim_2 = UBound($aarray, $ubound_columns)
            If $icolumn < 0x0 Or $icolumn > $idim_2 Then Return SetError(0x3, 0x0, +0xffffffff)
            ReDim $aarray[$idim_1][$idim_2 + 0x1]
            For $i = 0x0 To $idim_1 + 0xffffffff
                For $j = $idim_2 To $icolumn + 0x1 Step +0xffffffff
                    $aarray[$i][$j] = $aarray[$i][$j + 0xffffffff]
                Next
                $aarray[$i][$icolumn] = ""
            Next
        Case Else
            Return SetError(0x2, 0x0, +0xffffffff)
    EndSwitch
    Return UBound($aarray, $ubound_columns)
EndFunc   ;==>_ARRAYCOLINSERT
Func _ArrayCombinations(Const ByRef $aarray, $iset, $sdelimiter = "")
    If $sdelimiter = Default Then $sdelimiter = ""
    If Not IsArray($aarray) Then Return SetError(0x1, 0x0, 0x0)
    If UBound($aarray, $ubound_dimensions) <> 0x1 Then Return SetError(0x2, 0x0, 0x0)
    Local $in = UBound($aarray)
    Local $ir = $iset
    Local $aidx[$ir]
    For $i = 0x0 To $ir + 0xffffffff
        $aidx[$i] = $i
    Next
    Local $itotal = __ARRAY_COMBINATIONS($in, $ir)
    Local $ileft = $itotal
    Local $aresult[$itotal + 0x1]
    $aresult[0x0] = $itotal
    Local $icount = 0x1
    While $ileft > 0x0
        __ARRAY_GETNEXT($in, $ir, $ileft, $itotal, $aidx)
        For $i = 0x0 To $iset + 0xffffffff
            $aresult[$icount] &= $aarray[$aidx[$i]] & $sdelimiter
        Next
        If $sdelimiter <> "" Then $aresult[$icount] = StringTrimRight($aresult[$icount], 0x1)
        $icount += 0x1
    WEnd
    Return $aresult
EndFunc   ;==>_ARRAYCOMBINATIONS
Func _ArrayConcatenate(ByRef $aarraytarget, Const ByRef $aarraysource, $istart = 0x0)
    If $istart = Default Then $istart = 0x0
    If Not IsArray($aarraytarget) Then Return SetError(0x1, 0x0, +0xffffffff)
    If Not IsArray($aarraysource) Then Return SetError(0x2, 0x0, +0xffffffff)
    Local $idim_total_tgt = UBound($aarraytarget, $ubound_dimensions)
    Local $idim_total_src = UBound($aarraysource, $ubound_dimensions)
    Local $idim_1_tgt = UBound($aarraytarget, $ubound_rows)
    Local $idim_1_src = UBound($aarraysource, $ubound_rows)
    If $istart < 0x0 Or $istart > $idim_1_src + 0xffffffff Then Return SetError(0x6, 0x0, +0xffffffff)
    Switch $idim_total_tgt
        Case 0x1
            If $idim_total_src <> 0x1 Then Return SetError(0x4, 0x0, +0xffffffff)
            ReDim $aarraytarget[$idim_1_tgt + $idim_1_src - $istart]
            For $i = $istart To $idim_1_src + 0xffffffff
                $aarraytarget[$idim_1_tgt + $i - $istart] = $aarraysource[$i]
            Next
        Case 0x2
            If $idim_total_src <> 0x2 Then Return SetError(0x4, 0x0, +0xffffffff)
            Local $idim_2_tgt = UBound($aarraytarget, $ubound_columns)
            If UBound($aarraysource, $ubound_columns) <> $idim_2_tgt Then Return SetError(0x5, 0x0, +0xffffffff)
            ReDim $aarraytarget[$idim_1_tgt + $idim_1_src - $istart][$idim_2_tgt]
            For $i = $istart To $idim_1_src + 0xffffffff
                For $j = 0x0 To $idim_2_tgt + 0xffffffff
                    $aarraytarget[$idim_1_tgt + $i - $istart][$j] = $aarraysource[$i][$j]
                Next
            Next
        Case Else
            Return SetError(0x3, 0x0, +0xffffffff)
    EndSwitch
    Return UBound($aarraytarget, $ubound_rows)
EndFunc   ;==>_ARRAYCONCATENATE
Func _ArrayDelete(ByRef $aarray, $vrange)
    If Not IsArray($aarray) Then Return SetError(0x1, 0x0, +0xffffffff)
    Local $idim_1 = UBound($aarray, $ubound_rows) + 0xffffffff
    If IsArray($vrange) Then
        If UBound($vrange, $ubound_dimensions) <> 0x1 Or UBound($vrange, $ubound_rows) < 0x2 Then Return SetError(0x4, 0x0, +0xffffffff)
    Else
        Local $inumber, $asplit_1, $asplit_2
        $vrange = StringStripWS($vrange, 0x8)
        $asplit_1 = StringSplit($vrange, ";")
        $vrange = ""
        For $i = 0x1 To $asplit_1[0x0]
            If Not StringRegExp($asplit_1[$i], "^\d+(-\d+)?$") Then Return SetError(0x3, 0x0, +0xffffffff)
            $asplit_2 = StringSplit($asplit_1[$i], "-")
            Switch $asplit_2[0x0]
                Case 0x1
                    $vrange &= $asplit_2[0x1] & ";"
                Case 0x2
                    If Number($asplit_2[0x2]) >= Number($asplit_2[0x1]) Then
                        $inumber = $asplit_2[0x1] + 0xffffffff
                        Do
                            $inumber += 0x1
                            $vrange &= $inumber & ";"
                        Until $inumber = $asplit_2[0x2]
                    EndIf
            EndSwitch
        Next
        $vrange = StringSplit(StringTrimRight($vrange, 0x1), ";")
    EndIf
    For $i = 0x1 To $vrange[0x0]
        $vrange[$i] = Number($vrange[$i])
    Next
    If $vrange[0x1] < 0x0 Or $vrange[$vrange[0x0]] > $idim_1 Then Return SetError(0x5, 0x0, +0xffffffff)
    Local $icopyto_index = 0x0
    Switch UBound($aarray, $ubound_dimensions)
        Case 0x1
            For $i = 0x1 To $vrange[0x0]
                $aarray[$vrange[$i]] = ChrW(0xfab1)
            Next
            For $ireadfrom_index = 0x0 To $idim_1
                If $aarray[$ireadfrom_index] == ChrW(0xfab1) Then
                    ContinueLoop
                Else
                    If $ireadfrom_index <> $icopyto_index Then
                        $aarray[$icopyto_index] = $aarray[$ireadfrom_index]
                    EndIf
                    $icopyto_index += 0x1
                EndIf
            Next
            ReDim $aarray[$idim_1 - $vrange[0x0] + 0x1]
        Case 0x2
            Local $idim_2 = UBound($aarray, $ubound_columns) + 0xffffffff
            For $i = 0x1 To $vrange[0x0]
                $aarray[$vrange[$i]][0x0] = ChrW(0xfab1)
            Next
            For $ireadfrom_index = 0x0 To $idim_1
                If $aarray[$ireadfrom_index][0x0] == ChrW(0xfab1) Then
                    ContinueLoop
                Else
                    If $ireadfrom_index <> $icopyto_index Then
                        For $j = 0x0 To $idim_2
                            $aarray[$icopyto_index][$j] = $aarray[$ireadfrom_index][$j]
                        Next
                    EndIf
                    $icopyto_index += 0x1
                EndIf
            Next
            ReDim $aarray[$idim_1 - $vrange[0x0] + 0x1][$idim_2 + 0x1]
        Case Else
            Return SetError(0x2, 0x0, False)
    EndSwitch
    Return UBound($aarray, $ubound_rows)
EndFunc   ;==>_ARRAYDELETE
Func _ArrayDisplay(Const ByRef $aarray, $stitle = Default, $sarrayrange = Default, $iflags = Default, $vuser_separator = Default, $sheader = Default, $imax_colwidth = Default)
    #forceref $vuser_separator
    Local $iret = __ARRAYDISPLAY_SHARE($aarray, $stitle, $sarrayrange, $iflags, Default, $sheader, $imax_colwidth, 0x0, False)
    Return SetError(@error, @extended, $iret)
EndFunc   ;==>_ARRAYDISPLAY
Func _ARRAYEXTRACT(Const ByRef $aarray, $istart_row = +0xffffffff, $iend_row = +0xffffffff, $istart_col = +0xffffffff, $iend_col = +0xffffffff)
    If $istart_row = Default Then $istart_row = +0xffffffff
    If $iend_row = Default Then $iend_row = +0xffffffff
    If $istart_col = Default Then $istart_col = +0xffffffff
    If $iend_col = Default Then $iend_col = +0xffffffff
    If Not IsArray($aarray) Then Return SetError(0x1, 0x0, +0xffffffff)
    Local $idim_1 = UBound($aarray, $ubound_rows) + 0xffffffff
    If $iend_row = +0xffffffff Then $iend_row = $idim_1
    If $istart_row = +0xffffffff Then $istart_row = 0x0
    If $istart_row < +0xffffffff Or $iend_row < +0xffffffff Then Return SetError(0x3, 0x0, +0xffffffff)
    If $istart_row > $idim_1 Or $iend_row > $idim_1 Then Return SetError(0x3, 0x0, +0xffffffff)
    If $istart_row > $iend_row Then Return SetError(0x4, 0x0, +0xffffffff)
    Switch UBound($aarray, $ubound_dimensions)
        Case 0x1
            Local $aretarray[$iend_row - $istart_row + 0x1]
            For $i = 0x0 To $iend_row - $istart_row
                $aretarray[$i] = $aarray[$i + $istart_row]
            Next
            Return $aretarray
        Case 0x2
            Local $idim_2 = UBound($aarray, $ubound_columns) + 0xffffffff
            If $iend_col = +0xffffffff Then $iend_col = $idim_2
            If $istart_col = +0xffffffff Then $istart_col = 0x0
            If $istart_col < +0xffffffff Or $iend_col < +0xffffffff Then Return SetError(0x5, 0x0, +0xffffffff)
            If $istart_col > $idim_2 Or $iend_col > $idim_2 Then Return SetError(0x5, 0x0, +0xffffffff)
            If $istart_col > $iend_col Then Return SetError(0x6, 0x0, +0xffffffff)
            If $istart_col = $iend_col Then
                Local $aretarray[$iend_row - $istart_row + 0x1]
            Else
                Local $aretarray[$iend_row - $istart_row + 0x1][$iend_col - $istart_col + 0x1]
            EndIf
            For $i = 0x0 To $iend_row - $istart_row
                For $j = 0x0 To $iend_col - $istart_col
                    If $istart_col = $iend_col Then
                        $aretarray[$i] = $aarray[$i + $istart_row][$j + $istart_col]
                    Else
                        $aretarray[$i][$j] = $aarray[$i + $istart_row][$j + $istart_col]
                    EndIf
                Next
            Next
            Return $aretarray
        Case Else
            Return SetError(0x2, 0x0, +0xffffffff)
    EndSwitch
    Return 0x1
EndFunc   ;==>_ARRAYEXTRACT
Func _ArrayFindAll(Const ByRef $aarray, $vvalue, $istart = 0x0, $iend = 0x0, $icase = 0x0, $icompare = 0x0, $isubitem = 0x0, $brow = False)
    If $istart = Default Then $istart = 0x0
    If $iend = Default Then $iend = 0x0
    If $icase = Default Then $icase = 0x0
    If $icompare = Default Then $icompare = 0x0
    If $isubitem = Default Then $isubitem = 0x0
    If $brow = Default Then $brow = False
    $istart = _ArraySearch($aarray, $vvalue, $istart, $iend, $icase, $icompare, 0x1, $isubitem, $brow)
    If @error Then Return SetError(@error, 0x0, +0xffffffff)
    Local $iindex = 0x0, $avresult[UBound($aarray, ($brow ? $ubound_columns : $ubound_rows))]
    Do
        $avresult[$iindex] = $istart
        $iindex += 0x1
        $istart = _ArraySearch($aarray, $vvalue, $istart + 0x1, $iend, $icase, $icompare, 0x1, $isubitem, $brow)
    Until @error
    ReDim $avresult[$iindex]
    Return $avresult
EndFunc   ;==>_ARRAYFINDALL
Func _ARRAYFROMSTRING($sarraystr, $sdelim_col = "|", $sdelim_row = @CRLF, $bforce2d = False, $istripws = $str_stripleading + $str_striptrailing)
    If $sdelim_col = Default Then $sdelim_col = "|"
    If $sdelim_row = Default Then $sdelim_row = @CRLF
    If $bforce2d = Default Then $bforce2d = False
    If $istripws = Default Then $istripws = $str_stripleading + $str_striptrailing
    Local $arow, $acol = StringSplit($sarraystr, $sdelim_row, $str_entiresplit + $str_nocount)
    $arow = StringSplit($acol[0x0], $sdelim_col, $str_entiresplit + $str_nocount)
    If UBound($acol) = 0x1 And Not $bforce2d Then
        For $m = 0x0 To UBound($arow) + 0xffffffff
            $arow[$m] = ($istripws ? StringStripWS($arow[$m], $istripws) : $arow[$m])
        Next
        Return $arow
    EndIf
    Local $aret[UBound($acol)][UBound($arow)]
    For $n = 0x0 To UBound($acol) + 0xffffffff
        $arow = StringSplit($acol[$n], $sdelim_col, $str_entiresplit + $str_nocount)
        If UBound($arow) > UBound($aret, 0x2) Then Return SetError(0x1)
        For $m = 0x0 To UBound($arow) + 0xffffffff
            $aret[$n][$m] = ($istripws ? StringStripWS($arow[$m], $istripws) : $arow[$m])
        Next
    Next
    Return $aret
EndFunc   ;==>_ARRAYFROMSTRING
Func _ArrayInsert(ByRef $aarray, $vrange, $vvalue = "", $istart = 0x0, $sdelim_item = "|", $sdelim_row = @CRLF, $iforce = $arrayfill_force_default)
    If $vvalue = Default Then $vvalue = ""
    If $istart = Default Then $istart = 0x0
    If $sdelim_item = Default Then $sdelim_item = "|"
    If $sdelim_row = Default Then $sdelim_row = @CRLF
    If $iforce = Default Then $iforce = $arrayfill_force_default
    If Not IsArray($aarray) Then Return SetError(0x1, 0x0, +0xffffffff)
    Local $idim_1 = UBound($aarray, $ubound_rows) + 0xffffffff
    Local $hdatatype = 0x0
    Switch $iforce
        Case $arrayfill_force_int
            $hdatatype = INT
        Case $arrayfill_force_number
            $hdatatype = NUMBER
        Case $arrayfill_force_ptr
            $hdatatype = PTR
        Case $arrayfill_force_hwnd
            $hdatatype = HWND
        Case $arrayfill_force_string
            $hdatatype = STRING
    EndSwitch
    Local $asplit_1, $asplit_2
    If IsArray($vrange) Then
        If UBound($vrange, $ubound_dimensions) <> 0x1 Or UBound($vrange, $ubound_rows) < 0x2 Then Return SetError(0x4, 0x0, +0xffffffff)
    Else
        Local $inumber
        $vrange = StringStripWS($vrange, 0x8)
        $asplit_1 = StringSplit($vrange, ";")
        $vrange = ""
        For $i = 0x1 To $asplit_1[0x0]
            If Not StringRegExp($asplit_1[$i], "^\d+(-\d+)?$") Then Return SetError(0x3, 0x0, +0xffffffff)
            $asplit_2 = StringSplit($asplit_1[$i], "-")
            Switch $asplit_2[0x0]
                Case 0x1
                    $vrange &= $asplit_2[0x1] & ";"
                Case 0x2
                    If Number($asplit_2[0x2]) >= Number($asplit_2[0x1]) Then
                        $inumber = $asplit_2[0x1] + 0xffffffff
                        Do
                            $inumber += 0x1
                            $vrange &= $inumber & ";"
                        Until $inumber = $asplit_2[0x2]
                    EndIf
            EndSwitch
        Next
        $vrange = StringSplit(StringTrimRight($vrange, 0x1), ";")
    EndIf
    For $i = 0x1 To $vrange[0x0]
        $vrange[$i] = Number($vrange[$i])
    Next
    If $vrange[0x1] < 0x0 Or $vrange[$vrange[0x0]] > $idim_1 Then Return SetError(0x5, 0x0, +0xffffffff)
    For $i = 0x2 To $vrange[0x0]
        If $vrange[$i] < $vrange[$i + 0xffffffff] Then Return SetError(0x3, 0x0, +0xffffffff)
    Next
    Local $icopyto_index = $idim_1 + $vrange[0x0]
    Local $iinsertpoint_index = $vrange[0x0]
    Local $iinsert_index = $vrange[$iinsertpoint_index]
    Switch UBound($aarray, $ubound_dimensions)
        Case 0x1
            If $iforce = $arrayfill_force_singleitem Then
                ReDim $aarray[$idim_1 + $vrange[0x0] + 0x1]
                For $ireadfromindex = $idim_1 To 0x0 Step +0xffffffff
                    $aarray[$icopyto_index] = $aarray[$ireadfromindex]
                    $icopyto_index -= 0x1
                    $iinsert_index = $vrange[$iinsertpoint_index]
                    While $ireadfromindex = $iinsert_index
                        $aarray[$icopyto_index] = $vvalue
                        $icopyto_index -= 0x1
                        $iinsertpoint_index -= 0x1
                        If $iinsertpoint_index < 0x1 Then ExitLoop 0x2
                        $iinsert_index = $vrange[$iinsertpoint_index]
                    WEnd
                Next
                Return $idim_1 + $vrange[0x0] + 0x1
            EndIf
            ReDim $aarray[$idim_1 + $vrange[0x0] + 0x1]
            If IsArray($vvalue) Then
                If UBound($vvalue, $ubound_dimensions) <> 0x1 Then Return SetError(0x5, 0x0, +0xffffffff)
                $hdatatype = 0x0
            Else
                Local $atmp = StringSplit($vvalue, $sdelim_item, $str_nocount + $str_entiresplit)
                If UBound($atmp, $ubound_rows) = 0x1 Then
                    $atmp[0x0] = $vvalue
                    $hdatatype = 0x0
                EndIf
                $vvalue = $atmp
            EndIf
            For $ireadfromindex = $idim_1 To 0x0 Step +0xffffffff
                $aarray[$icopyto_index] = $aarray[$ireadfromindex]
                $icopyto_index -= 0x1
                $iinsert_index = $vrange[$iinsertpoint_index]
                While $ireadfromindex = $iinsert_index
                    If $iinsertpoint_index <= UBound($vvalue, $ubound_rows) Then
                        If ISFUNC($hdatatype) Then
                            $aarray[$icopyto_index] = $HDATATYPE($vvalue[$iinsertpoint_index + 0xffffffff])
                        Else
                            $aarray[$icopyto_index] = $vvalue[$iinsertpoint_index + 0xffffffff]
                        EndIf
                    Else
                        $aarray[$icopyto_index] = ""
                    EndIf
                    $icopyto_index -= 0x1
                    $iinsertpoint_index -= 0x1
                    If $iinsertpoint_index = 0x0 Then ExitLoop 0x2
                    $iinsert_index = $vrange[$iinsertpoint_index]
                WEnd
            Next
        Case 0x2
            Local $idim_2 = UBound($aarray, $ubound_columns)
            If $istart < 0x0 Or $istart > $idim_2 + 0xffffffff Then Return SetError(0x6, 0x0, +0xffffffff)
            Local $ivaldim_1, $ivaldim_2
            If IsArray($vvalue) Then
                If UBound($vvalue, $ubound_dimensions) <> 0x2 Then Return SetError(0x7, 0x0, +0xffffffff)
                $ivaldim_1 = UBound($vvalue, $ubound_rows)
                $ivaldim_2 = UBound($vvalue, $ubound_columns)
                $hdatatype = 0x0
            Else
                $asplit_1 = StringSplit($vvalue, $sdelim_row, $str_nocount + $str_entiresplit)
                $ivaldim_1 = UBound($asplit_1, $ubound_rows)
                StringReplace($asplit_1[0x0], $sdelim_item, "")
                $ivaldim_2 = @extended + 0x1
                Local $atmp[$ivaldim_1][$ivaldim_2]
                For $i = 0x0 To $ivaldim_1 + 0xffffffff
                    $asplit_2 = StringSplit($asplit_1[$i], $sdelim_item, $str_nocount + $str_entiresplit)
                    For $j = 0x0 To $ivaldim_2 + 0xffffffff
                        $atmp[$i][$j] = $asplit_2[$j]
                    Next
                Next
                $vvalue = $atmp
            EndIf
            If UBound($vvalue, $ubound_columns) + $istart > UBound($aarray, $ubound_columns) Then Return SetError(0x8, 0x0, +0xffffffff)
            ReDim $aarray[$idim_1 + $vrange[0x0] + 0x1][$idim_2]
            For $ireadfromindex = $idim_1 To 0x0 Step +0xffffffff
                For $j = 0x0 To $idim_2 + 0xffffffff
                    $aarray[$icopyto_index][$j] = $aarray[$ireadfromindex][$j]
                Next
                $icopyto_index -= 0x1
                $iinsert_index = $vrange[$iinsertpoint_index]
                While $ireadfromindex = $iinsert_index
                    For $j = 0x0 To $idim_2 + 0xffffffff
                        If $j < $istart Then
                            $aarray[$icopyto_index][$j] = ""
                        ElseIf $j - $istart > $ivaldim_2 + 0xffffffff Then
                            $aarray[$icopyto_index][$j] = ""
                        Else
                            If $iinsertpoint_index + 0xffffffff < $ivaldim_1 Then
                                If ISFUNC($hdatatype) Then
                                    $aarray[$icopyto_index][$j] = $HDATATYPE($vvalue[$iinsertpoint_index + 0xffffffff][$j - $istart])
                                Else
                                    $aarray[$icopyto_index][$j] = $vvalue[$iinsertpoint_index + 0xffffffff][$j - $istart]
                                EndIf
                            Else
                                $aarray[$icopyto_index][$j] = ""
                            EndIf
                        EndIf
                    Next
                    $icopyto_index -= 0x1
                    $iinsertpoint_index -= 0x1
                    If $iinsertpoint_index = 0x0 Then ExitLoop 0x2
                    $iinsert_index = $vrange[$iinsertpoint_index]
                WEnd
            Next
        Case Else
            Return SetError(0x2, 0x0, +0xffffffff)
    EndSwitch
    Return UBound($aarray, $ubound_rows)
EndFunc   ;==>_ARRAYINSERT
Func _ArrayMax(Const ByRef $aarray, $icompnumeric = 0x0, $istart = +0xffffffff, $iend = +0xffffffff, $isubitem = 0x0)
    Local $iresult = _ArrayMaxIndex($aarray, $icompnumeric, $istart, $iend, $isubitem)
    If @error Then Return SetError(@error, 0x0, "")
    If UBound($aarray, $ubound_dimensions) = 0x1 Then
        Return $aarray[$iresult]
    Else
        Return $aarray[$iresult][$isubitem]
    EndIf
EndFunc   ;==>_ARRAYMAX
Func _ArrayMaxIndex(Const ByRef $aarray, $icompnumeric = 0x0, $istart = +0xffffffff, $iend = +0xffffffff, $isubitem = 0x0)
    If $icompnumeric = Default Then $icompnumeric = 0x0
    If $istart = Default Then $istart = +0xffffffff
    If $iend = Default Then $iend = +0xffffffff
    If $isubitem = Default Then $isubitem = 0x0
    Local $iret = __ARRAY_MINMAXINDEX($aarray, $icompnumeric, $istart, $iend, $isubitem, __ARRAY_GREATERTHAN)
    Return SetError(@error, 0x0, $iret)
EndFunc   ;==>_ARRAYMAXINDEX
Func _ArrayMin(Const ByRef $aarray, $icompnumeric = 0x0, $istart = +0xffffffff, $iend = +0xffffffff, $isubitem = 0x0)
    Local $iresult = _ArrayMinIndex($aarray, $icompnumeric, $istart, $iend, $isubitem)
    If @error Then Return SetError(@error, 0x0, "")
    If UBound($aarray, $ubound_dimensions) = 0x1 Then
        Return $aarray[$iresult]
    Else
        Return $aarray[$iresult][$isubitem]
    EndIf
EndFunc   ;==>_ARRAYMIN
Func _ArrayMinIndex(Const ByRef $aarray, $icompnumeric = 0x0, $istart = +0xffffffff, $iend = +0xffffffff, $isubitem = 0x0)
    If $icompnumeric = Default Then $icompnumeric = 0x0
    If $istart = Default Then $istart = +0xffffffff
    If $iend = Default Then $iend = +0xffffffff
    If $isubitem = Default Then $isubitem = 0x0
    Local $iret = __ARRAY_MINMAXINDEX($aarray, $icompnumeric, $istart, $iend, $isubitem, __ARRAY_LESSTHAN)
    Return SetError(@error, 0x0, $iret)
EndFunc   ;==>_ARRAYMININDEX
Func _ArrayPermute(ByRef $aarray, $sdelimiter = "")
    If $sdelimiter = Default Then $sdelimiter = ""
    If Not IsArray($aarray) Then Return SetError(0x1, 0x0, 0x0)
    If UBound($aarray, $ubound_dimensions) <> 0x1 Then Return SetError(0x2, 0x0, 0x0)
    Local $isize = UBound($aarray), $ifactorial = 0x1, $aidx[$isize], $aresult[0x1], $icount = 0x1
    If UBound($aarray) Then
        For $i = 0x0 To $isize + 0xffffffff
            $aidx[$i] = $i
        Next
        For $i = $isize To 0x1 Step +0xffffffff
            $ifactorial *= $i
        Next
        ReDim $aresult[$ifactorial + 0x1]
        $aresult[0x0] = $ifactorial
        __ARRAY_EXETERINTERNAL($aarray, 0x0, $isize, $sdelimiter, $aidx, $aresult, $icount)
    Else
        $aresult[0x0] = 0x0
    EndIf
    Return $aresult
EndFunc   ;==>_ARRAYPERMUTE
Func _ArrayPop(ByRef $aarray)
    If (Not IsArray($aarray)) Then Return SetError(0x1, 0x0, "")
    If UBound($aarray, $ubound_dimensions) <> 0x1 Then Return SetError(0x2, 0x0, "")
    Local $iubound = UBound($aarray) + 0xffffffff
    If $iubound = +0xffffffff Then Return SetError(0x3, 0x0, "")
    Local $slastval = $aarray[$iubound]
    If $iubound > +0xffffffff Then
        ReDim $aarray[$iubound]
    EndIf
    Return $slastval
EndFunc   ;==>_ARRAYPOP
Func _ArrayPush(ByRef $aarray, $vvalue, $idirection = 0x0)
    If $idirection = Default Then $idirection = 0x0
    If (Not IsArray($aarray)) Then Return SetError(0x1, 0x0, 0x0)
    If UBound($aarray, $ubound_dimensions) <> 0x1 Then Return SetError(0x3, 0x0, 0x0)
    Local $iubound = UBound($aarray) + 0xffffffff
    If IsArray($vvalue) Then
        Local $iubounds = UBound($vvalue)
        If ($iubounds + 0xffffffff) > $iubound Then Return SetError(0x2, 0x0, 0x0)
        If $idirection Then
            For $i = $iubound To $iubounds Step +0xffffffff
                $aarray[$i] = $aarray[$i - $iubounds]
            Next
            For $i = 0x0 To $iubounds + 0xffffffff
                $aarray[$i] = $vvalue[$i]
            Next
        Else
            For $i = 0x0 To $iubound - $iubounds
                $aarray[$i] = $aarray[$i + $iubounds]
            Next
            For $i = 0x0 To $iubounds + 0xffffffff
                $aarray[$i + $iubound - $iubounds + 0x1] = $vvalue[$i]
            Next
        EndIf
    Else
        If $iubound > +0xffffffff Then
            If $idirection Then
                For $i = $iubound To 0x1 Step +0xffffffff
                    $aarray[$i] = $aarray[$i + 0xffffffff]
                Next
                $aarray[0x0] = $vvalue
            Else
                For $i = 0x0 To $iubound + 0xffffffff
                    $aarray[$i] = $aarray[$i + 0x1]
                Next
                $aarray[$iubound] = $vvalue
            EndIf
        EndIf
    EndIf
    Return 0x1
EndFunc   ;==>_ARRAYPUSH
Func _ArrayReverse(ByRef $aarray, $istart = 0x0, $iend = 0x0)
    If $istart = Default Then $istart = 0x0
    If $iend = Default Then $iend = 0x0
    If Not IsArray($aarray) Then Return SetError(0x1, 0x0, 0x0)
    If UBound($aarray, $ubound_dimensions) <> 0x1 Then Return SetError(0x3, 0x0, 0x0)
    If Not UBound($aarray) Then Return SetError(0x4, 0x0, 0x0)
    Local $vtmp, $iubound = UBound($aarray) + 0xffffffff
    If $iend < 0x1 Or $iend > $iubound Then $iend = $iubound
    If $istart < 0x0 Then $istart = 0x0
    If $istart > $iend Then Return SetError(0x2, 0x0, 0x0)
    For $i = $istart To Int(($istart + $iend + 0xffffffff) / 0x2)
        $vtmp = $aarray[$i]
        $aarray[$i] = $aarray[$iend]
        $aarray[$iend] = $vtmp
        $iend -= 0x1
    Next
    Return 0x1
EndFunc   ;==>_ARRAYREVERSE
Func _ArraySearch(Const ByRef $aarray, $vvalue, $istart = 0x0, $iend = 0x0, $icase = 0x0, $icompare = 0x0, $iforward = 0x1, $isubitem = +0xffffffff, $brow = False)
    If $istart = Default Then $istart = 0x0
    If $iend = Default Then $iend = 0x0
    If $icase = Default Then $icase = 0x0
    If $icompare = Default Then $icompare = 0x0
    If $iforward = Default Then $iforward = 0x1
    If $isubitem = Default Then $isubitem = +0xffffffff
    If $brow = Default Then $brow = False
    If Not IsArray($aarray) Then Return SetError(0x1, 0x0, +0xffffffff)
    Local $idim_1 = UBound($aarray) + 0xffffffff
    If $idim_1 = +0xffffffff Then Return SetError(0x3, 0x0, +0xffffffff)
    Local $idim_2 = UBound($aarray, $ubound_columns) + 0xffffffff
    Local $bcomptype = False
    If $icompare = 0x2 Then
        $icompare = 0x0
        $bcomptype = True
    EndIf
    If $brow Then
        If UBound($aarray, $ubound_dimensions) = 0x1 Then Return SetError(0x5, 0x0, +0xffffffff)
        If $iend < 0x1 Or $iend > $idim_2 Then $iend = $idim_2
        If $istart < 0x0 Then $istart = 0x0
        If $istart > $iend Then Return SetError(0x4, 0x0, +0xffffffff)
    Else
        If $iend < 0x1 Or $iend > $idim_1 Then $iend = $idim_1
        If $istart < 0x0 Then $istart = 0x0
        If $istart > $iend Then Return SetError(0x4, 0x0, +0xffffffff)
    EndIf
    Local $istep = 0x1
    If Not $iforward Then
        Local $itmp = $istart
        $istart = $iend
        $iend = $itmp
        $istep = +0xffffffff
    EndIf
    Switch UBound($aarray, $ubound_dimensions)
        Case 0x1
            If Not $icompare Then
                If Not $icase Then
                    For $i = $istart To $iend Step $istep
                        If $bcomptype And VarGetType($aarray[$i]) <> VarGetType($vvalue) Then ContinueLoop
                        If $aarray[$i] = $vvalue Then Return $i
                    Next
                Else
                    For $i = $istart To $iend Step $istep
                        If $bcomptype And VarGetType($aarray[$i]) <> VarGetType($vvalue) Then ContinueLoop
                        If $aarray[$i] == $vvalue Then Return $i
                    Next
                EndIf
            Else
                For $i = $istart To $iend Step $istep
                    If $icompare = 0x3 Then
                        If StringRegExp($aarray[$i], $vvalue) Then Return $i
                    Else
                        If StringInStr($aarray[$i], $vvalue, $icase) > 0x0 Then Return $i
                    EndIf
                Next
            EndIf
        Case 0x2
            Local $idim_sub
            If $brow Then
                $idim_sub = $idim_1
                If $isubitem > $idim_sub Then $isubitem = $idim_sub
                If $isubitem < 0x0 Then
                    $isubitem = 0x0
                Else
                    $idim_sub = $isubitem
                EndIf
            Else
                $idim_sub = $idim_2
                If $isubitem > $idim_sub Then $isubitem = $idim_sub
                If $isubitem < 0x0 Then
                    $isubitem = 0x0
                Else
                    $idim_sub = $isubitem
                EndIf
            EndIf
            For $j = $isubitem To $idim_sub
                If Not $icompare Then
                    If Not $icase Then
                        For $i = $istart To $iend Step $istep
                            If $brow Then
                                If $bcomptype And VarGetType($aarray[$j][$i]) <> VarGetType($vvalue) Then ContinueLoop
                                If $aarray[$j][$i] = $vvalue Then Return $i
                            Else
                                If $bcomptype And VarGetType($aarray[$i][$j]) <> VarGetType($vvalue) Then ContinueLoop
                                If $aarray[$i][$j] = $vvalue Then Return $i
                            EndIf
                        Next
                    Else
                        For $i = $istart To $iend Step $istep
                            If $brow Then
                                If $bcomptype And VarGetType($aarray[$j][$i]) <> VarGetType($vvalue) Then ContinueLoop
                                If $aarray[$j][$i] == $vvalue Then Return $i
                            Else
                                If $bcomptype And VarGetType($aarray[$i][$j]) <> VarGetType($vvalue) Then ContinueLoop
                                If $aarray[$i][$j] == $vvalue Then Return $i
                            EndIf
                        Next
                    EndIf
                Else
                    For $i = $istart To $iend Step $istep
                        If $icompare = 0x3 Then
                            If $brow Then
                                If StringRegExp($aarray[$j][$i], $vvalue) Then Return $i
                            Else
                                If StringRegExp($aarray[$i][$j], $vvalue) Then Return $i
                            EndIf
                        Else
                            If $brow Then
                                If StringInStr($aarray[$j][$i], $vvalue, $icase) > 0x0 Then Return $i
                            Else
                                If StringInStr($aarray[$i][$j], $vvalue, $icase) > 0x0 Then Return $i
                            EndIf
                        EndIf
                    Next
                EndIf
            Next
        Case Else
            Return SetError(0x2, 0x0, +0xffffffff)
    EndSwitch
    Return SetError(0x6, 0x0, +0xffffffff)
EndFunc   ;==>_ARRAYSEARCH
Func _ARRAYSHUFFLE(ByRef $aarray, $istart_row = 0x0, $iend_row = 0x0, $icol = +0xffffffff)
    If $istart_row = Default Then $istart_row = 0x0
    If $iend_row = Default Then $iend_row = 0x0
    If $icol = Default Then $icol = +0xffffffff
    If Not IsArray($aarray) Then Return SetError(0x1, 0x0, +0xffffffff)
    Local $idim_1 = UBound($aarray, $ubound_rows)
    If $iend_row = 0x0 Then $iend_row = $idim_1 + 0xffffffff
    If $istart_row < 0x0 Or $istart_row > $idim_1 + 0xffffffff Then Return SetError(0x3, 0x0, +0xffffffff)
    If $iend_row < 0x1 Or $iend_row > $idim_1 + 0xffffffff Then Return SetError(0x3, 0x0, +0xffffffff)
    If $istart_row > $iend_row Then Return SetError(0x4, 0x0, +0xffffffff)
    Local $vtmp, $irand
    Switch UBound($aarray, $ubound_dimensions)
        Case 0x1
            For $i = $iend_row To $istart_row + 0x1 Step +0xffffffff
                $irand = Random($istart_row, $i, 0x1)
                $vtmp = $aarray[$i]
                $aarray[$i] = $aarray[$irand]
                $aarray[$irand] = $vtmp
            Next
            Return 0x1
        Case 0x2
            Local $idim_2 = UBound($aarray, $ubound_columns)
            If $icol < +0xffffffff Or $icol > $idim_2 + 0xffffffff Then Return SetError(0x5, 0x0, +0xffffffff)
            Local $icol_start, $icol_end
            If $icol = +0xffffffff Then
                $icol_start = 0x0
                $icol_end = $idim_2 + 0xffffffff
            Else
                $icol_start = $icol
                $icol_end = $icol
            EndIf
            For $i = $iend_row To $istart_row + 0x1 Step +0xffffffff
                $irand = Random($istart_row, $i, 0x1)
                For $j = $icol_start To $icol_end
                    $vtmp = $aarray[$i][$j]
                    $aarray[$i][$j] = $aarray[$irand][$j]
                    $aarray[$irand][$j] = $vtmp
                Next
            Next
            Return 0x1
        Case Else
            Return SetError(0x2, 0x0, +0xffffffff)
    EndSwitch
EndFunc   ;==>_ARRAYSHUFFLE
Func _ArraySort(ByRef $aarray, $idescending = 0x0, $istart = 0x0, $iend = 0x0, $isubitem = 0x0, $ipivot = 0x0)
    If $idescending = Default Then $idescending = 0x0
    If $istart = Default Then $istart = 0x0
    If $iend = Default Then $iend = 0x0
    If $isubitem = Default Then $isubitem = 0x0
    If $ipivot = Default Then $ipivot = 0x0
    If Not IsArray($aarray) Then Return SetError(0x1, 0x0, 0x0)
    Local $iubound = UBound($aarray) + 0xffffffff
    If $iubound = +0xffffffff Then Return SetError(0x5, 0x0, 0x0)
    If $iend = Default Then $iend = 0x0
    If $iend < 0x1 Or $iend > $iubound Or $iend = Default Then $iend = $iubound
    If $istart < 0x0 Or $istart = Default Then $istart = 0x0
    If $istart > $iend Then Return SetError(0x2, 0x0, 0x0)
    Switch UBound($aarray, $ubound_dimensions)
        Case 0x1
            If $ipivot Then
                __ARRAYDUALPIVOTSORT($aarray, $istart, $iend)
            Else
                __ARRAYQUICKSORT1D($aarray, $istart, $iend)
            EndIf
            If $idescending Then _ArrayReverse($aarray, $istart, $iend)
        Case 0x2
            If $ipivot Then Return SetError(0x6, 0x0, 0x0)
            Local $isubmax = UBound($aarray, $ubound_columns) + 0xffffffff
            If $isubitem > $isubmax Then Return SetError(0x3, 0x0, 0x0)
            If $idescending Then
                $idescending = +0xffffffff
            Else
                $idescending = 0x1
            EndIf
            __ARRAYQUICKSORT2D($aarray, $idescending, $istart, $iend, $isubitem, $isubmax)
        Case Else
            Return SetError(0x4, 0x0, 0x0)
    EndSwitch
    Return 0x1
EndFunc   ;==>_ARRAYSORT
Func __ARRAYQUICKSORT1D(ByRef $aarray, Const ByRef $istart, Const ByRef $iend)
    If $iend <= $istart Then Return
    Local $vtmp
    If ($iend - $istart) < 0xf Then
        Local $vcur
        For $i = $istart + 0x1 To $iend
            $vtmp = $aarray[$i]
            If IsNumber($vtmp) Then
                For $j = $i + 0xffffffff To $istart Step +0xffffffff
                    $vcur = $aarray[$j]
                    If ($vtmp >= $vcur And IsNumber($vcur)) Or (Not IsNumber($vcur) And StringCompare($vtmp, $vcur) >= 0x0) Then ExitLoop
                    $aarray[$j + 0x1] = $vcur
                Next
            Else
                For $j = $i + 0xffffffff To $istart Step +0xffffffff
                    If (StringCompare($vtmp, $aarray[$j]) >= 0x0) Then ExitLoop
                    $aarray[$j + 0x1] = $aarray[$j]
                Next
            EndIf
            $aarray[$j + 0x1] = $vtmp
        Next
        Return
    EndIf
    Local $l = $istart, $r = $iend, $vpivot = $aarray[Int(($istart + $iend) / 0x2)], $bnum = IsNumber($vpivot)
    Do
        If $bnum Then
            While ($aarray[$l] < $vpivot And IsNumber($aarray[$l])) Or (Not IsNumber($aarray[$l]) And StringCompare($aarray[$l], $vpivot) < 0x0)
                $l += 0x1
            WEnd
            While ($aarray[$r] > $vpivot And IsNumber($aarray[$r])) Or (Not IsNumber($aarray[$r]) And StringCompare($aarray[$r], $vpivot) > 0x0)
                $r -= 0x1
            WEnd
        Else
            While (StringCompare($aarray[$l], $vpivot) < 0x0)
                $l += 0x1
            WEnd
            While (StringCompare($aarray[$r], $vpivot) > 0x0)
                $r -= 0x1
            WEnd
        EndIf
        If $l <= $r Then
            $vtmp = $aarray[$l]
            $aarray[$l] = $aarray[$r]
            $aarray[$r] = $vtmp
            $l += 0x1
            $r -= 0x1
        EndIf
    Until $l > $r
    __ARRAYQUICKSORT1D($aarray, $istart, $r)
    __ARRAYQUICKSORT1D($aarray, $l, $iend)
EndFunc   ;==>__ARRAYQUICKSORT1D
Func __ARRAYQUICKSORT2D(ByRef $aarray, Const ByRef $istep, Const ByRef $istart, Const ByRef $iend, Const ByRef $isubitem, Const ByRef $isubmax)
    If $iend <= $istart Then Return
    Local $vtmp, $l = $istart, $r = $iend, $vpivot = $aarray[Int(($istart + $iend) / 0x2)][$isubitem], $bnum = IsNumber($vpivot)
    Do
        If $bnum Then
            While ($istep * ($aarray[$l][$isubitem] - $vpivot) < 0x0 And IsNumber($aarray[$l][$isubitem])) Or (Not IsNumber($aarray[$l][$isubitem]) And $istep * StringCompare($aarray[$l][$isubitem], $vpivot) < 0x0)
                $l += 0x1
            WEnd
            While ($istep * ($aarray[$r][$isubitem] - $vpivot) > 0x0 And IsNumber($aarray[$r][$isubitem])) Or (Not IsNumber($aarray[$r][$isubitem]) And $istep * StringCompare($aarray[$r][$isubitem], $vpivot) > 0x0)
                $r -= 0x1
            WEnd
        Else
            While ($istep * StringCompare($aarray[$l][$isubitem], $vpivot) < 0x0)
                $l += 0x1
            WEnd
            While ($istep * StringCompare($aarray[$r][$isubitem], $vpivot) > 0x0)
                $r -= 0x1
            WEnd
        EndIf
        If $l <= $r Then
            For $i = 0x0 To $isubmax
                $vtmp = $aarray[$l][$i]
                $aarray[$l][$i] = $aarray[$r][$i]
                $aarray[$r][$i] = $vtmp
            Next
            $l += 0x1
            $r -= 0x1
        EndIf
    Until $l > $r
    __ARRAYQUICKSORT2D($aarray, $istep, $istart, $r, $isubitem, $isubmax)
    __ARRAYQUICKSORT2D($aarray, $istep, $l, $iend, $isubitem, $isubmax)
EndFunc   ;==>__ARRAYQUICKSORT2D
Func __ARRAYDUALPIVOTSORT(ByRef $aarray, $ipivot_left, $ipivot_right, $bleftmost = True)
    If $ipivot_left > $ipivot_right Then Return
    Local $ilength = $ipivot_right - $ipivot_left + 0x1
    Local $i, $j, $k, $iai, $iak, $ia1, $ia2, $ilast
    If $ilength < 0x2d Then
        If $bleftmost Then
            $i = $ipivot_left
            While $i < $ipivot_right
                $j = $i
                $iai = $aarray[$i + 0x1]
                While $iai < $aarray[$j]
                    $aarray[$j + 0x1] = $aarray[$j]
                    $j -= 0x1
                    If $j + 0x1 = $ipivot_left Then ExitLoop
                WEnd
                $aarray[$j + 0x1] = $iai
                $i += 0x1
            WEnd
        Else
            While 0x1
                If $ipivot_left >= $ipivot_right Then Return 0x1
                $ipivot_left += 0x1
                If $aarray[$ipivot_left] < $aarray[$ipivot_left + 0xffffffff] Then ExitLoop
            WEnd
            While 0x1
                $k = $ipivot_left
                $ipivot_left += 0x1
                If $ipivot_left > $ipivot_right Then ExitLoop
                $ia1 = $aarray[$k]
                $ia2 = $aarray[$ipivot_left]
                If $ia1 < $ia2 Then
                    $ia2 = $ia1
                    $ia1 = $aarray[$ipivot_left]
                EndIf
                $k -= 0x1
                While $ia1 < $aarray[$k]
                    $aarray[$k + 0x2] = $aarray[$k]
                    $k -= 0x1
                WEnd
                $aarray[$k + 0x2] = $ia1
                While $ia2 < $aarray[$k]
                    $aarray[$k + 0x1] = $aarray[$k]
                    $k -= 0x1
                WEnd
                $aarray[$k + 0x1] = $ia2
                $ipivot_left += 0x1
            WEnd
            $ilast = $aarray[$ipivot_right]
            $ipivot_right -= 0x1
            While $ilast < $aarray[$ipivot_right]
                $aarray[$ipivot_right + 0x1] = $aarray[$ipivot_right]
                $ipivot_right -= 0x1
            WEnd
            $aarray[$ipivot_right + 0x1] = $ilast
        EndIf
        Return 0x1
    EndIf
    Local $iseventh = BitShift($ilength, 0x3) + BitShift($ilength, 0x6) + 0x1
    Local $ie1, $ie2, $ie3, $ie4, $ie5, $t
    $ie3 = Ceiling(($ipivot_left + $ipivot_right) / 0x2)
    $ie2 = $ie3 - $iseventh
    $ie1 = $ie2 - $iseventh
    $ie4 = $ie3 + $iseventh
    $ie5 = $ie4 + $iseventh
    If $aarray[$ie2] < $aarray[$ie1] Then
        $t = $aarray[$ie2]
        $aarray[$ie2] = $aarray[$ie1]
        $aarray[$ie1] = $t
    EndIf
    If $aarray[$ie3] < $aarray[$ie2] Then
        $t = $aarray[$ie3]
        $aarray[$ie3] = $aarray[$ie2]
        $aarray[$ie2] = $t
        If $t < $aarray[$ie1] Then
            $aarray[$ie2] = $aarray[$ie1]
            $aarray[$ie1] = $t
        EndIf
    EndIf
    If $aarray[$ie4] < $aarray[$ie3] Then
        $t = $aarray[$ie4]
        $aarray[$ie4] = $aarray[$ie3]
        $aarray[$ie3] = $t
        If $t < $aarray[$ie2] Then
            $aarray[$ie3] = $aarray[$ie2]
            $aarray[$ie2] = $t
            If $t < $aarray[$ie1] Then
                $aarray[$ie2] = $aarray[$ie1]
                $aarray[$ie1] = $t
            EndIf
        EndIf
    EndIf
    If $aarray[$ie5] < $aarray[$ie4] Then
        $t = $aarray[$ie5]
        $aarray[$ie5] = $aarray[$ie4]
        $aarray[$ie4] = $t
        If $t < $aarray[$ie3] Then
            $aarray[$ie4] = $aarray[$ie3]
            $aarray[$ie3] = $t
            If $t < $aarray[$ie2] Then
                $aarray[$ie3] = $aarray[$ie2]
                $aarray[$ie2] = $t
                If $t < $aarray[$ie1] Then
                    $aarray[$ie2] = $aarray[$ie1]
                    $aarray[$ie1] = $t
                EndIf
            EndIf
        EndIf
    EndIf
    Local $iless = $ipivot_left
    Local $igreater = $ipivot_right
    If (($aarray[$ie1] <> $aarray[$ie2]) And ($aarray[$ie2] <> $aarray[$ie3]) And ($aarray[$ie3] <> $aarray[$ie4]) And ($aarray[$ie4] <> $aarray[$ie5])) Then
        Local $ipivot_1 = $aarray[$ie2]
        Local $ipivot_2 = $aarray[$ie4]
        $aarray[$ie2] = $aarray[$ipivot_left]
        $aarray[$ie4] = $aarray[$ipivot_right]
        Do
            $iless += 0x1
        Until $aarray[$iless] >= $ipivot_1
        Do
            $igreater -= 0x1
        Until $aarray[$igreater] <= $ipivot_2
        $k = $iless
        While $k <= $igreater
            $iak = $aarray[$k]
            If $iak < $ipivot_1 Then
                $aarray[$k] = $aarray[$iless]
                $aarray[$iless] = $iak
                $iless += 0x1
            ElseIf $iak > $ipivot_2 Then
                While $aarray[$igreater] > $ipivot_2
                    $igreater -= 0x1
                    If $igreater + 0x1 = $k Then ExitLoop 0x2
                WEnd
                If $aarray[$igreater] < $ipivot_1 Then
                    $aarray[$k] = $aarray[$iless]
                    $aarray[$iless] = $aarray[$igreater]
                    $iless += 0x1
                Else
                    $aarray[$k] = $aarray[$igreater]
                EndIf
                $aarray[$igreater] = $iak
                $igreater -= 0x1
            EndIf
            $k += 0x1
        WEnd
        $aarray[$ipivot_left] = $aarray[$iless + 0xffffffff]
        $aarray[$iless + 0xffffffff] = $ipivot_1
        $aarray[$ipivot_right] = $aarray[$igreater + 0x1]
        $aarray[$igreater + 0x1] = $ipivot_2
        __ARRAYDUALPIVOTSORT($aarray, $ipivot_left, $iless + 0xfffffffe, True)
        __ARRAYDUALPIVOTSORT($aarray, $igreater + 0x2, $ipivot_right, False)
        If ($iless < $ie1) And ($ie5 < $igreater) Then
            While $aarray[$iless] = $ipivot_1
                $iless += 0x1
            WEnd
            While $aarray[$igreater] = $ipivot_2
                $igreater -= 0x1
            WEnd
            $k = $iless
            While $k <= $igreater
                $iak = $aarray[$k]
                If $iak = $ipivot_1 Then
                    $aarray[$k] = $aarray[$iless]
                    $aarray[$iless] = $iak
                    $iless += 0x1
                ElseIf $iak = $ipivot_2 Then
                    While $aarray[$igreater] = $ipivot_2
                        $igreater -= 0x1
                        If $igreater + 0x1 = $k Then ExitLoop 0x2
                    WEnd
                    If $aarray[$igreater] = $ipivot_1 Then
                        $aarray[$k] = $aarray[$iless]
                        $aarray[$iless] = $ipivot_1
                        $iless += 0x1
                    Else
                        $aarray[$k] = $aarray[$igreater]
                    EndIf
                    $aarray[$igreater] = $iak
                    $igreater -= 0x1
                EndIf
                $k += 0x1
            WEnd
        EndIf
        __ARRAYDUALPIVOTSORT($aarray, $iless, $igreater, False)
    Else
        Local $ipivot = $aarray[$ie3]
        $k = $iless
        While $k <= $igreater
            If $aarray[$k] = $ipivot Then
                $k += 0x1
                ContinueLoop
            EndIf
            $iak = $aarray[$k]
            If $iak < $ipivot Then
                $aarray[$k] = $aarray[$iless]
                $aarray[$iless] = $iak
                $iless += 0x1
            Else
                While $aarray[$igreater] > $ipivot
                    $igreater -= 0x1
                WEnd
                If $aarray[$igreater] < $ipivot Then
                    $aarray[$k] = $aarray[$iless]
                    $aarray[$iless] = $aarray[$igreater]
                    $iless += 0x1
                Else
                    $aarray[$k] = $ipivot
                EndIf
                $aarray[$igreater] = $iak
                $igreater -= 0x1
            EndIf
            $k += 0x1
        WEnd
        __ARRAYDUALPIVOTSORT($aarray, $ipivot_left, $iless + 0xffffffff, True)
        __ARRAYDUALPIVOTSORT($aarray, $igreater + 0x1, $ipivot_right, False)
    EndIf
EndFunc   ;==>__ARRAYDUALPIVOTSORT
Func _ArraySwap(ByRef $aarray, $iindex_1, $iindex_2, $bcol = False, $istart = +0xffffffff, $iend = +0xffffffff)
    If $bcol = Default Then $bcol = False
    If $istart = Default Then $istart = +0xffffffff
    If $iend = Default Then $iend = +0xffffffff
    If Not IsArray($aarray) Then Return SetError(0x1, 0x0, +0xffffffff)
    Local $idim_1 = UBound($aarray, $ubound_rows) + 0xffffffff
    Local $idim_2 = UBound($aarray, $ubound_columns) + 0xffffffff
    If $idim_2 = +0xffffffff Then
        $bcol = False
        $istart = +0xffffffff
        $iend = +0xffffffff
    EndIf
    If $istart > $iend Then Return SetError(0x5, 0x0, +0xffffffff)
    If $bcol Then
        If $iindex_1 < 0x0 Or $iindex_2 > $idim_2 Then Return SetError(0x3, 0x0, +0xffffffff)
        If $istart = +0xffffffff Then $istart = 0x0
        If $iend = +0xffffffff Then $iend = $idim_1
    Else
        If $iindex_1 < 0x0 Or $iindex_2 > $idim_1 Then Return SetError(0x3, 0x0, +0xffffffff)
        If $istart = +0xffffffff Then $istart = 0x0
        If $iend = +0xffffffff Then $iend = $idim_2
    EndIf
    Local $vtmp
    Switch UBound($aarray, $ubound_dimensions)
        Case 0x1
            $vtmp = $aarray[$iindex_1]
            $aarray[$iindex_1] = $aarray[$iindex_2]
            $aarray[$iindex_2] = $vtmp
        Case 0x2
            If $istart < +0xffffffff Or $iend < +0xffffffff Then Return SetError(0x4, 0x0, +0xffffffff)
            If $bcol Then
                If $istart > $idim_1 Or $iend > $idim_1 Then Return SetError(0x4, 0x0, +0xffffffff)
                For $j = $istart To $iend
                    $vtmp = $aarray[$j][$iindex_1]
                    $aarray[$j][$iindex_1] = $aarray[$j][$iindex_2]
                    $aarray[$j][$iindex_2] = $vtmp
                Next
            Else
                If $istart > $idim_2 Or $iend > $idim_2 Then Return SetError(0x4, 0x0, +0xffffffff)
                For $j = $istart To $iend
                    $vtmp = $aarray[$iindex_1][$j]
                    $aarray[$iindex_1][$j] = $aarray[$iindex_2][$j]
                    $aarray[$iindex_2][$j] = $vtmp
                Next
            EndIf
        Case Else
            Return SetError(0x2, 0x0, +0xffffffff)
    EndSwitch
    Return 0x1
EndFunc   ;==>_ARRAYSWAP
Func _ArrayToClip(Const ByRef $aarray, $sdelim_col = "|", $istart_row = +0xffffffff, $iend_row = +0xffffffff, $sdelim_row = @CRLF, $istart_col = +0xffffffff, $iend_col = +0xffffffff)
    Local $sresult = _ArrayToString($aarray, $sdelim_col, $istart_row, $iend_row, $sdelim_row, $istart_col, $iend_col)
    If @error Then Return SetError(@error, 0x0, 0x0)
    If ClipPut($sresult) Then Return 0x1
    Return SetError(+0xffffffff, 0x0, 0x0)
EndFunc   ;==>_ARRAYTOCLIP
Func _ArrayToString(Const ByRef $aarray, $sdelim_col = "|", $istart_row = Default, $iend_row = Default, $sdelim_row = @CRLF, $istart_col = Default, $iend_col = Default)
    If $sdelim_col = Default Then $sdelim_col = "|"
    If $sdelim_row = Default Then $sdelim_row = @CRLF
    If $istart_row = Default Then $istart_row = +0xffffffff
    If $iend_row = Default Then $iend_row = +0xffffffff
    If $istart_col = Default Then $istart_col = +0xffffffff
    If $iend_col = Default Then $iend_col = +0xffffffff
    If Not IsArray($aarray) Then Return SetError(0x1, 0x0, +0xffffffff)
    Local $idim_1 = UBound($aarray, $ubound_rows) + 0xffffffff
    If $idim_1 = +0xffffffff Then Return ""
    If $istart_row = +0xffffffff Then $istart_row = 0x0
    If $iend_row = +0xffffffff Then $iend_row = $idim_1
    If $istart_row < +0xffffffff Or $iend_row < +0xffffffff Then Return SetError(0x3, 0x0, +0xffffffff)
    If $istart_row > $idim_1 Or $iend_row > $idim_1 Then Return SetError(0x3, 0x0, "")
    If $istart_row > $iend_row Then Return SetError(0x4, 0x0, +0xffffffff)
    Local $sret = ""
    Switch UBound($aarray, $ubound_dimensions)
        Case 0x1
            For $i = $istart_row To $iend_row
                $sret &= $aarray[$i] & $sdelim_col
            Next
            Return StringTrimRight($sret, StringLen($sdelim_col))
        Case 0x2
            Local $idim_2 = UBound($aarray, $ubound_columns) + 0xffffffff
            If $idim_2 = +0xffffffff Then Return ""
            If $istart_col = +0xffffffff Then $istart_col = 0x0
            If $iend_col = +0xffffffff Then $iend_col = $idim_2
            If $istart_col < +0xffffffff Or $iend_col < +0xffffffff Then Return SetError(0x5, 0x0, +0xffffffff)
            If $istart_col > $idim_2 Or $iend_col > $idim_2 Then Return SetError(0x5, 0x0, +0xffffffff)
            If $istart_col > $iend_col Then Return SetError(0x6, 0x0, +0xffffffff)
            Local $idelimcollen = StringLen($sdelim_col)
            For $i = $istart_row To $iend_row
                For $j = $istart_col To $iend_col
                    $sret &= $aarray[$i][$j] & $sdelim_col
                Next
                $sret = StringTrimRight($sret, $idelimcollen) & $sdelim_row
            Next
            Return StringTrimRight($sret, StringLen($sdelim_row))
        Case Else
            Return SetError(0x2, 0x0, +0xffffffff)
    EndSwitch
    Return 0x1
EndFunc   ;==>_ARRAYTOSTRING
Func _ARRAYTRANSPOSE(ByRef $aarray, $bforce1d = False)
    Local $atemp
    Switch $bforce1d
        Case Default
            $bforce1d = False
        Case True, False
        Case Else
            Return SetError(0x3, 0x0, 0x0)
    EndSwitch
    Switch UBound($aarray, 0x0)
        Case 0x0
            Return SetError(0x2, 0x0, 0x0)
        Case 0x1
            Local $atemp[0x1][UBound($aarray)]
            For $i = 0x0 To UBound($aarray) + 0xffffffff
                $atemp[0x0][$i] = $aarray[$i]
            Next
            $aarray = $atemp
        Case 0x2
            Local $idim_1 = UBound($aarray, 0x1), $idim_2 = UBound($aarray, 0x2)
            If $idim_1 <> $idim_2 Then
                Local $atemp[$idim_2][$idim_1]
                For $i = 0x0 To $idim_1 + 0xffffffff
                    For $j = 0x0 To $idim_2 + 0xffffffff
                        $atemp[$j][$i] = $aarray[$i][$j]
                    Next
                Next
                $aarray = $atemp
            Else
                Local $velement
                For $i = 0x0 To $idim_1 + 0xffffffff
                    For $j = $i + 0x1 To $idim_2 + 0xffffffff
                        $velement = $aarray[$i][$j]
                        $aarray[$i][$j] = $aarray[$j][$i]
                        $aarray[$j][$i] = $velement
                    Next
                Next
            EndIf
            If $bforce1d = True And UBound($aarray, 0x2) = 0x1 Then
                $atemp = $aarray
                ReDim $aarray[UBound($atemp)]
                For $i = 0x0 To UBound($atemp) + 0xffffffff
                    $aarray[$i] = $atemp[$i][0x0]
                Next
            EndIf
        Case Else
            Return SetError(0x1, 0x0, 0x0)
    EndSwitch
    Return 0x1
EndFunc   ;==>_ARRAYTRANSPOSE
Func _ArrayTrim(ByRef $aarray, $itrimnum, $idirection = 0x0, $istart = 0x0, $iend = 0x0, $isubitem = 0x0)
    If $idirection = Default Then $idirection = 0x0
    If $istart = Default Then $istart = 0x0
    If $iend = Default Then $iend = 0x0
    If $isubitem = Default Then $isubitem = 0x0
    If Not IsArray($aarray) Then Return SetError(0x1, 0x0, 0x0)
    Local $idim_1 = UBound($aarray, $ubound_rows) + 0xffffffff
    If $iend = 0x0 Then $iend = $idim_1
    If $istart > $iend Then Return SetError(0x3, 0x0, +0xffffffff)
    If $istart < 0x0 Or $iend < 0x0 Then Return SetError(0x3, 0x0, +0xffffffff)
    If $istart > $idim_1 Or $iend > $idim_1 Then Return SetError(0x3, 0x0, +0xffffffff)
    If $istart > $iend Then Return SetError(0x4, 0x0, +0xffffffff)
    Switch UBound($aarray, $ubound_dimensions)
        Case 0x1
            If $idirection Then
                For $i = $istart To $iend
                    $aarray[$i] = StringTrimRight($aarray[$i], $itrimnum)
                Next
            Else
                For $i = $istart To $iend
                    $aarray[$i] = StringTrimLeft($aarray[$i], $itrimnum)
                Next
            EndIf
        Case 0x2
            Local $idim_2 = UBound($aarray, $ubound_columns) + 0xffffffff
            If $isubitem < 0x0 Or $isubitem > $idim_2 Then Return SetError(0x5, 0x0, +0xffffffff)
            If $idirection Then
                For $i = $istart To $iend
                    $aarray[$i][$isubitem] = StringTrimRight($aarray[$i][$isubitem], $itrimnum)
                Next
            Else
                For $i = $istart To $iend
                    $aarray[$i][$isubitem] = StringTrimLeft($aarray[$i][$isubitem], $itrimnum)
                Next
            EndIf
        Case Else
            Return SetError(0x2, 0x0, 0x0)
    EndSwitch
    Return 0x1
EndFunc   ;==>_ARRAYTRIM
Func _ArrayUnique(Const ByRef $aarray, $icolumn = 0x0, $ibase = 0x0, $icase = 0x0, $icount = $arrayunique_count, $iinttype = $arrayunique_auto)
    If $icolumn = Default Then $icolumn = 0x0
    If $ibase = Default Then $ibase = 0x0
    If $icase = Default Then $icase = 0x0
    If $icount = Default Then $icount = $arrayunique_count
    If $iinttype = Default Then $iinttype = $arrayunique_auto
    If UBound($aarray, $ubound_rows) = 0x0 Then Return SetError(0x1, 0x0, 0x0)
    Local $idims = UBound($aarray, $ubound_dimensions), $inumcolumns = UBound($aarray, $ubound_columns)
    If $idims > 0x2 Then Return SetError(0x2, 0x0, 0x0)
    If $ibase < 0x0 Or $ibase > 0x1 Or (Not IsInt($ibase)) Then Return SetError(0x3, 0x0, 0x0)
    If $icase < 0x0 Or $icase > 0x1 Or (Not IsInt($icase)) Then Return SetError(0x3, 0x0, 0x0)
    If $icount < 0x0 Or $icount > 0x1 Or (Not IsInt($icount)) Then Return SetError(0x4, 0x0, 0x0)
    If $iinttype < 0x0 Or $iinttype > 0x4 Or (Not IsInt($iinttype)) Then Return SetError(0x5, 0x0, 0x0)
    If $icolumn < 0x0 Or ($inumcolumns = 0x0 And $icolumn > 0x0) Or ($inumcolumns > 0x0 And $icolumn >= $inumcolumns) Then Return SetError(0x6, 0x0, 0x0)
    If $iinttype = $arrayunique_auto Then
        Local $bint, $svartype
        If $idims = 0x1 Then
            $bint = IsInt($aarray[$ibase])
            $svartype = VarGetType($aarray[$ibase])
        Else
            $bint = IsInt($aarray[$ibase][$icolumn])
            $svartype = VarGetType($aarray[$ibase][$icolumn])
        EndIf
        If $bint And $svartype = "Int64" Then
            $iinttype = $arrayunique_force64
        Else
            $iinttype = $arrayunique_force32
        EndIf
    EndIf
    ObjEvent("AutoIt.Error", __ARRAYUNIQUE_AUTOERRFUNC)
    Local $odictionary = ObjCreate("Scripting.Dictionary")
    $odictionary .CompareMode = Number(Not $icase)
    Local $velem, $stype, $vkey, $bcomerror = False
    For $i = $ibase To UBound($aarray) + 0xffffffff
        If $idims = 0x1 Then
            $velem = $aarray[$i]
        Else
            $velem = $aarray[$i][$icolumn]
        EndIf
        Switch $iinttype
            Case $arrayunique_force32
                $odictionary .Item($velem)
                If @error Then
                    $bcomerror = True
                    ExitLoop
                EndIf
            Case $arrayunique_force64
                $stype = VarGetType($velem)
                If $stype = "Int32" Then
                    $bcomerror = True
                    ExitLoop
                EndIf
                $vkey = "#" & $stype & "#" & String($velem)
                If Not $odictionary .Item($vkey) Then
                    $ODICTIONARY($vkey) = $velem
                EndIf
            Case $arrayunique_match
                $stype = VarGetType($velem)
                If StringLeft($stype, 0x3) = "Int" Then
                    $vkey = "#Int#" & String($velem)
                Else
                    $vkey = "#" & $stype & "#" & String($velem)
                EndIf
                If Not $odictionary .Item($vkey) Then
                    $ODICTIONARY($vkey) = $velem
                EndIf
            Case $arrayunique_distinct
                $vkey = "#" & VarGetType($velem) & "#" & String($velem)
                If Not $odictionary .Item($vkey) Then
                    $ODICTIONARY($vkey) = $velem
                EndIf
        EndSwitch
    Next
    Local $avalues, $j = 0x0
    If $bcomerror Then
        Return SetError(0x7, 0x0, 0x0)
    ElseIf $iinttype <> $arrayunique_force32 Then
        Local $avalues[$odictionary .Count]
        For $vkey In $odictionary .Keys()
            $avalues[$j] = $ODICTIONARY($vkey)
            If StringLeft($vkey, 0x5) = "#Ptr#" Then
                $avalues[$j] = Ptr($avalues[$j])
            EndIf
            $j += 0x1
        Next
    Else
        $avalues = $odictionary .Keys()
    EndIf
    If $icount Then
        _ArrayInsert($avalues, 0x0, $odictionary .Count)
    EndIf
    Return $avalues
EndFunc   ;==>_ARRAYUNIQUE
Func _ARRAY1DTOHISTOGRAM($aarray, $isizing = 0x64)
    If UBound($aarray, 0x0) > 0x1 Then Return SetError(0x1, 0x0, "")
    $isizing = $isizing * 0x8
    Local $t, $n, $imin = 0x0, $imax = 0x0, $ioffset = 0x0
    For $i = 0x0 To UBound($aarray) + 0xffffffff
        $t = $aarray[$i]
        $t = IsNumber($t) ? Round($t) : 0x0
        If $t < $imin Then $imin = $t
        If $t > $imax Then $imax = $t
    Next
    Local $irange = Int(Round(($imax - $imin) / 0x8)) * 0x8
    Local $ispaceratio = 0x4
    For $i = 0x0 To UBound($aarray) + 0xffffffff
        $t = $aarray[$i]
        If $t Then
            $n = Abs(Round(($isizing * $t) / $irange) / 0x8)
            $aarray[$i] = ""
            If $t > 0x0 Then
                If $imin Then
                    $ioffset = Int(Abs(Round(($isizing * $imin) / $irange) / 0x8) / 0x8 * $ispaceratio)
                    $aarray[$i] = __ARRAY_STRINGREPEAT(ChrW(0x20), $ioffset)
                EndIf
            Else
                If $imin <> $t Then
                    $ioffset = Int(Abs(Round(($isizing * ($t - $imin)) / $irange) / 0x8) / 0x8 * $ispaceratio)
                    $aarray[$i] = __ARRAY_STRINGREPEAT(ChrW(0x20), $ioffset)
                EndIf
            EndIf
            $aarray[$i] &= __ARRAY_STRINGREPEAT(ChrW(0x2588), Int($n / 0x8))
            $n = Mod($n, 0x8)
            If $n > 0x0 Then $aarray[$i] &= ChrW(0x2588 + 0x8 - $n)
            $aarray[$i] &= " " & $t
        Else
            $aarray[$i] = ""
        EndIf
    Next
    Return $aarray
EndFunc   ;==>_ARRAY1DTOHISTOGRAM
Func _ARRAY2DCREATE($acol0, $acol1)
    If (UBound($acol0, 0x0) <> 0x1) Or (UBound($acol1, 0x0) <> 0x1) Then Return SetError(0x1, 0x0, "")
    Local $nrows = UBound($acol0)
    If $nrows <> UBound($acol1) Then Return SetError(0x2, 0x0, "")
    Local $atmp[$nrows][0x2]
    For $i = 0x0 To $nrows + 0xffffffff
        $atmp[$i][0x0] = $acol0[$i]
        $atmp[$i][0x1] = $acol1[$i]
    Next
    Return $atmp
EndFunc   ;==>_ARRAY2DCREATE
Func __ARRAY_STRINGREPEAT($sstring, $irepeatcount)
    $irepeatcount = Int($irepeatcount)
    If StringLen($sstring) < 0x1 Or $irepeatcount <= 0x0 Then Return SetError(0x1, 0x0, "")
    Local $sresult = ""
    While $irepeatcount > 0x1
        If BitAND($irepeatcount, 0x1) Then $sresult &= $sstring
        $sstring &= $sstring
        $irepeatcount = BitShift($irepeatcount, 0x1)
    WEnd
    Return $sstring & $sresult
EndFunc   ;==>__ARRAY_STRINGREPEAT
Func __ARRAY_EXETERINTERNAL(ByRef $aarray, $istart, $isize, $sdelimiter, ByRef $aidx, ByRef $aresult, ByRef $icount)
    If $istart == $isize + 0xffffffff Then
        For $i = 0x0 To $isize + 0xffffffff
            $aresult[$icount] &= $aarray[$aidx[$i]] & $sdelimiter
        Next
        If $sdelimiter <> "" Then $aresult[$icount] = StringTrimRight($aresult[$icount], StringLen($sdelimiter))
        $icount += 0x1
    Else
        Local $itemp
        For $i = $istart To $isize + 0xffffffff
            $itemp = $aidx[$i]
            $aidx[$i] = $aidx[$istart]
            $aidx[$istart] = $itemp
            __ARRAY_EXETERINTERNAL($aarray, $istart + 0x1, $isize, $sdelimiter, $aidx, $aresult, $icount)
            $aidx[$istart] = $aidx[$i]
            $aidx[$i] = $itemp
        Next
    EndIf
EndFunc   ;==>__ARRAY_EXETERINTERNAL
Func __ARRAY_COMBINATIONS($in, $ir)
    Local $i_total = 0x1
    For $i = $ir To 0x1 Step +0xffffffff
        $i_total *= ($in / $i)
        $in -= 0x1
    Next
    Return Round($i_total)
EndFunc   ;==>__ARRAY_COMBINATIONS
Func __ARRAY_GETNEXT($in, $ir, ByRef $ileft, $itotal, ByRef $aidx)
    If $ileft == $itotal Then
        $ileft -= 0x1
        Return
    EndIf
    Local $i = $ir + 0xffffffff
    While $aidx[$i] == $in - $ir + $i
        $i -= 0x1
    WEnd
    $aidx[$i] += 0x1
    For $j = $i + 0x1 To $ir + 0xffffffff
        $aidx[$j] = $aidx[$i] + $j - $i
    Next
    $ileft -= 0x1
EndFunc   ;==>__ARRAY_GETNEXT
Func __ARRAY_MINMAXINDEX(Const ByRef $aarray, $icompnumeric, $istart, $iend, $isubitem, $fucomparison)
    If $icompnumeric = Default Then $icompnumeric = 0x0
    If $icompnumeric <> 0x1 Then $icompnumeric = 0x0
    If $istart = Default Then $istart = 0x0
    If $iend = Default Then $iend = 0x0
    If $isubitem = Default Then $isubitem = 0x0
    If Not IsArray($aarray) Then Return SetError(0x1, 0x0, +0xffffffff)
    Local $idim_1 = UBound($aarray, $ubound_rows) + 0xffffffff
    If $idim_1 < 0x0 Then Return SetError(0x1, 0x0, +0xffffffff)
    If $iend = +0xffffffff Then $iend = $idim_1
    If $istart = +0xffffffff Then $istart = 0x0
    If $istart < +0xffffffff Or $iend < +0xffffffff Then Return SetError(0x3, 0x0, +0xffffffff)
    If $istart > $idim_1 Or $iend > $idim_1 Then Return SetError(0x3, 0x0, +0xffffffff)
    If $istart > $iend Then Return SetError(0x4, 0x0, +0xffffffff)
    If $idim_1 < 0x0 Then Return SetError(0x5, 0x0, +0xffffffff)
    Local $imaxminindex = $istart
    Switch UBound($aarray, $ubound_dimensions)
        Case 0x1
            If $icompnumeric Then
                For $i = $istart To $iend
                    If $FUCOMPARISON(Number($aarray[$i]), Number($aarray[$imaxminindex])) Then $imaxminindex = $i
                Next
            Else
                For $i = $istart To $iend
                    If $FUCOMPARISON($aarray[$i], $aarray[$imaxminindex]) Then $imaxminindex = $i
                Next
            EndIf
        Case 0x2
            If $isubitem < 0x0 Or $isubitem > UBound($aarray, $ubound_columns) + 0xffffffff Then Return SetError(0x6, 0x0, +0xffffffff)
            If $icompnumeric Then
                For $i = $istart To $iend
                    If $FUCOMPARISON(Number($aarray[$i][$isubitem]), Number($aarray[$imaxminindex][$isubitem])) Then $imaxminindex = $i
                Next
            Else
                For $i = $istart To $iend
                    If $FUCOMPARISON($aarray[$i][$isubitem], $aarray[$imaxminindex][$isubitem]) Then $imaxminindex = $i
                Next
            EndIf
        Case Else
            Return SetError(0x2, 0x0, +0xffffffff)
    EndSwitch
    Return $imaxminindex
EndFunc   ;==>__ARRAY_MINMAXINDEX
Func __ARRAY_GREATERTHAN($vvalue1, $vvalue2)
    Return $vvalue1 > $vvalue2
EndFunc   ;==>__ARRAY_GREATERTHAN
Func __ARRAY_LESSTHAN($vvalue1, $vvalue2)
    Return $vvalue1 < $vvalue2
EndFunc   ;==>__ARRAY_LESSTHAN
Func __ARRAYUNIQUE_AUTOERRFUNC()
EndFunc   ;==>__ARRAYUNIQUE_AUTOERRFUNC
#region ### START Koda GUI section ### Form=e:\ctf\ctf_challenge\kcscctf-2022\flag checker\flagchecker.kxf
$bgui = GUICreate("Flag Checker", 0x13a, 0x88, 0xc0, 0x7c)
$iflag = GUICtrlCreateInput("", 0x50, 0x41, 0xc9, 0x15)
GUICtrlCreateLabel("FLAG CHECKER", 0x60, 0x10, 0x88, 0x1b)
GUICtrlSetFont(+0xffffffff, 0xf, 0x320, 0x0, "Consolas")
GUICtrlCreateLabel("Enter flag: ", 0x16, 0x44, 0x37, 0x11)
$bntcheck = GUICtrlCreateButton("Check", 0x70, 0x63, 0x4b, 0x19)
GUISetState(@SW_SHOW)
#endregion ### END Koda GUI section ###
While 0x1
    $nmsg = GUIGetMsg()
    Switch $nmsg
        Case $gui_event_close
            Exit
        Case $bntcheck
            CHECKER()
            Sleep(0x64)
    EndSwitch
WEnd
Func CHECKER()
    Local $input = GUICtrlRead($iflag)
    Local $len_input = StringLen($input)
    Local $opcode = "0x558bec83ec6c8d45d850e8aa05000083c4048d4d94518d55d8" & "52e8cb03000083c408e80c0000007573657233322e646c6c00" & "00ff55d88945f8837df8007505e9fb000000e80c0000004d65" & "7373616765426f7841008b45f850e8b306000083c4088945f0" & "8b4d0851ff55e883f81c740b8b550cc60200e9c4000000c645" & "bcf8c645bd50c645beccc645bfefc645c0e6c645c13cc645c2" & "35c645c396c645c41dc645c561c645c6aec645c7c0c645c8c5" & "c645c931c645cacec645cbb0c645cce7c645cd1dc645ceedc6" & "45cfbcc645d05dc645d181c645d269c645d38ac645d435c645" & "d574c645d657c645d7b68b4508508d4d94518d55d852e84700" & "000083c40c8945f4c745fc00000000eb098b45fc83c0018945" & "fc837dfc1c7d1f8b4df4034dfc0fb6118b45fc0fb64c05bc3b" & "d174088b550cc60200eb08ebd28b450cc600018be55dc3558b" & "ec83ec445657b90b000000e82c00000068747470733a2f2f77" & "77772e796f75747562652e636f6d2f77617463683f763d6451" & "773477395767586351005e8d7dbcf3a5c745f800000000c745" & "f400000000c745fc000000008b4510508b4d088b5110ffd289" & "45ec6a006a016a006a008d45f8508b4d0c8b11ffd285c07507" & "33c0e91b0200008d45f4506a006a0068048000008b4df8518b" & "550c8b420cffd085c075156a008b4df8518b550c8b4224ffd0" & "33c0e9e9010000837df40075156a008b4df8518b550c8b4224" & "ffd033c0e9ce0100006a008d4dbc518b55088b4210ffd0508d" & "4dbc518b55f4528b450c8b4808ffd185c075218b55f4528b45" & "0c8b481cffd16a008b55f8528b450c8b4824ffd133c0e98a01" & "00008d55fc526a008b45f45068016800008b4df8518b550c8b" & "4214ffd085c075218b4df4518b550c8b421cffd06a008b4df8" & "518b550c8b4224ffd033c0e94a0100008b4df4518b550c8b42" & "1cffd06a008d4dec516a006a006a016a008b55fc528b450c8b" & "4810ffd185c07527837dfc0074218b55fc528b450c8b4820ff" & "d16a008b55f8528b450c8b4824ffd133c0e9f90000006a0468" & "001000008b55ec83c201526a008b45088b4808ffd18945e883" & "7de8007527837dfc0074218b55fc528b450c8b4820ffd16a00" & "8b55f8528b450c8b4824ffd133c0e9b10000008b55ec83c201" & "528b45e850e8cc06000083c408c745f000000000eb098b4df0" & "83c101894df08b55f03b55ec73128b45e80345f08b4d10034d" & "f08a118810ebdd8b4510508b4d088b5110ffd2508d45ec508b" & "4de8516a006a016a008b55fc528b450c8b4810ffd185c07524" & "837dfc00741e8b55fc528b450c8b4820ffd16a008b55f8528b" & "450c8b4824ffd133c0eb23837dfc00741a8b55fc528b450c8b" & "4820ffd16a008b55f8528b450c8b4824ffd18b45e85f5e8be5" & "5dc3558bec51e81000000061647661706933322e646c6c0000" & "00008b45088b08ffd18945fc837dfc00750732c0e99b010000" & "e818000000437279707441637175697265436f6e7465787441" & "000000008b55fc52e8d102000083c4088b4d0c8901e8100000" & "00437279707443726561746548617368008b55fc52e8ab0200" & "0083c4088b4d0c89410ce8100000004372797074496d706f72" & "744b657900008b55fc52e88402000083c4088b4d0c894104e8" & "1000000043727970744465726976654b657900008b55fc52e8" & "5d02000083c4088b4d0c894114e81000000043727970744861" & "7368446174610000008b55fc52e83602000083c4088b4d0c89" & "4108e8100000004372797074456e6372797074000000008b55" & "fc52e80f02000083c4088b4d0c894110e81400000043727970" & "7447657448617368506172616d0000008b55fc52e8e4010000" & "83c4088b4d0c894118e814000000437279707444657374726f" & "7948617368000000008b55fc52e8b901000083c4088b4d0c89" & "411ce810000000437279707444657374726f794b6579008b55" & "fc52e89201000083c4088b4d0c894120e81400000043727970" & "7452656c65617365436f6e74657874008b55fc52e867010000" & "83c4088b4d0c894124b0018be55dc3558bec83ec18e81c0000" & "006b00650072006e0065006c00330032002e0064006c006c00" & "00000000e88602000083c4048945fc837dfc00750732c0e915" & "010000e8100000004c6f61644c69627261727941000000008b" & "45fc50e8fb00000083c4088945f8837df800750732c0e9e400" & "0000e81000000047657450726f634164647265737300008b4d" & "fc51e8ca00000083c4088945f4837df400750732c0e9b30000" & "00e8100000005669727475616c416c6c6f63000000008b55fc" & "52e89900000083c4088945f0837df000750732c0e982000000" & "e80c0000005669727475616c46726565008b45fc50e86c0000" & "0083c4088945ec837dec00750432c0eb58e80c0000006c7374" & "726c656e41000000008b4dfc51e84200000083c4088945e883" & "7de800750432c0eb2e8b55088b45f889028b4d088b55f48951" & "048b45088b4df08948088b55088b45ec89420c8b4d088b55e8" & "895110b0018be55dc3558bec83ec3c8b45088945ec8b4dec0f" & "b71181fa4d5a0000740733c0e9350100008b45ec8b4d080348" & "3c894de4ba080000006bc2008b4de48d5401788955e88b45e8" & "833800750733c0e9080100008b4de88b118955e08b45e00345" & "088945f48b4df48b51188955dc8b45f48b481c894dd08b55f4" & "8b42208945d88b4df48b51248955d4c745f800000000eb098b" & "45f883c0018945f88b4df83b4ddc0f83b30000008b55080355" & "d88b45f88d0c82894dc88b55080355d48b45f88d0c42894dcc" & "8b55080355d08b45cc0fb7088d148a8955c48b45c88b4d0803" & "08894df0c745fc00000000c745fc00000000eb098b55fc83c2" & "018955fc8b450c0345fc0fbe0885c974278b55f00355fc0fbe" & "0285c0741a8b4d0c034dfc0fbe118b45f00345fc0fbe083bd1" & "7402eb02ebc38b550c0355fc0fbe0285c075198b4df0034dfc" & "0fbe1185d2750c8b45c48b4d0803088bc1eb07e938ffffff33" & "c08be55dc3558bec83ec34c745e40000000064a13000000089" & "45e48b4de48b510c8955d88b45d88b480c8b5010894dcc8955" & "d08b45cc8945d48b4dd4894de8837de8000f845a0100008b55" & "e8837a18000f844d0100008b45e8837830007502ebde8b4de8" & "8b51308955ecc745f000000000c745f000000000eb098b45f0" & "83c0018945f08b4df08b55080fb7044a85c00f84dd0000008b" & "4df08b55ec0fb7044a85c00f84cb0000008b4df08b55080fb7" & "044a83f85a7f378b4df08b55080fb7044a83f8417c288b4df0" & "8b55080fb7044a83c0208945e08b4df08b5508668b45e06689" & "044a668b4de066894dfeeb0e8b55f08b4508668b0c5066894d" & "fe668b55fe668955f88b45f08b4dec0fb7144183fa5a7f378b" & "45f08b4dec0fb7144183fa417c288b45f08b4dec0fb7144183" & "c2208955dc8b45f08b4dec668b55dc66891441668b45dc6689" & "45fceb0e8b4df08b55ec668b044a668945fc668b4dfc66894d" & "f40fb755f80fb745f43bd07402eb05e908ffffff8b4df08b55" & "080fb7044a85c075168b4df08b55ec0fb7044a85c075088b4d" & "e88b4118eb0f8b55e88b028945e8e99cfeffff33c08be55dc3" & "558bec518b45088945fc837d0c00741a8b4dfcc601008b55fc" & "83c2018955fc8b450c83e80189450cebe08b45088be55dc300" & "00000000000000000000000000000000000000000000000000" & "00000000000000000000000000000000000000000000000000" & "00000000000000000000000000000000000000000000000000" & "00000000000000000000000000000000000000000000000000" & "00000000000000000000000000000000000000000000000000" & "00000000000000000000000000000000000000000000000000" & "00000000000000000000000000000000000000000000000000" & "00000000000000000000000000000000000000000000000000" & "00000000000000000000000000000000000000000000000000" & "00000000000000000000000000000000000000000000000000" & "00000000000000000000000000000000000000000000000000" & "00000000000000000000000000000000000000000000000000" & "00000000000000000000000000000000000000000000000000" & "00000000000000000000000000000000000000000000000000" & "00000000000000000000000000000000000000000000000000" & "00000000000000000000000000000000000000000000000000" & "00000000000000000000000000000000000000000000000000" & "00000000000000000000000000000000000000000000"
    Local $opcode_buf = DllStructCreate("byte[" & BinaryLen($opcode) & "]")
    DllStructSetData($opcode_buf, 0x1, Binary($opcode))
    Local $input_buf = DllStructCreate("byte[" & BinaryLen($input) + 0x1 & "]")
    DllStructSetData($input_buf, 0x1, Binary($input))
    Local $is_flag = DllStructCreate("byte[1]")
    DllStructSetData($is_flag, 0x1, Binary("0x00"))
    DllCall("user32.dll", "none", "CallWindowProcA", "ptr", DllStructGetPtr($opcode_buf), "ptr", DllStructGetPtr($input_buf), "ptr", DllStructGetPtr($is_flag), "int", 0x0, "int", 0x0)
    If DllStructGetData($is_flag, 0x1) == "0x01" Then
        MsgBox(0x0, "", "Correct!")
    Else
        MsgBox($mb_iconerror, "", "Incorrect!")
    EndIf
EndFunc   ;==>CHECKER